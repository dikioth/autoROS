{"ast":null,"code":"import mapValues from 'lodash/mapValues';\nimport pickBy from 'lodash/pickBy';\nimport ContainerDimensions from 'react-container-dimensions';\nimport { createSelector } from 'reselect';\nimport normalizeWheel from 'normalize-wheel';\nimport debounce from 'lodash/debounce';\nimport createREGL from 'regl';\nimport shallowequal from 'shallowequal';\nimport last from 'lodash/last';\nimport omit from 'lodash/omit';\nimport flatten from 'lodash/flatten';\nimport distance from 'distance-to-line-segment';\nimport earcut from 'earcut';\nimport TinySDF from '@mapbox/tiny-sdf';\nimport memoizeOne from 'memoize-one';\nimport _objectSpread from '@babel/runtime/helpers/objectSpread';\nimport { vec4, vec3, quat, mat4, mat3 } from 'gl-matrix';\nimport memoizeWeak from 'memoize-weak';\nimport _objectWithoutProperties from '@babel/runtime/helpers/objectWithoutProperties';\nimport _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport _extends from '@babel/runtime/helpers/extends';\nimport React__default, { Component, createRef, createElement, Fragment, memo, useState, useEffect, useCallback, useDebugValue, useContext } from 'react'; //  Copyright (c) 2018-present, GM Cruise LLC\n//\n//  This source code is licensed under the Apache License, Version 2.0,\n//  found in the LICENSE file in the root directory of this source tree.\n//  You may not use this file except in compliance with the License.\n\nclass BoundingBox {\n  constructor(left, top) {\n    _defineProperty(this, \"left\", void 0);\n\n    _defineProperty(this, \"right\", void 0);\n\n    _defineProperty(this, \"top\", void 0);\n\n    _defineProperty(this, \"bottom\", void 0);\n\n    _defineProperty(this, \"width\", void 0);\n\n    _defineProperty(this, \"height\", void 0);\n\n    this.left = left;\n    this.top = top;\n    this.right = -left;\n    this.bottom = -top;\n    this.width = Math.abs(left) * 2;\n    this.height = Math.abs(top) * 2;\n  }\n\n}\n\nfunction getOrthographicBounds(zDistance, width, height) {\n  const aspect = width / height; // never go below ground level\n\n  const distanceToGround = Math.abs(zDistance);\n  const left = -distanceToGround / 2 * aspect;\n  const top = distanceToGround / 2;\n  return new BoundingBox(left, top);\n} //  Copyright (c) 2018-present, GM Cruise LLC\n\n\nconst NEAR_RANGE = 0;\nconst FAR_RANGE = 1;\nconst tmp4 = [0, 0, 0, 0];\n\nfunction cameraProject(out, vec, viewport, combinedProjView) {\n  const vX = viewport[0],\n        vY = viewport[1],\n        vWidth = viewport[2],\n        vHeight = viewport[3],\n        n = NEAR_RANGE,\n        f = FAR_RANGE; // convert: clip space -> NDC -> window coords\n  // implicit 1.0 for w component\n\n  vec4.set(tmp4, vec[0], vec[1], vec[2], 1.0); // transform into clip space\n\n  vec4.transformMat4(tmp4, tmp4, combinedProjView); // now transform into NDC\n\n  const w = tmp4[3];\n\n  if (w !== 0) {\n    // how to handle infinity here?\n    tmp4[0] = tmp4[0] / w;\n    tmp4[1] = tmp4[1] / w;\n    tmp4[2] = tmp4[2] / w;\n  } // and finally into window coordinates\n  // the foruth component is (1/clip.w)\n  // which is the same as gl_FragCoord.w\n\n\n  out[0] = vX + vWidth / 2 * tmp4[0] + (0 + vWidth / 2);\n  out[1] = vY + vHeight / 2 * tmp4[1] + (0 + vHeight / 2);\n  out[2] = (f - n) / 2 * tmp4[2] + (f + n) / 2;\n  out[3] = w === 0 ? 0 : 1 / w;\n  return out;\n} //  Copyright (c) 2018-present, GM Cruise LLC\n//\n//  This source code is licensed under the Apache License, Version 2.0,\n//  found in the LICENSE file in the root directory of this source tree.\n//  You may not use this file except in compliance with the License.\n\n\nconst rotateGLSL = `\n  uniform vec3 _position;\n  uniform vec4 _rotation;\n\n  // rotate a 3d point v by a rotation quaternion q\n  vec3 rotate(vec3 v, vec4 q) {\n    vec3 temp = cross(q.xyz, v) + q.w * v;\n    return v + (2.0 * cross(q.xyz, temp));\n  }\n\n  vec3 applyPose(vec3 point) {\n    // rotate the point and then add the position of the pose\n    return rotate(point, _rotation) + _position;\n  }\n`;\nconst DEFAULT_TEXT_COLOR = {\n  r: 1,\n  g: 1,\n  b: 1,\n  a: 1\n};\n\nconst pointToVec3 = ({\n  x,\n  y,\n  z\n}) => {\n  return [x, y, z];\n};\n\nconst orientationToVec4 = ({\n  x,\n  y,\n  z,\n  w\n}) => {\n  return [x, y, z, w];\n};\n\nconst vec3ToPoint = ([x, y, z]) => ({\n  x,\n  y,\n  z\n});\n\nconst vec4ToOrientation = ([x, y, z, w]) => ({\n  x,\n  y,\n  z,\n  w\n});\n\nconst pointToVec3Array = points => {\n  const result = new Float32Array(points.length * 3);\n  let i = 0;\n\n  for (const _ref of points) {\n    const {\n      x,\n      y,\n      z\n    } = _ref;\n    result[i++] = x;\n    result[i++] = y;\n    result[i++] = z;\n  }\n\n  return result;\n};\n\nconst toRGBA = val => {\n  return [val.r, val.g, val.b, val.a];\n};\n\nconst vec4ToRGBA = color => ({\n  r: color[0],\n  g: color[1],\n  b: color[2],\n  a: color[3]\n});\n\nfunction getCSSColor(color = DEFAULT_TEXT_COLOR) {\n  const {\n    r,\n    g,\n    b,\n    a\n  } = color;\n  return `rgba(${(r * 255).toFixed()}, ${(g * 255).toFixed()}, ${(b * 255).toFixed()}, ${a.toFixed(3)})`;\n}\n\nconst toRGBAArray = colors => {\n  const result = new Float32Array(colors.length * 4);\n  let i = 0;\n\n  for (const _ref2 of colors) {\n    const {\n      r,\n      g,\n      b,\n      a\n    } = _ref2;\n    result[i++] = r;\n    result[i++] = g;\n    result[i++] = b;\n    result[i++] = a;\n  }\n\n  return result;\n};\n\nconst constantRGBAArray = (count, {\n  r,\n  g,\n  b,\n  a\n}) => {\n  const result = new Float32Array(count * 4);\n\n  for (let i = 0; i < count; i++) {\n    result[4 * i + 0] = r;\n    result[4 * i + 1] = g;\n    result[4 * i + 2] = b;\n    result[4 * i + 3] = a;\n  }\n\n  return result;\n}; // default blend func params to be mixed into regl commands\n\n\nconst defaultReglBlend = {\n  enable: true,\n  // this is the same gl.BlendFunc used by three.js by default\n  func: {\n    src: \"src alpha\",\n    dst: \"one minus src alpha\",\n    srcAlpha: 1,\n    dstAlpha: \"one minus src alpha\"\n  },\n  equation: {\n    rgb: \"add\",\n    alpha: \"add\"\n  }\n};\nconst defaultReglDepth = {\n  enable: true,\n  mask: true\n};\nconst defaultDepth = {\n  enable: (context, props) => props.depth && props.depth.enable || defaultReglDepth.enable,\n  mask: (context, props) => props.depth && props.depth.mask || defaultReglDepth.mask\n};\n\nconst defaultBlend = _objectSpread({}, defaultReglBlend, {\n  enable: (context, props) => props.blend && props.blend.enable || defaultReglBlend.enable,\n  func: (context, props) => props.blend && props.blend.func || defaultReglBlend.func\n}); // TODO: deprecating, remove before 1.x release\n\n\nconst blend = defaultBlend; // takes a regl command definition object and injects\n// position and rotation from the object pose and also\n// inserts some glsl helpers to apply the pose to points in a fragment shader\n\nfunction withPose(command) {\n  const {\n    vert,\n    uniforms\n  } = command;\n  const newVert = vert.replace(\"#WITH_POSE\", rotateGLSL);\n\n  const newUniforms = _objectSpread({}, uniforms, {\n    _position: (context, props) => {\n      const {\n        position\n      } = props.pose;\n      return Array.isArray(position) ? position : pointToVec3(position);\n    },\n    _rotation: (context, props) => {\n      const {\n        orientation: r\n      } = props.pose;\n      return Array.isArray(r) ? r : [r.x, r.y, r.z, r.w];\n    }\n  });\n\n  return _objectSpread({}, command, {\n    vert: newVert,\n    uniforms: newUniforms\n  });\n}\n\nfunction getVertexColors({\n  colors,\n  color,\n  points\n}) {\n  if ((!colors || !colors.length) && color) {\n    return constantRGBAArray(points.length, color);\n  }\n\n  if (colors) {\n    // $FlowFixMe this will go away once we consolidate getVertexColors and colorBuffer\n    return shouldConvert(colors) ? toRGBAArray(colors) : colors;\n  }\n\n  return [];\n}\n\nfunction hasNestedArrays(arr) {\n  return arr.length && Array.isArray(arr[0]);\n} // Returns a function which accepts a single color, an array of colors, and the number of instances,\n// and returns a color attribute buffer for use in regl.\n// If there are multiple colors in the colors array, one color will be assigned to each instance.\n// In the case of a single color, the same color will be used for all instances.\n\n\nfunction colorBuffer(regl) {\n  const buffer = regl.buffer({\n    usage: \"dynamic\",\n    data: []\n  });\n  return function (color, colors, length) {\n    let data, divisor;\n\n    if (!colors || !colors.length) {\n      data = shouldConvert(color) ? toRGBA(color) : color;\n      divisor = length;\n    } else {\n      data = shouldConvert(colors) ? toRGBAArray(colors) : colors;\n      divisor = 1;\n    }\n\n    return {\n      buffer: buffer({\n        usage: \"dynamic\",\n        data\n      }),\n      divisor\n    };\n  };\n} // used to determine if the input/array of inputs is an object like {r: 0, g: 0, b: 0} or [0,0,0]\n\n\nfunction shouldConvert(props) {\n  if (!props || hasNestedArrays(props) || !isNaN(props[0])) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction intToRGB(i = 0) {\n  const r = (i >> 16 & 255) / 255;\n  const g = (i >> 8 & 255) / 255;\n  const b = (i & 255) / 255;\n  return [r, g, b, 1];\n}\n\nfunction getIdFromColor(rgb) {\n  const r = rgb[0] * 255;\n  const g = rgb[1] * 255;\n  const b = rgb[2] * 255;\n  return b | g << 8 | r << 16;\n}\n\nfunction getIdFromPixel(rgb) {\n  const r = rgb[0];\n  const g = rgb[1];\n  const b = rgb[2];\n  return b | g << 8 | r << 16;\n} // gl-matrix clone of three.js Vector3.setFromSpherical\n// phi: polar angle (between poles, 0 - pi)\n// theta: azimuthal angle (around equator, 0 - 2pi)\n\n\nfunction fromSpherical(out, r, theta, phi) {\n  const rSinPhi = r * Math.sin(phi);\n  out[0] = rSinPhi * Math.sin(theta);\n  out[1] = r * Math.cos(phi);\n  out[2] = rSinPhi * Math.cos(theta);\n  return out;\n} //  Copyright (c) 2018-present, GM Cruise LLC\n\n\nconst UNIT_X_VECTOR = Object.freeze([1, 0, 0]); // reusable arrays for intermediate calculations\n\nconst TEMP_VEC3 = [0, 0, 0];\nconst TEMP_MAT = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\nconst TEMP_QUAT = [0, 0, 0, 0];\n\nconst stateSelector = state => state;\n\nconst perspectiveSelector = createSelector(stateSelector, ({\n  perspective\n}) => perspective);\nconst distanceSelector = createSelector(stateSelector, ({\n  distance: distance$$1\n}) => distance$$1);\nconst phiSelector = createSelector(stateSelector, ({\n  phi\n}) => phi);\nconst thetaOffsetSelector = createSelector(stateSelector, ({\n  thetaOffset\n}) => thetaOffset);\nconst targetOrientationSelector = createSelector(stateSelector, ({\n  targetOrientation\n}) => targetOrientation); // the heading direction of the target\n\nconst targetHeadingSelector = createSelector(targetOrientationSelector, targetOrientation => {\n  const out = vec3.transformQuat(TEMP_VEC3, UNIT_X_VECTOR, targetOrientation);\n  const heading = -Math.atan2(out[1], out[0]);\n  return heading;\n}); // orientation of the camera\n\nconst orientationSelector = createSelector(perspectiveSelector, phiSelector, thetaOffsetSelector, (perspective, phi, thetaOffset) => {\n  const result = quat.identity([0, 0, 0, 0]);\n  quat.rotateZ(result, result, -thetaOffset); // phi is ignored in 2D mode\n\n  if (perspective) {\n    quat.rotateX(result, result, phi);\n  }\n\n  return result;\n}); // position of the camera\n\nconst positionSelector = createSelector(thetaOffsetSelector, phiSelector, distanceSelector, (thetaOffset, phi, distance$$1) => {\n  const position = fromSpherical([], distance$$1, thetaOffset, phi); // poles are on the y-axis in spherical coordinates; rearrange so they are on the z axis\n\n  const [x, y, z] = position;\n  position[0] = -x;\n  position[1] = -z;\n  position[2] = y;\n  return position;\n});\n/*\nGet the view matrix, which transforms points from world coordinates to camera coordinates.\n\nAn equivalent and easier way to think about this transformation is that it takes the camera from\nits actual position/orientation in the world, and moves it to have position=0,0,0 and orientation=0,0,0,1.\n\nWe build up this transformation in 5 steps as demonstrated below:\n   T = target\n   < = direction of target\n   * = target with offset (position that the camera is looking at)\n   C = camera (always points toward *)\n\nStarting point: actual positions in world coordinates\n\n  |      *\n  |  <T   C\n  |\n  +--------\n\nStep 1: translate target to the origin\n\n  |\n  |  *\n <T---C----\n\nStep 2: rotate around the origin so the target points forward\n(Here we use the target's heading only, ignoring other components of its rotation)\n\n  |\n  ^\n  T--------\n  |\n  | *\n  C\n\nStep 3: translate the target-with-offset point to be at the origin\n\n ^\n T|\n  |\n  *--------\n C|\n  |\n\n\nStep 4: translate the camera to be at the origin\n(Steps 3 and 4 are both translations, but they're kept separate because it's easier\nto conceptualize: 3 uses the targetOffset and 4 uses the distance+thetaOffset+phi.)\n\n ^\n T\n |\n |*\n C--------\n |\n\nStep 5: rotate the camera to point forward\n\n \\\n  T  |\n     *\n     C--------\n     |\n\n*/\n\nconst viewSelector = createSelector(stateSelector, orientationSelector, positionSelector, targetHeadingSelector, ({\n  target,\n  targetOffset,\n  perspective\n}, orientation, position, targetHeading) => {\n  const m = mat4.identity([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]); // apply the steps described above in reverse because we use right-multiplication\n  // 5. rotate camera to point forward\n\n  mat4.multiply(m, m, mat4.fromQuat(TEMP_MAT, quat.invert(TEMP_QUAT, orientation))); // 4. move camera to the origin\n\n  if (perspective) {\n    mat4.translate(m, m, vec3.negate(TEMP_VEC3, position));\n  } // 3. move center to the origin\n\n\n  mat4.translate(m, m, vec3.negate(TEMP_VEC3, targetOffset)); // 2. rotate target to point forward\n\n  mat4.rotateZ(m, m, targetHeading); // 1. move target to the origin\n\n  vec3.negate(TEMP_VEC3, target);\n\n  if (!perspective) {\n    // if using orthographic camera ensure the distance from \"ground\"\n    // stays large so no reasonably tall item goes past the camera\n    TEMP_VEC3[2] = -2500;\n  }\n\n  mat4.translate(m, m, TEMP_VEC3);\n  return m;\n});\nconst billboardRotation = createSelector(orientationSelector, targetHeadingSelector, (orientation, targetHeading) => {\n  const m = mat4.identity(mat4.create());\n  mat4.rotateZ(m, m, -targetHeading);\n  mat4.multiply(m, m, mat4.fromQuat(TEMP_MAT, orientation));\n  return m;\n});\nvar selectors = {\n  orientation: orientationSelector,\n  position: positionSelector,\n  targetHeading: targetHeadingSelector,\n  view: viewSelector,\n  billboardRotation\n}; //  we use up on the +z axis\n\nconst UNIT_Z_VECTOR = Object.freeze([0, 0, 1]); // reusable array for intermediate calculations\n\nconst TEMP_QUAT$1 = [0, 0, 0, 0];\nconst DEFAULT_CAMERA_STATE = {\n  distance: 75,\n  perspective: true,\n  phi: Math.PI / 4,\n  target: [0, 0, 0],\n  targetOffset: [0, 0, 0],\n  targetOrientation: [0, 0, 0, 1],\n  thetaOffset: 0,\n  fovy: Math.PI / 4,\n  near: 0.01,\n  far: 5000\n};\n\nfunction distanceAfterZoom(startingDistance, zoomPercent) {\n  // keep distance above 0 so that percentage-based zoom always works\n  return Math.max(0.001, startingDistance * (1 - zoomPercent / 100));\n}\n\nclass CameraStore {\n  constructor(handler = () => {}, initialCameraState = DEFAULT_CAMERA_STATE) {\n    _defineProperty(this, \"state\", void 0);\n\n    _defineProperty(this, \"_onChange\", void 0);\n\n    _defineProperty(this, \"setCameraState\", state => {\n      // Fill in missing properties from DEFAULT_CAMERA_STATE.\n      // Mutate the `state` parameter instead of copying -- this\n      // matches the previous behavior of this method, which didn't\n      for (const [key, value] of Object.entries(DEFAULT_CAMERA_STATE)) {\n        if (state[key] == null) {\n          state[key] = value;\n        }\n      } // `state` must be a valid CameraState now, because we filled in\n      // missing properties from DEFAULT_CAMERA_STATE.\n\n\n      this.state = state;\n    });\n\n    _defineProperty(this, \"cameraRotate\", ([x, y]) => {\n      // This can happen in 2D mode, when both e.movementX and e.movementY are evaluated as negative and mouseX move is 0\n      if (x === 0 && y === 0) {\n        return;\n      }\n\n      const {\n        thetaOffset,\n        phi\n      } = this.state;\n      this.setCameraState(_objectSpread({}, this.state, {\n        thetaOffset: thetaOffset - x,\n        phi: Math.max(0, Math.min(phi + y, Math.PI))\n      }));\n\n      this._onChange(this.state);\n    });\n\n    _defineProperty(this, \"cameraMove\", ([x, y]) => {\n      // moveX and moveY both be 0 sometimes\n      if (x === 0 && y === 0) {\n        return;\n      }\n\n      const {\n        targetOffset,\n        thetaOffset\n      } = this.state; // rotate around z axis so the offset is in the target's reference frame\n\n      const result = [x, y, 0];\n      const offset = vec3.transformQuat(result, result, quat.setAxisAngle(TEMP_QUAT$1, UNIT_Z_VECTOR, -thetaOffset));\n      this.setCameraState(_objectSpread({}, this.state, {\n        targetOffset: vec3.add(offset, targetOffset, offset)\n      }));\n\n      this._onChange(this.state);\n    });\n\n    _defineProperty(this, \"cameraZoom\", zoomPercent => {\n      const {\n        distance: distance$$1\n      } = this.state;\n      const newDistance = distanceAfterZoom(distance$$1, zoomPercent);\n\n      if (distance$$1 === newDistance) {\n        return;\n      }\n\n      this.setCameraState(_objectSpread({}, this.state, {\n        distance: newDistance\n      }));\n\n      this._onChange(this.state);\n    });\n\n    this._onChange = handler;\n    this.setCameraState(initialCameraState);\n  }\n\n}\n\nconst TEMP_MAT$1 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]; // This is the regl command which encapsulates the camera projection and view matrices.\n// It adds the matrices to the regl context so they can be used by other commands.\n\nvar camera = regl => {\n  return class Camera {\n    constructor() {\n      _defineProperty(this, \"viewportWidth\", 0);\n\n      _defineProperty(this, \"viewportHeight\", 0);\n\n      _defineProperty(this, \"cameraState\", DEFAULT_CAMERA_STATE);\n\n      _defineProperty(this, \"draw\", regl({\n        // adds context variables to the regl context so they are accessible from commands\n        context: {\n          // use functions, not lambdas here to make sure we can access\n          // the regl supplied this scope: http://regl.party/api#this\n          projection(context, props) {\n            const {\n              viewportWidth,\n              viewportHeight\n            } = context; // save these variables on the camera instance\n            // because we need them for raycasting\n\n            this.viewportWidth = viewportWidth;\n            this.viewportHeight = viewportHeight;\n            this.cameraState = props;\n            return this.getProjection();\n          },\n\n          view(context, props) {\n            return this.getView();\n          },\n\n          // inverse of the view rotation, used for making objects always face the camera\n          billboardRotation(context, props) {\n            return selectors.billboardRotation(this.cameraState);\n          }\n\n        },\n        // adds view and projection as uniforms to every command\n        // and makes them available in the shaders\n        uniforms: {\n          view: regl.context(\"view\"),\n          billboardRotation: regl.context(\"billboardRotation\"),\n          projection: regl.context(\"projection\")\n        }\n      }));\n    }\n\n    getProjection() {\n      const {\n        near,\n        far,\n        distance: distance$$1,\n        fovy\n      } = this.cameraState;\n\n      if (!this.cameraState.perspective) {\n        const bounds = getOrthographicBounds(distance$$1, this.viewportWidth, this.viewportHeight);\n        const {\n          left,\n          right,\n          bottom,\n          top\n        } = bounds;\n        return mat4.ortho([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], left, right, bottom, top, near, far);\n      }\n\n      const aspect = this.viewportWidth / this.viewportHeight;\n      return mat4.perspective([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], fovy, aspect, near, far);\n    }\n\n    getView() {\n      return selectors.view(this.cameraState);\n    } // convert a point in 3D space to a point on the screen\n\n\n    toScreenCoord(viewport, point) {\n      const projection = this.getProjection();\n      const view = selectors.view(this.cameraState);\n      const combinedProjView = mat4.multiply(TEMP_MAT$1, projection, view);\n      const [x, y, z, w] = cameraProject([], point, viewport, combinedProjView);\n\n      if (z < 0 || z > 1 || w < 0) {\n        // resulting point is outside the window depth range\n        return undefined;\n      }\n\n      const diffY = viewport[3] + viewport[1];\n      const diffX = viewport[0]; // move the x value over based on the left of the viewport\n      // and move the y value over based on the bottom of the viewport\n\n      return [x - diffX, diffY - y, z];\n    }\n\n  };\n};\n\nconst PAN_SPEED = 4;\nconst MOUSE_ZOOM_SPEED = 0.3;\nconst KEYBOARD_MOVE_SPEED = 0.3;\nconst KEYBOARD_ZOOM_SPEED = 150;\nconst KEYBOARD_SPIN_SPEED = 1.5;\nconst DEFAULT_KEYMAP = {\n  KeyA: \"moveLeft\",\n  KeyD: \"moveRight\",\n  KeyE: \"rotateRight\",\n  KeyF: \"tiltUp\",\n  KeyQ: \"rotateLeft\",\n  KeyR: \"tiltDown\",\n  KeyS: \"moveDown\",\n  KeyW: \"moveUp\",\n  KeyX: \"zoomOut\",\n  KeyZ: \"zoomIn\"\n}; // attaches mouse and keyboard listeners to allow for moving the camera on user input\n\nclass CameraListener extends Component {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"_keyTimer\", void 0);\n\n    _defineProperty(this, \"_keys\", new Set());\n\n    _defineProperty(this, \"_buttons\", new Set());\n\n    _defineProperty(this, \"_listeners\", []);\n\n    _defineProperty(this, \"_shiftKey\", false);\n\n    _defineProperty(this, \"_metaKey\", false);\n\n    _defineProperty(this, \"_ctrlKey\", false);\n\n    _defineProperty(this, \"_el\", void 0);\n\n    _defineProperty(this, \"_rect\", void 0);\n\n    _defineProperty(this, \"_initialMouse\", void 0);\n\n    _defineProperty(this, \"_getMouseOnScreen\", mouse => {\n      const {\n        clientX,\n        clientY\n      } = mouse;\n      const {\n        top,\n        left,\n        width,\n        height\n      } = this._rect;\n      const x = (clientX - left) / width;\n      const y = (clientY - top) / height;\n      return [x, y];\n    });\n\n    _defineProperty(this, \"_onMouseDown\", e => {\n      const {\n        _el\n      } = this;\n\n      if (!_el) {\n        return;\n      }\n\n      e.preventDefault();\n\n      this._buttons.add(e.button);\n\n      _el.focus();\n\n      this._rect = _el.getBoundingClientRect();\n      this._initialMouse = this._getMouseOnScreen(e);\n      this.startDragging(e);\n    });\n\n    _defineProperty(this, \"_onWindowMouseMove\", e => {\n      if (!this._buttons.size) {\n        return;\n      }\n\n      this._shiftKey = e.shiftKey;\n      const {\n        cameraStore: {\n          cameraMove,\n          cameraRotate,\n          state: {\n            perspective\n          }\n        }\n      } = this.props; // compute the amount the mouse has moved\n\n      let moveX, moveY;\n\n      const mouse = this._getMouseOnScreen(e); // when pointer lock is enabled, we get movementX and movementY (with direction reversed)\n      // instead of the screenX/screenY changing... except, when using synergy, they come through\n      // like regular mousemove events.\n\n\n      if (document.pointerLockElement && (e.movementX || e.movementY)) {\n        moveX = -e.movementX / this._rect.width;\n        moveY = -e.movementY / this._rect.height;\n      } else {\n        moveX = this._initialMouse[0] - mouse[0];\n        moveY = this._initialMouse[1] - mouse[1];\n      }\n\n      this._initialMouse = mouse;\n\n      if (this._isRightMouseDown()) {\n        const magnitude = this._getMagnitude(PAN_SPEED); // in orthographic mode, flip the direction of rotation so \"left\" means \"counterclockwise\"\n\n\n        const x = (perspective ? moveX : -moveX) * magnitude; // do not rotate vertically in orthograhpic mode\n\n        const y = perspective ? moveY * magnitude : 0;\n        cameraRotate([x, y]);\n      }\n\n      if (this._isLeftMouseDown()) {\n        const {\n          x,\n          y\n        } = this._getMoveMagnitude();\n\n        cameraMove([this._getMagnitude(moveX * x), this._getMagnitude(-moveY * y)]);\n      }\n    });\n\n    _defineProperty(this, \"_onMouseUp\", e => {\n      this._buttons.delete(e.button);\n\n      this._endDragging();\n    });\n\n    _defineProperty(this, \"_onWindowMouseUp\", e => {\n      const {\n        _el\n      } = this;\n\n      if (!_el) {\n        return;\n      } // do nothing if this container had a mouseup, because we catch it in the onMouseUp handler\n\n\n      if (_el.contains(e.target) || e.target === _el) {\n        return;\n      } // If mouseup triggers on the window outside this container, clear any active interactions.\n      // This will allow a mouseup outside the browser window to be handled; otherwise the mouse\n      // \"sticks\" in a down position until another click on this element is received.\n\n\n      this._buttons.clear();\n\n      this._endDragging();\n    });\n\n    _defineProperty(this, \"_getKeyMotion\", code => {\n      const moveSpeed = this._getMagnitude(KEYBOARD_MOVE_SPEED);\n\n      const zoomSpeed = this._getMagnitude(KEYBOARD_ZOOM_SPEED);\n\n      const spinSpeed = this._getMagnitude(KEYBOARD_SPIN_SPEED);\n\n      const {\n        keyMap,\n        shiftKeys\n      } = this.props;\n      const action = keyMap && keyMap[code] || DEFAULT_KEYMAP[code] || false;\n\n      if (this._shiftKey && !shiftKeys) {\n        return null;\n      }\n\n      switch (action) {\n        case \"moveRight\":\n          return {\n            x: moveSpeed\n          };\n\n        case \"moveLeft\":\n          return {\n            x: -moveSpeed\n          };\n\n        case \"moveUp\":\n          return {\n            y: moveSpeed\n          };\n\n        case \"moveDown\":\n          return {\n            y: -moveSpeed\n          };\n\n        case \"zoomIn\":\n          return {\n            zoom: zoomSpeed\n          };\n\n        case \"zoomOut\":\n          return {\n            zoom: -zoomSpeed\n          };\n\n        case \"rotateLeft\":\n          return {\n            yaw: -spinSpeed\n          };\n\n        case \"rotateRight\":\n          return {\n            yaw: spinSpeed\n          };\n\n        case \"tiltUp\":\n          return {\n            tilt: -spinSpeed\n          };\n\n        case \"tiltDown\":\n          return {\n            tilt: spinSpeed\n          };\n\n        case false:\n          return null;\n\n        default:\n          console.warn(\"Unrecognized key action:\", action);\n          return null;\n      }\n    });\n\n    _defineProperty(this, \"_onKeyDown\", e => {\n      const {\n        keyMap\n      } = this.props;\n      this._shiftKey = e.shiftKey;\n      this._metaKey = e.metaKey;\n      this._ctrlKey = e.ctrlKey;\n      const code = e.nativeEvent.code; // ignore repeated keydown events\n\n      if (e.repeat || this._keys.has(code)) {\n        e.stopPropagation();\n        e.preventDefault();\n        return;\n      }\n\n      if (e.altKey || e.ctrlKey || e.metaKey) {\n        // we don't currently handle these modifiers\n        return;\n      } // allow null, false, or empty keymappings which explicitly cancel Worldview from processing that key\n\n\n      if (keyMap && code in keyMap && !keyMap[code]) {\n        return false;\n      } // if we respond to this key, start the update timer\n\n\n      if (this._getKeyMotion(code)) {\n        this._keys.add(code);\n\n        this._startKeyTimer();\n\n        e.stopPropagation();\n        e.preventDefault();\n      }\n    });\n\n    _defineProperty(this, \"_onKeyUp\", e => {\n      this._shiftKey = e.shiftKey;\n      this._metaKey = e.metaKey;\n      this._ctrlKey = e.ctrlKey;\n\n      this._keys.delete(e.nativeEvent.code);\n    });\n\n    _defineProperty(this, \"_onWheel\", e => {\n      // stop the wheel event here, as wheel propagation through the entire dom\n      // can cause the browser to slow down & thrash\n      e.preventDefault();\n      e.stopPropagation();\n      this._shiftKey = e.shiftKey; // with osx trackpad scrolling, slow to medium pixelY is around +/- 1 to 10\n      // external mouse wheels generally come in higher values around +/- 30 to 50\n\n      const {\n        pixelX,\n        pixelY\n      } = normalizeWheel(e); // shift+scroll on an external mouse may scroll in the X direction instead of Y\n\n      const wheelAmount = pixelY || pixelX; // we use positive value to indicate zooming in\n      // and negative value to zoom out, so reverse the direction of the wheel\n\n      const dir = Math.sign(wheelAmount) * -1;\n      const amount = Math.abs(wheelAmount); // restrict zoom percentage per tick to between 1 & 50 percent\n\n      const percentage = Math.max(1, Math.min(amount, 50)); // support shift+wheel magnitude adjustment\n\n      const zoomPercentage = this._getMagnitude(percentage * dir * MOUSE_ZOOM_SPEED);\n\n      this.props.cameraStore.cameraZoom(zoomPercentage);\n    });\n\n    _defineProperty(this, \"_onBlur\", e => {\n      this._keys = new Set();\n      this._ctrlKey = false;\n      this._shiftKey = false;\n      this._metaKey = false;\n\n      this._stopKeyTimer();\n    });\n\n    _defineProperty(this, \"_onContextMenu\", e => {\n      e.preventDefault();\n      e.stopPropagation();\n    });\n  }\n\n  componentDidMount() {\n    const {\n      _el\n    } = this;\n\n    if (!_el) {\n      return;\n    }\n\n    this._rect = _el.getBoundingClientRect();\n\n    const listen = (target, name, fn) => {\n      target.addEventListener(name, fn);\n\n      this._listeners.push({\n        target,\n        name,\n        fn\n      });\n    };\n\n    listen(document, \"blur\", this._onBlur);\n    listen(window, \"mouseup\", this._onWindowMouseUp);\n\n    _el.addEventListener(\"wheel\", this._onWheel, {\n      passive: false\n    });\n  }\n\n  componentWillUnmount() {\n    this._listeners.forEach(listener => {\n      listener.target.removeEventListener(listener.name, listener.fn);\n    });\n\n    this._endDragging();\n\n    const {\n      _el\n    } = this;\n\n    if (!_el) {\n      return;\n    }\n\n    _el.removeEventListener(\"wheel\", this._onWheel, {\n      passive: false\n    });\n  }\n\n  _isLeftMouseDown() {\n    return this._buttons.has(0);\n  }\n\n  _isRightMouseDown() {\n    return this._buttons.has(2);\n  }\n\n  _getMagnitude(base = 1) {\n    return this._shiftKey ? base / 10 : base;\n  }\n\n  _getMoveMagnitude() {\n    // avoid interference with drawing tools\n    if (this._ctrlKey) {\n      return {\n        x: 0,\n        y: 0\n      };\n    }\n\n    const {\n      cameraStore: {\n        state: {\n          distance: distance$$1,\n          perspective\n        }\n      }\n    } = this.props;\n\n    if (perspective) {\n      // in perspective mode its more like flying, so move by the magnitude\n      // we use the camera distance as a heuristic\n      return {\n        x: distance$$1,\n        y: distance$$1\n      };\n    } // in orthographic mode we know the exact viewable area\n    // which is a square so we can move exactly percentage within it\n\n\n    const {\n      width,\n      height\n    } = this._rect;\n    const bounds = getOrthographicBounds(distance$$1, width, height);\n    return {\n      x: bounds.width,\n      y: bounds.height\n    };\n  }\n\n  startDragging(e) {\n    if (e.button !== 0 && this._el && typeof this._el.requestPointerLock === \"function\") {\n      this._el.requestPointerLock();\n    }\n\n    window.addEventListener(\"mousemove\", this._onWindowMouseMove);\n  }\n\n  _endDragging() {\n    window.removeEventListener(\"mousemove\", this._onWindowMouseMove);\n\n    if (typeof document.exitPointerLock === \"function\") {\n      document.exitPointerLock();\n    }\n  }\n\n  _moveKeyboard(dt) {\n    const motion = {\n      x: 0,\n      y: 0,\n      zoom: 0,\n      yaw: 0,\n      tilt: 0\n    };\n\n    this._keys.forEach(code => {\n      const {\n        x = 0,\n        y = 0,\n        zoom = 0,\n        yaw = 0,\n        tilt = 0\n      } = this._getKeyMotion(code) || {};\n      motion.x += x;\n      motion.y += y;\n      motion.zoom += zoom;\n      motion.yaw += yaw;\n      motion.tilt += tilt;\n    });\n\n    const {\n      cameraStore: {\n        cameraMove,\n        cameraRotate,\n        cameraZoom,\n        state: {\n          perspective\n        }\n      }\n    } = this.props;\n\n    if (motion.x || motion.y) {\n      const {\n        x,\n        y\n      } = this._getMoveMagnitude();\n\n      cameraMove([motion.x * x * dt, motion.y * y * dt]);\n    }\n\n    if (motion.yaw || perspective && motion.tilt) {\n      cameraRotate([motion.yaw * dt, perspective ? motion.tilt * dt : 0]);\n    }\n\n    if (motion.zoom) {\n      cameraZoom(motion.zoom * dt);\n    }\n  }\n\n  _startKeyTimer(lastStamp) {\n    if (this._keyTimer) {\n      return;\n    }\n\n    this._keyTimer = requestAnimationFrame(stamp => {\n      this._moveKeyboard((lastStamp ? stamp - lastStamp : 0) / 1000);\n\n      this._keyTimer = undefined; // Only start the timer if keys are still pressed.\n      // We do this rather than stopping the timer in onKeyUp, because keys held\n      // sometimes actually trigger repeated keyup/keydown, rather than just repeated keydown.\n      // By checking currently-down keys in the requestAnimationFrame callback, we give the browser enough time to\n      // handle both the keyup and keydown before checking whether we should restart the timer.\n\n      if (this._keys.size) {\n        this._startKeyTimer(stamp);\n      }\n    });\n  }\n\n  _stopKeyTimer() {\n    if (this._keyTimer) {\n      cancelAnimationFrame(this._keyTimer);\n    }\n\n    this._keyTimer = undefined;\n  }\n\n  render() {\n    const {\n      children\n    } = this.props;\n    return createElement(\"div\", {\n      tabIndex: 0,\n      style: {\n        outline: \"none\"\n      },\n      draggable: true,\n      ref: el => this._el = el,\n      onMouseDown: this._onMouseDown,\n      onMouseUp: this._onMouseUp,\n      onBlur: this._onBlur,\n      onContextMenu: this._onContextMenu,\n      onKeyDown: this._onKeyDown,\n      onKeyUp: this._onKeyUp\n    }, children);\n  }\n\n} //  Copyright (c) 2018-present, GM Cruise LLC\n//  Copyright (c) 2018-present, GM Cruise LLC\n//\n//  This source code is licensed under the Apache License, Version 2.0,\n//  found in the LICENSE file in the root directory of this source tree.\n//  You may not use this file except in compliance with the License.\n\n\nfunction getNodeEnv() {\n  return process && process.env && process.env.NODE_ENV;\n}\n\nconst tempVec = [0, 0, 0];\nconst tempMat = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n\nclass Ray {\n  constructor(origin, dir, point) {\n    _defineProperty(this, \"origin\", void 0);\n\n    _defineProperty(this, \"dir\", void 0);\n\n    _defineProperty(this, \"point\", void 0);\n\n    this.origin = origin;\n    this.dir = dir;\n    this.point = point;\n  }\n\n  distanceToPoint(point) {\n    return vec3.distance(this.origin, point);\n  } // https://stackoverflow.com/questions/7168484/3d-line-segment-and-plane-intersection/35396994#35396994\n\n\n  planeIntersection(planeCoordinate, planeNormal) {\n    const d = vec3.dot(planeNormal, planeCoordinate);\n    const cosine = vec3.dot(planeNormal, this.dir);\n\n    if (cosine === 0) {\n      return null;\n    }\n\n    const x = d - vec3.dot(planeNormal, this.origin) / cosine;\n    const contact = vec3.add([0, 0, 0], this.origin, vec3.scale(tempVec, this.dir, x));\n    return contact;\n  }\n\n} // adapted from https://github.com/regl-project/regl/blob/master/example/raycast.js\n\n\nfunction getRayFromClick(camera, {\n  clientX,\n  clientY,\n  width,\n  height\n}) {\n  const projectionMatrix = camera.getProjection();\n  const viewMatrix = camera.getView();\n  const vp = mat4.multiply(tempMat, projectionMatrix, viewMatrix);\n  const invVp = mat4.invert(tempMat, vp);\n  const mouseX = 2.0 * clientX / width - 1.0;\n  const mouseY = -2.0 * clientY / height + 1.0; // get a single point on the camera ray.\n\n  const rayPoint = vec3.transformMat4([0, 0, 0], [mouseX, mouseY, 0.0], invVp); // get the position of the camera.\n\n  const rayOrigin = vec3.transformMat4([0, 0, 0], [0, 0, 0], mat4.invert(tempMat, viewMatrix));\n  const rayDir = vec3.normalize([0, 0, 0], vec3.subtract(tempVec, rayPoint, rayOrigin));\n  return new Ray(rayOrigin, rayDir, rayPoint);\n} //  Copyright (c) 2018-present, GM Cruise LLC\n// $FlowFixMe\n\n\nvar WorldviewReactContext = React__default.createContext(undefined);\nconst SUPPORTED_MOUSE_EVENTS = [\"onClick\", \"onMouseUp\", \"onMouseMove\", \"onMouseDown\", \"onDoubleClick\"]; // Component to dispatch children (for drawing) and hitmap props and a reglCommand to the render loop to render with regl.\n\nclass Command extends Component {\n  constructor(props) {\n    super(props); // In development put a check in to make sure the reglCommand prop is not mutated.\n    // Similar to how react checks for unsupported or deprecated calls in a development build.\n\n    _defineProperty(this, \"context\", void 0);\n\n    if (getNodeEnv() !== \"production\") {\n      // $FlowFixMe\n      this.shouldComponentUpdate = nextProps => {\n        if (nextProps.reglCommand !== this.props.reglCommand) {\n          console.error(\"Changing the regl command prop on a <Command /> is not supported.\");\n        }\n\n        return true;\n      };\n    }\n  }\n\n  componentDidMount() {\n    const context = this.context;\n\n    if (!context) {\n      return;\n    }\n\n    context.onMount(this, this.props.reglCommand);\n\n    this._updateContext();\n  }\n\n  componentDidUpdate() {\n    this._updateContext();\n  }\n\n  componentWillUnmount() {\n    const context = this.context;\n\n    if (!context) {\n      return;\n    }\n\n    context.onUnmount(this);\n  }\n\n  _updateContext() {\n    const context = this.context;\n\n    if (!context) {\n      return;\n    }\n\n    const {\n      reglCommand,\n      layerIndex,\n      getChildrenForHitmap\n    } = this.props;\n    const children = this.props.children || this.props.drawProps;\n\n    if (children == null) {\n      return;\n    }\n\n    context.registerDrawCall({\n      instance: this,\n      reglCommand,\n      children,\n      layerIndex,\n      getChildrenForHitmap\n    });\n  }\n\n  handleMouseEvent(objects, ray, e, mouseEventName) {\n    const mouseHandler = this.props[mouseEventName];\n\n    if (!mouseHandler || !objects.length) {\n      return;\n    }\n\n    mouseHandler(e, {\n      ray,\n      objects\n    });\n  }\n\n  render() {\n    return createElement(WorldviewReactContext.Consumer, null, ctx => {\n      if (ctx) {\n        this.context = ctx;\n      }\n\n      return null;\n    });\n  }\n\n}\n\n_defineProperty(Command, \"displayName\", \"Command\"); //  Copyright (c) 2018-present, GM Cruise LLC\n//\n//  This source code is licensed under the Apache License, Version 2.0,\n//  found in the LICENSE file in the root directory of this source tree.\n//  You may not use this file except in compliance with the License.\n// Takes an array of [value, key] and aggregates across the keys. Results in a Map of [key, values[]], in order of the\n// keys as seen in the array.\n\n\nfunction aggregate(array) {\n  const aggregationMap = new Map();\n  array.forEach(([item, key]) => {\n    const existingItems = aggregationMap.get(key) || [];\n    existingItems.push(item);\n\n    if (!aggregationMap.has(key)) {\n      aggregationMap.set(key, existingItems);\n    }\n  });\n  return aggregationMap;\n}\n\nfunction fillArray(start, length) {\n  return new Array(length).fill(0).map((_, index) => start + index);\n}\n/*\n * This object manages the mapping between objects that are rendered into the scene and their IDs.\n * It supplies an API for generating IDs for a rendered object and then accessing those objects based on their ID.\n */\n\n\nclass HitmapObjectIdManager {\n  constructor() {\n    _defineProperty(this, \"_objectsByObjectHitmapIdMap\", {});\n\n    _defineProperty(this, \"_commandsByObjectMap\", new Map());\n\n    _defineProperty(this, \"_nextObjectHitmapId\", 1);\n\n    _defineProperty(this, \"_instanceIndexByObjectHitmapIdMap\", {});\n\n    _defineProperty(this, \"assignNextColors\", (command, object, count) => {\n      if (count < 1) {\n        throw new Error(\"Must get at least 1 id\");\n      }\n\n      const ids = fillArray(this._nextObjectHitmapId, count);\n      this._nextObjectHitmapId = last(ids) + 1; // Instanced rendering - add to the instanced ID map.\n\n      if (count > 1) {\n        ids.forEach((id, index) => {\n          this._instanceIndexByObjectHitmapIdMap[id] = index;\n        });\n      } // Store the mapping of ID to original marker object\n\n\n      for (const id of ids) {\n        this._objectsByObjectHitmapIdMap[id] = object;\n      }\n\n      this._commandsByObjectMap.set(object, command); // Return colors from the IDs.\n\n\n      const colors = ids.map(id => intToRGB(id));\n      return colors;\n    });\n\n    _defineProperty(this, \"getObjectByObjectHitmapId\", objectHitmapId => {\n      return {\n        object: this._objectsByObjectHitmapIdMap[objectHitmapId],\n        instanceIndex: this._instanceIndexByObjectHitmapIdMap[objectHitmapId]\n      };\n    });\n\n    _defineProperty(this, \"getCommandForObject\", object => {\n      return this._commandsByObjectMap.get(object);\n    });\n  }\n\n} //\n//  Copyright (c) 2019-present, Cruise LLC\n//\n//  This source code is licensed under the Apache License, Version 2.0,\n//  found in the LICENSE file in the root directory of this source tree.\n//  You may not use this file except in compliance with the License.\n\n\nfunction signal() {\n  let resolve;\n  let reject;\n  const promise = new Promise((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n  promise.resolve = resolve;\n  promise.reject = reject;\n  return promise;\n} //\n// Wait for the previous promise to resolve before starting the next call to the function.\n\n\nfunction queuePromise(fn) {\n  // Whether we are currently waiting for a promise returned by `fn` to resolve.\n  let calling = false; // The list of calls made to the function was made while a call was in progress.\n\n  const nextCalls = [];\n\n  function queuedFn(...args) {\n    if (calling) {\n      const returnPromise = signal();\n      nextCalls.push({\n        args,\n        promise: returnPromise\n      });\n      return returnPromise;\n    }\n\n    return start(...args);\n  }\n\n  function start(...args) {\n    calling = true;\n    const promise = fn(...args).finally(() => {\n      calling = false;\n      queuedFn.currentPromise = undefined;\n\n      if (nextCalls.length) {\n        const {\n          promise: nextPromise,\n          args: nextArgs\n        } = nextCalls.shift();\n        start(...nextArgs).then(result => nextPromise.resolve(result)).catch(error => nextPromise.reject(error));\n      }\n    });\n    queuedFn.currentPromise = promise;\n    return promise;\n  }\n\n  return queuedFn;\n} // Compile instructions with an initialized regl context into a regl command.\n// If the instructions are a function, pass the context to the instructions and compile the result\n// of the function; otherwise, compile the instructions directly\n\n\nfunction compile(regl, cmd) {\n  const src = cmd(regl);\n  return typeof src === \"function\" ? src : regl(src);\n} // This is made available to every Command component as `this.context`.\n// It contains all the regl interaction code and is responsible for collecting and executing\n// draw calls, hitmap calls, and raycasting.\n\n\nclass WorldviewContext {\n  // store every compiled command object compiled for debugging purposes\n  // group all initialized data together so it can be checked for existence to verify initialization is complete\n  constructor({\n    dimension,\n    canvasBackgroundColor,\n    cameraState,\n    onCameraStateChange\n  }) {\n    _defineProperty(this, \"_commands\", new Set());\n\n    _defineProperty(this, \"_compiled\", new Map());\n\n    _defineProperty(this, \"_drawCalls\", new Map());\n\n    _defineProperty(this, \"_paintCalls\", new Map());\n\n    _defineProperty(this, \"_hitmapObjectIdManager\", new HitmapObjectIdManager());\n\n    _defineProperty(this, \"_cachedReadHitmapCall\", undefined);\n\n    _defineProperty(this, \"reglCommandObjects\", []);\n\n    _defineProperty(this, \"counters\", {});\n\n    _defineProperty(this, \"dimension\", void 0);\n\n    _defineProperty(this, \"onDirty\", void 0);\n\n    _defineProperty(this, \"cameraStore\", void 0);\n\n    _defineProperty(this, \"canvasBackgroundColor\", [0, 0, 0, 1]);\n\n    _defineProperty(this, \"initializedData\", void 0);\n\n    _defineProperty(this, \"raycast\", (canvasX, canvasY) => {\n      if (!this.initializedData) {\n        return undefined;\n      }\n\n      const {\n        width,\n        height\n      } = this.dimension;\n      return getRayFromClick(this.initializedData.camera, {\n        clientX: canvasX,\n        clientY: canvasY,\n        width,\n        height\n      });\n    });\n\n    _defineProperty(this, \"_debouncedPaint\", debounce(this.paint, 10));\n\n    _defineProperty(this, \"readHitmap\", queuePromise((canvasX, canvasY, enableStackedObjectEvents, maxStackedObjectCount) => {\n      if (!this.initializedData) {\n        return Promise.reject(new Error(\"regl data not initialized yet\"));\n      }\n\n      const args = [canvasX, canvasY, enableStackedObjectEvents, maxStackedObjectCount];\n      const cachedReadHitmapCall = this._cachedReadHitmapCall;\n\n      if (cachedReadHitmapCall) {\n        if (shallowequal(cachedReadHitmapCall.arguments, args)) {\n          // Make sure that we aren't returning the exact object identity of the mouseEventObject - we don't know what\n          // callers have done with it.\n          const result = cachedReadHitmapCall.result.map(([mouseEventObject, command]) => [_objectSpread({}, mouseEventObject), command]);\n          return Promise.resolve(result);\n        }\n\n        this._cachedReadHitmapCall = undefined;\n      }\n\n      const {\n        regl,\n        camera: camera$$1,\n        _fbo\n      } = this.initializedData;\n      const {\n        width,\n        height\n      } = this.dimension;\n      const x = canvasX; // 0,0 corresponds to the bottom left in the webgl context, but the top left in window coordinates\n\n      const y = height - canvasY; // regl will only resize the framebuffer if the size changed\n      // it uses floored whole pixel values\n\n      _fbo.resize(Math.floor(width), Math.floor(height));\n\n      return new Promise(resolve => {\n        // tell regl to use a framebuffer for this render\n        regl({\n          framebuffer: _fbo\n        })(() => {\n          // clear the framebuffer\n          regl.clear({\n            color: intToRGB(0),\n            depth: 1\n          });\n          let currentObjectId = 0;\n          const excludedObjects = [];\n          const mouseEventsWithCommands = [];\n          let counter = 0;\n          camera$$1.draw(this.cameraStore.state, () => {\n            // Every iteration in this loop clears the framebuffer, draws the hitmap objects that have NOT already been\n            // seen to the framebuffer, and then reads the pixel under the cursor to find the object on top.\n            // If `enableStackedObjectEvents` is false, we only do this iteration once - we only resolve with 0 or 1\n            // objects.\n            do {\n              if (counter >= maxStackedObjectCount) {\n                // Provide a max number of layers so this while loop doesn't crash the page.\n                console.error(`Hit ${maxStackedObjectCount} iterations. There is either a bug or that number of rendered hitmap layers under the mouse cursor.`);\n                break;\n              }\n\n              counter++;\n              regl.clear({\n                color: intToRGB(0),\n                depth: 1\n              });\n\n              this._drawInput(true, excludedObjects); // it's possible to get x/y values outside the framebuffer size\n              // if the mouse quickly leaves the draw area during a read operation\n              // reading outside the bounds of the framebuffer causes errors\n              // and puts regl into a bad internal state.\n              // https://github.com/regl-project/regl/blob/28fbf71c871498c608d9ec741d47e34d44af0eb5/lib/read.js#L57\n\n\n              if (x < Math.floor(width) && y < Math.floor(height) && x >= 0 && y >= 0) {\n                const pixel = new Uint8Array(4); // read pixel value from the frame buffer\n\n                regl.read({\n                  x,\n                  y,\n                  width: 1,\n                  height: 1,\n                  data: pixel\n                });\n                currentObjectId = getIdFromPixel(pixel);\n\n                const mouseEventObject = this._hitmapObjectIdManager.getObjectByObjectHitmapId(currentObjectId); // Check an error case: if we see an ID/color that we don't know about, it means that some command is\n                // drawing a color into the hitmap that it shouldn't be.\n\n\n                if (currentObjectId > 0 && !mouseEventObject) {\n                  console.error(`Clicked on an unknown object with id ${currentObjectId}. This likely means that a command is painting an incorrect color into the hitmap.`);\n                } // Check an error case: if we've already seen this object, then the getHitmapFromChildren function\n                // is not respecting the excludedObjects correctly and we should notify the user of a bug.\n\n\n                if (excludedObjects.some(({\n                  object,\n                  instanceIndex\n                }) => object === mouseEventObject.object && instanceIndex === mouseEventObject.instanceIndex)) {\n                  console.error(`Saw object twice when reading from hitmap. There is likely an error in getHitmapFromChildren`, mouseEventObject);\n                  break;\n                }\n\n                if (currentObjectId > 0 && mouseEventObject.object) {\n                  const command = this._hitmapObjectIdManager.getCommandForObject(mouseEventObject.object);\n\n                  excludedObjects.push(mouseEventObject);\n\n                  if (command) {\n                    mouseEventsWithCommands.push([mouseEventObject, command]);\n                  }\n                }\n              } // If we haven't enabled stacked object events, break out of the loop immediately.\n              // eslint-disable-next-line no-unmodified-loop-condition\n\n            } while (currentObjectId !== 0 && enableStackedObjectEvents);\n\n            this._cachedReadHitmapCall = {\n              arguments: args,\n              result: mouseEventsWithCommands\n            };\n            resolve(mouseEventsWithCommands);\n          });\n        });\n      });\n    }));\n\n    _defineProperty(this, \"_drawInput\", (isHitmap, excludedObjects) => {\n      if (isHitmap) {\n        this._hitmapObjectIdManager = new HitmapObjectIdManager();\n      }\n\n      const drawCalls = Array.from(this._drawCalls.values()).sort((a, b) => (a.layerIndex || 0) - (b.layerIndex || 0));\n      drawCalls.forEach(drawInput => {\n        const {\n          reglCommand,\n          children,\n          instance,\n          getChildrenForHitmap\n        } = drawInput;\n\n        if (!children) {\n          return console.debug(`${isHitmap ? \"hitmap\" : \"\"} draw skipped, props was falsy`, drawInput);\n        }\n\n        const cmd = this._compiled.get(reglCommand);\n\n        if (!cmd) {\n          return console.warn(\"could not find draw command for\", instance ? instance.constructor.displayName : \"Unknown\");\n        } // draw hitmap\n\n\n        if (isHitmap && getChildrenForHitmap) {\n          const assignNextColorsFn = (...rest) => {\n            return this._hitmapObjectIdManager.assignNextColors(instance, ...rest);\n          };\n\n          const hitmapProps = getChildrenForHitmap(children, assignNextColorsFn, excludedObjects || []);\n\n          if (hitmapProps) {\n            cmd(hitmapProps, true);\n          }\n        } else if (!isHitmap) {\n          cmd(children, false);\n        }\n      });\n    });\n\n    _defineProperty(this, \"_clearCanvas\", regl => {\n      // Since we aren't using regl.frame and only rendering when we need to,\n      // we need to tell regl to update its internal state.\n      regl.poll();\n      regl.clear({\n        color: this.canvasBackgroundColor,\n        depth: 1\n      });\n    }); // used for children to call paint() directly\n\n\n    this.onDirty = this._debouncedPaint;\n    this.dimension = dimension;\n    this.canvasBackgroundColor = canvasBackgroundColor;\n    this.cameraStore = new CameraStore(cameraState => {\n      if (onCameraStateChange) {\n        onCameraStateChange(cameraState);\n      } else {\n        // this must be called for Worldview with defaultCameraState prop\n        this.paint();\n      }\n    }, cameraState);\n  }\n\n  initialize(canvas) {\n    if (this.initializedData) {\n      throw new Error(\"can not initialize regl twice\");\n    }\n\n    const regl = this._instrumentCommands(createREGL({\n      canvas,\n      extensions: [\"angle_instanced_arrays\", \"oes_texture_float\", \"oes_element_index_uint\", \"oes_standard_derivatives\"],\n      profile: getNodeEnv() !== \"production\"\n    })); // compile any components which mounted before regl is initialized\n\n\n    this._commands.forEach(uncompiledCommand => {\n      const compiledCommand = compile(regl, uncompiledCommand);\n\n      this._compiled.set(uncompiledCommand, compiledCommand);\n    });\n\n    const Camera = compile(regl, camera);\n    const compiledCameraCommand = new Camera(); // framebuffer object from regl context\n\n    const fbo = regl.framebuffer({\n      width: Math.round(this.dimension.width),\n      height: Math.round(this.dimension.height)\n    });\n    this.initializedData = {\n      _fbo: fbo,\n      camera: compiledCameraCommand,\n      regl\n    };\n  }\n\n  destroy() {\n    if (this.initializedData) {\n      this.initializedData.regl.destroy();\n    }\n  } // compile a command when it is first mounted, and try to register in _commands and _compiled maps\n\n\n  onMount(instance, command) {\n    const {\n      initializedData\n    } = this; // do nothing if regl hasn't been initialized yet\n\n    if (!initializedData || this._commands.has(command)) {\n      return;\n    }\n\n    this._commands.add(command); // for components that mount after regl is initialized\n\n\n    this._compiled.set(command, compile(initializedData.regl, command));\n  } // unregister children hitmap and draw calls\n\n\n  onUnmount(instance) {\n    this._drawCalls.delete(instance);\n  }\n\n  unregisterPaintCallback(paintFn) {\n    this._paintCalls.delete(paintFn);\n  }\n\n  registerDrawCall(drawInput) {\n    this._drawCalls.set(drawInput.instance, drawInput);\n  }\n\n  registerPaintCallback(paintFn) {\n    this._paintCalls.set(paintFn, paintFn);\n  }\n\n  setDimension(dimension) {\n    this.dimension = dimension;\n  }\n\n  paint() {\n    const start = Date.now();\n    this.reglCommandObjects.forEach(cmd => cmd.stats.count = 0);\n\n    if (!this.initializedData) {\n      return;\n    }\n\n    this._cachedReadHitmapCall = null; // clear the cache every time we paint\n\n    const {\n      regl,\n      camera: camera$$1\n    } = this.initializedData;\n\n    this._clearCanvas(regl);\n\n    camera$$1.draw(this.cameraStore.state, () => {\n      const x = Date.now();\n\n      this._drawInput();\n\n      this.counters.paint = Date.now() - x;\n    });\n\n    this._paintCalls.forEach(paintCall => {\n      paintCall();\n    });\n\n    this.counters.render = Date.now() - start;\n  }\n\n  _instrumentCommands(regl) {\n    if (getNodeEnv() === \"production\") {\n      return regl;\n    }\n\n    return new Proxy(regl, {\n      apply: (target, thisArg, args) => {\n        const command = target(...args);\n\n        if (typeof command.stats === \"object\") {\n          this.reglCommandObjects.push(command);\n        }\n\n        return command;\n      }\n    });\n  }\n\n}\n\nconst DEFAULT_BACKGROUND_COLOR = [0, 0, 0, 1];\nconst DEFAULT_MOUSE_CLICK_RADIUS = 3;\nconst DEFAULT_MAX_NUMBER_OF_HITMAP_LAYERS = 100;\n\nfunction handleWorldviewMouseInteraction(objects, ray, e, handler) {\n  const args = {\n    ray,\n    objects\n  };\n\n  try {\n    handler(e, args);\n  } catch (err) {\n    console.error(\"Error during mouse handler\", err);\n  }\n} // responsible for camera and scene state management\n// takes in children that declaritively define what should be rendered\n\n\nclass WorldviewBase extends Component {\n  constructor(props) {\n    super(props);\n\n    _defineProperty(this, \"_canvas\", createRef());\n\n    _defineProperty(this, \"_tick\", void 0);\n\n    _defineProperty(this, \"_dragStartPos\", null);\n\n    _defineProperty(this, \"_onDoubleClick\", e => {\n      this._onMouseInteraction(e, \"onDoubleClick\");\n    });\n\n    _defineProperty(this, \"_onMouseDown\", e => {\n      this._dragStartPos = {\n        x: e.clientX,\n        y: e.clientY\n      };\n\n      this._onMouseInteraction(e, \"onMouseDown\");\n    });\n\n    _defineProperty(this, \"_onMouseMove\", e => {\n      this._onMouseInteraction(e, \"onMouseMove\");\n    });\n\n    _defineProperty(this, \"_onMouseUp\", e => {\n      this._onMouseInteraction(e, \"onMouseUp\");\n\n      const {\n        _dragStartPos\n      } = this;\n\n      if (_dragStartPos) {\n        const deltaX = e.clientX - _dragStartPos.x;\n        const deltaY = e.clientY - _dragStartPos.y;\n        const distance$$1 = Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n\n        if (distance$$1 < DEFAULT_MOUSE_CLICK_RADIUS) {\n          this._onMouseInteraction(e, \"onClick\");\n        }\n\n        this._dragStartPos = null;\n      }\n    });\n\n    _defineProperty(this, \"_onMouseInteraction\", (e, mouseEventName) => {\n      const {\n        worldviewContext\n      } = this.state;\n      const worldviewHandler = this.props[mouseEventName];\n\n      if (!(e.target instanceof window.HTMLElement) || e.button !== 0) {\n        return;\n      }\n\n      const {\n        top: clientTop,\n        left: clientLeft\n      } = e.target.getBoundingClientRect();\n      const {\n        clientX,\n        clientY\n      } = e;\n      const canvasX = clientX - clientLeft;\n      const canvasY = clientY - clientTop;\n      const ray = worldviewContext.raycast(canvasX, canvasY);\n\n      if (!ray) {\n        return;\n      } // rendering the hitmap on mouse move is expensive, so disable it by default\n\n\n      if (mouseEventName === \"onMouseMove\" && !this.props.hitmapOnMouseMove) {\n        if (worldviewHandler) {\n          return handleWorldviewMouseInteraction([], ray, e, worldviewHandler);\n        }\n\n        return;\n      } // reading hitmap is async so we need to persist the event to use later in the event handler\n\n\n      e.persist();\n      worldviewContext.readHitmap(canvasX, canvasY, !!this.props.enableStackedObjectEvents, this.props.maxStackedObjectCount).then(mouseEventsWithCommands => {\n        const mouseEventsByCommand = aggregate(mouseEventsWithCommands);\n\n        for (const [command, mouseEvents] of mouseEventsByCommand.entries()) {\n          command.handleMouseEvent(mouseEvents, ray, e, mouseEventName);\n\n          if (e.isPropagationStopped()) {\n            break;\n          }\n        }\n\n        if (worldviewHandler && !e.isPropagationStopped()) {\n          const mouseEvents = mouseEventsWithCommands.map(([mouseEventObject]) => mouseEventObject);\n          handleWorldviewMouseInteraction(mouseEvents, ray, e, worldviewHandler);\n        }\n      }).catch(e => {\n        console.error(e);\n      });\n    });\n\n    const {\n      width,\n      height,\n      top,\n      left,\n      backgroundColor,\n      onCameraStateChange,\n      cameraState,\n      defaultCameraState\n    } = props;\n\n    if (onCameraStateChange) {\n      if (!cameraState) {\n        console.warn(\"You provided `onCameraStateChange` without `cameraState`. Use Worldview as a controlled component with `cameraState` and `onCameraStateChange`, or uncontrolled with `defaultCameraState`.\");\n      }\n\n      if (cameraState && defaultCameraState) {\n        console.warn(\"You provided both `cameraState` and `defaultCameraState`. `defaultCameraState` will be ignored.\");\n      }\n    } else {\n      if (cameraState) {\n        console.warn(\"You provided `cameraState` without an `onCameraStateChange` handler. This will prevent moving the camera. If the camera should be movable, use `defaultCameraState`, otherwise set `onCameraStateChange`.\");\n      }\n    }\n\n    this.state = {\n      worldviewContext: new WorldviewContext({\n        dimension: {\n          width,\n          height,\n          top,\n          left\n        },\n        canvasBackgroundColor: backgroundColor || DEFAULT_BACKGROUND_COLOR,\n        // DEFAULT_CAMERA_STATE is applied if both `cameraState` and `defaultCameraState` are not present\n        cameraState: props.cameraState || props.defaultCameraState || DEFAULT_CAMERA_STATE,\n        onCameraStateChange: props.onCameraStateChange || undefined\n      })\n    };\n  }\n\n  static getDerivedStateFromProps({\n    width,\n    height,\n    top,\n    left\n  }, {\n    worldviewContext\n  }) {\n    worldviewContext.setDimension({\n      width,\n      height,\n      top,\n      left\n    });\n    return null;\n  }\n\n  componentDidMount() {\n    if (!this._canvas.current) {\n      return console.warn(\"missing canvas element\");\n    }\n\n    const {\n      worldviewContext\n    } = this.state;\n    worldviewContext.initialize(this._canvas.current); // trigger rendering in children that require camera to be present, e.g. Text component\n\n    this.setState({}); //eslint-disable-line\n    // call paint to set the correct viewportWidth and viewportHeight for camera so non-regl components\n    // such as Text can get the correct screen coordinates for the first render\n\n    worldviewContext.paint();\n  }\n\n  componentWillUnmount() {\n    if (this._tick) {\n      cancelAnimationFrame(this._tick);\n    }\n\n    this.state.worldviewContext.destroy();\n  }\n\n  componentDidUpdate() {\n    const {\n      worldviewContext\n    } = this.state; // update internal cameraState\n\n    if (this.props.cameraState) {\n      worldviewContext.cameraStore.setCameraState(this.props.cameraState);\n    } // queue up a paint operation on the next frame, if we haven't already\n\n\n    if (!this._tick) {\n      this._tick = requestAnimationFrame(() => {\n        this._tick = undefined;\n\n        try {\n          worldviewContext.paint();\n        } catch (error) {\n          // Regl automatically tries to reconnect when losing the canvas 3d context.\n          // We should log this error, but it's not important to throw it.\n          if (error.message === \"(regl) context lost\") {\n            console.warn(error);\n          } else {\n            throw error;\n          }\n        }\n      });\n    }\n  }\n\n  _renderDebug() {\n    const {\n      worldviewContext\n    } = this.state;\n    const initializedData = worldviewContext.initializedData;\n\n    if (getNodeEnv() === \"production\" || !initializedData) {\n      return null;\n    }\n\n    const {\n      regl\n    } = initializedData;\n    const mem = window.performance.memory;\n    const style = {\n      bottom: 5,\n      right: 10,\n      width: 200,\n      position: \"absolute\",\n      backgroundColor: \"rgba(0, 0, 0, 0.5)\",\n      color: \"white\",\n      fontFamily: \"monospace\",\n      fontSize: 10\n    };\n    const {\n      counters,\n      reglCommandObjects\n    } = worldviewContext;\n    const data = mapValues(counters, val => `${val} ms`);\n    data[\"draw calls\"] = reglCommandObjects.reduce((total, cmd) => total + cmd.stats.count, 0);\n\n    if (mem) {\n      data[\"heap used\"] = `${(mem.usedJSHeapSize / mem.jsHeapSizeLimit * 100).toFixed(3)}%`;\n    }\n\n    Object.assign(data, pickBy(regl.stats, val => typeof val === \"number\" && val !== 0));\n\n    if (regl.stats.bufferCount > 1000) {\n      throw new Error(\"Memory leak: Buffer count > 1000.\");\n    }\n\n    const rows = Object.keys(data).map(key => {\n      return createElement(\"tr\", {\n        key: key,\n        style: {\n          backgroundColor: \"transparent\",\n          border: \"none\"\n        }\n      }, createElement(\"td\", {\n        style: {\n          paddingRight: 10,\n          border: \"none\"\n        }\n      }, key), createElement(\"td\", {\n        style: {\n          width: \"100%\",\n          border: \"none\"\n        }\n      }, data[key]));\n    });\n    return createElement(\"table\", {\n      style: style\n    }, createElement(\"tbody\", null, rows));\n  }\n\n  render() {\n    const {\n      width,\n      height,\n      showDebug,\n      keyMap,\n      shiftKeys,\n      style,\n      cameraState,\n      onCameraStateChange\n    } = this.props;\n    const {\n      worldviewContext\n    } = this.state; // If we are supplied controlled camera state and no onCameraStateChange callback\n    // then there is a 'fixed' camera from outside of worldview itself.\n\n    const isFixedCamera = cameraState && !onCameraStateChange;\n    const canvasHtml = createElement(Fragment, null, createElement(\"canvas\", {\n      style: {\n        width,\n        height,\n        maxWidth: \"100%\",\n        maxHeight: \"100%\"\n      },\n      width: width,\n      height: height,\n      ref: this._canvas,\n      onMouseUp: this._onMouseUp,\n      onMouseDown: this._onMouseDown,\n      onDoubleClick: this._onDoubleClick,\n      onMouseMove: this._onMouseMove\n    }), showDebug && this._renderDebug());\n    return createElement(\"div\", {\n      style: _objectSpread({\n        position: \"relative\",\n        overflow: \"hidden\"\n      }, style)\n    }, isFixedCamera ? canvasHtml : createElement(CameraListener, {\n      cameraStore: worldviewContext.cameraStore,\n      keyMap: keyMap,\n      shiftKeys: shiftKeys\n    }, canvasHtml), worldviewContext.initializedData && createElement(WorldviewReactContext.Provider, {\n      value: worldviewContext\n    }, this.props.children));\n  }\n\n}\n\n_defineProperty(WorldviewBase, \"defaultProps\", {\n  maxStackedObjectCount: DEFAULT_MAX_NUMBER_OF_HITMAP_LAYERS,\n  backgroundColor: DEFAULT_BACKGROUND_COLOR,\n  shiftKeys: true,\n  style: {}\n});\n\nconst Worldview = props => createElement(ContainerDimensions, null, ({\n  width,\n  height,\n  left,\n  top\n}) => createElement(WorldviewBase, _extends({\n  width: width,\n  height: height,\n  left: left,\n  top: top\n}, props)));\n\nWorldview.displayName = \"Worldview\"; //  Copyright (c) 2018-present, GM Cruise LLC\n//\n//  This source code is licensed under the Apache License, Version 2.0,\n//  found in the LICENSE file in the root directory of this source tree.\n//  You may not use this file except in compliance with the License.\n// a single min/max value\n\nclass Bound {\n  constructor() {\n    _defineProperty(this, \"min\", void 0);\n\n    _defineProperty(this, \"max\", void 0);\n\n    this.min = Number.MAX_SAFE_INTEGER;\n    this.max = Number.MIN_SAFE_INTEGER;\n  } // update the bound based on a value\n\n\n  update(value) {\n    this.min = Math.min(this.min, value);\n    this.max = Math.max(this.max, value);\n  }\n\n} // represents x, y, and z min & max bounds for a 3d scene\n\n\nclass Bounds {\n  constructor() {\n    _defineProperty(this, \"x\", void 0);\n\n    _defineProperty(this, \"y\", void 0);\n\n    _defineProperty(this, \"z\", void 0);\n\n    this.x = new Bound();\n    this.y = new Bound();\n    this.z = new Bound();\n  } // update the bounds based on a point\n\n\n  update(point) {\n    this.x.update(point.x);\n    this.y.update(point.y);\n    this.z.update(point.z);\n  }\n\n} //  Copyright (c) 2018-present, GM Cruise LLC\n\n\nconst scratch = [0, 0, 0, 0, 0, 0, 0, 0, 0]; // gl-matrix clone of three.js Euler.setFromQuaternion\n// assumes default XYZ order\n\nfunction eulerFromQuaternion(out, q) {\n  const m = mat3.fromQuat(scratch, q);\n  const m11 = m[0],\n        m12 = m[3],\n        m13 = m[6]; // prettier-ignore\n\n  const m22 = m[4],\n        m23 = m[7]; // prettier-ignore\n\n  const m32 = m[5],\n        m33 = m[8]; // prettier-ignore\n\n  out[1] = Math.asin(m13 < -1 ? -1 : m13 > 1 ? 1 : m13);\n\n  if (Math.abs(m13) < 0.99999) {\n    out[0] = Math.atan2(-m23, m33);\n    out[2] = Math.atan2(-m12, m11);\n  } else {\n    out[0] = Math.atan2(m32, m22);\n    out[2] = 0;\n  }\n\n  return out;\n} //  Copyright (c) 2018-present, GM Cruise LLC\n// and elements (indexes into the array of positions), and apply the object's pose, scale, and color to it.\n\n\nvar fromGeometry = (positions, elements) => regl => {\n  const vertexArray = Float32Array.from([].concat(...positions));\n\n  if (elements.some(face => face.some(i => i < 0 || i >= 1 << 16))) {\n    throw new Error(\"Element index out of bounds for Uint16\");\n  }\n\n  const elementsArray = Uint16Array.from([].concat(...elements));\n  const buff = regl.buffer({\n    // tell the gpu this buffer's contents will change frequently\n    usage: \"dynamic\",\n    data: []\n  });\n  const colorBuff = colorBuffer(regl);\n  return withPose({\n    vert: `\n    precision mediump float;\n    attribute vec3 point;\n    attribute vec3 offset;\n    attribute vec4 color;\n    uniform mat4 projection, view;\n    uniform vec3 scale;\n    varying vec4 vColor;\n\n    #WITH_POSE\n\n    void main () {\n      vec3 p = applyPose(scale * point) + offset;\n      vColor = color;\n      gl_Position = projection * view * vec4(p, 1);\n    }\n    `,\n    frag: `\n    precision mediump float;\n    varying vec4 vColor;\n    void main () {\n      gl_FragColor = vColor;\n    }`,\n    attributes: {\n      point: vertexArray,\n      color: (context, props) => {\n        return colorBuff(props.color, props.colors, props.points ? props.points.length : 1);\n      },\n      offset: (context, props) => {\n        const points = shouldConvert(props.points) ? props.points.map(pointToVec3) : props.points || [0, 0, 0];\n        return {\n          buffer: buff({\n            usage: \"dynamic\",\n            data: points\n          }),\n          divisor: 1\n        };\n      }\n    },\n    elements: elementsArray,\n    depth: defaultDepth,\n    blend: defaultBlend,\n    uniforms: {\n      scale: (context, props) => shouldConvert(props.scale) ? pointToVec3(props.scale) : props.scale\n    },\n    count: elementsArray.length,\n    instances: (context, props) => props.points ? props.points.length : 1\n  });\n}; //  Copyright (c) 2019-present, GM Cruise LLC\n//\n//  This source code is licensed under the Apache License, Version 2.0,\n//  found in the LICENSE file in the root directory of this source tree.\n//  You may not use this file except in compliance with the License.\n// Parse a GLB file: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0\n//\n// Returns an object containing the raw json data as well as parsed images (Image) and\n// accessors (TypedArray).\n\n\nasync function parseGLB(arrayBuffer) {\n  const data = new DataView(arrayBuffer);\n  let offset = 0;\n\n  function readUint32() {\n    const value = data.getUint32(offset, true);\n    offset += 4;\n    return value;\n  } // magic header\n\n\n  const magic = readUint32();\n\n  if (magic !== 0x46546c67) {\n    throw new Error(`incorrect magic value 0x${magic.toString(16)}`);\n  } // Binary glTF version\n\n\n  const version = readUint32();\n\n  if (version !== 2) {\n    throw new Error(`incorrect version ${version}`);\n  } // total file length\n\n\n  const totalLength = readUint32();\n\n  if (totalLength !== data.byteLength) {\n    throw new Error(`length ${totalLength} doesn't match response length ${data.byteLength}`);\n  }\n\n  function findNextChunkOfType(type) {\n    do {\n      const chunkLength = readUint32();\n      const chunkType = readUint32();\n\n      if (chunkType === type) {\n        const chunkData = new DataView(data.buffer, offset, chunkLength);\n        offset += chunkLength;\n        return chunkData;\n      }\n\n      offset += chunkLength;\n    } while (offset < totalLength);\n  }\n\n  const jsonData = findNextChunkOfType(\n  /* JSON */\n  0x4e4f534a);\n\n  if (!jsonData) {\n    throw new Error(\"no JSON chunk found\");\n  }\n\n  const json = JSON.parse(new TextDecoder().decode(jsonData));\n  const binary = findNextChunkOfType(\n  /* BIN */\n  0x004e4942);\n\n  if (!binary) {\n    return {\n      json\n    };\n  }\n\n  if (json.buffers[0].uri !== undefined) {\n    throw new Error(\"expected GLB-stored buffer\");\n  } // create a TypedArray for each accessor\n\n\n  const accessors = json.accessors.map(accessorInfo => {\n    let arrayType; // prettier-ignore\n\n    switch (accessorInfo.componentType) {\n      case WebGLRenderingContext.BYTE:\n        arrayType = Int8Array;\n        break;\n\n      case WebGLRenderingContext.UNSIGNED_BYTE:\n        arrayType = Uint8Array;\n        break;\n\n      case WebGLRenderingContext.SHORT:\n        arrayType = Int16Array;\n        break;\n\n      case WebGLRenderingContext.UNSIGNED_SHORT:\n        arrayType = Uint16Array;\n        break;\n\n      case WebGLRenderingContext.UNSIGNED_INT:\n        arrayType = Uint32Array;\n        break;\n\n      case WebGLRenderingContext.FLOAT:\n        arrayType = Float32Array;\n        break;\n\n      default:\n        throw new Error(`unrecognized componentType ${accessorInfo.componentType}`);\n    }\n\n    let numComponents; // prettier-ignore\n\n    switch (accessorInfo.type) {\n      case \"SCALAR\":\n        numComponents = 1;\n        break;\n\n      case \"VEC2\":\n        numComponents = 2;\n        break;\n\n      case \"VEC3\":\n        numComponents = 3;\n        break;\n\n      case \"VEC4\":\n        numComponents = 4;\n        break;\n\n      case \"MAT2\":\n        numComponents = 4;\n        break;\n\n      case \"MAT3\":\n        numComponents = 9;\n        break;\n\n      case \"MAT4\":\n        numComponents = 16;\n        break;\n\n      default:\n        throw new Error(`unrecognized type ${accessorInfo.type}`);\n    }\n\n    const bufferView = json.bufferViews[accessorInfo.bufferView];\n\n    if (bufferView.buffer !== 0) {\n      throw new Error(\"only GLB-stored buffers are supported\");\n    }\n\n    if (bufferView.byteLength % arrayType.BYTES_PER_ELEMENT !== 0) {\n      throw new Error(\"bufferView.byteLength mismatch\");\n    }\n\n    return new arrayType(binary.buffer, binary.byteOffset + (bufferView.byteOffset || 0) + (accessorInfo.byteOffset || 0), accessorInfo.count * numComponents);\n  }); // load embedded images\n\n  const images = json.images && (await Promise.all(json.images.map(imgInfo => {\n    const bufferView = json.bufferViews[imgInfo.bufferView];\n    const data = new DataView(binary.buffer, binary.byteOffset + bufferView.byteOffset, bufferView.byteLength);\n    return self.createImageBitmap(new Blob([data], {\n      type: imgInfo.mimeType\n    }));\n  })));\n  return {\n    json,\n    accessors,\n    images\n  };\n} //  Copyright (c) 2018-present, GM Cruise LLC\n//\n//  This source code is licensed under the Apache License, Version 2.0,\n//  found in the LICENSE file in the root directory of this source tree.\n//  You may not use this file except in compliance with the License.\n\n\nfunction nonInstancedGetChildrenForHitmapFromSingleProp(prop, assignNextColors, excludedObjects, useOriginalMarkerProp = false) {\n  // The marker that we send to event callbacks.\n  const eventCallbackMarker = useOriginalMarkerProp ? prop.originalMarker : prop;\n\n  if (excludedObjects.some(({\n    object\n  }) => object === eventCallbackMarker)) {\n    return null;\n  }\n\n  const hitmapProp = _objectSpread({}, prop);\n\n  const [hitmapColor] = assignNextColors(eventCallbackMarker, 1);\n  hitmapProp.color = hitmapColor;\n\n  if (hitmapProp.colors && hitmapProp.points && hitmapProp.points.length) {\n    hitmapProp.colors = new Array(hitmapProp.points.length).fill(hitmapColor);\n  }\n\n  return hitmapProp;\n}\n\nconst nonInstancedGetChildrenForHitmap = (props, assignNextColors, excludedObjects) => {\n  if (Array.isArray(props)) {\n    return props.map(prop => nonInstancedGetChildrenForHitmapFromSingleProp(prop, assignNextColors, excludedObjects)).filter(Boolean);\n  }\n\n  return nonInstancedGetChildrenForHitmapFromSingleProp(props, assignNextColors, excludedObjects);\n}; // Almost identical to nonInstancedGetChildrenForHitmap, but instead the object passed to event callbacks is the object\n// at `prop.originalMarker`, not just `prop`.\n\n\nconst getChildrenForHitmapWithOriginalMarker = (props, assignNextColors, excludedObjects) => {\n  if (Array.isArray(props)) {\n    return props.map(prop => nonInstancedGetChildrenForHitmapFromSingleProp(prop, assignNextColors, excludedObjects, true)).filter(Boolean);\n  }\n\n  return nonInstancedGetChildrenForHitmapFromSingleProp(props, assignNextColors, excludedObjects, true);\n};\n\nfunction instancedGetChildrenForHitmapFromSingleProp(prop, assignNextColors, excludedObjects, pointCountPerInstance) {\n  const matchedExcludedObjects = excludedObjects.filter(({\n    object,\n    instanceIndex\n  }) => object === prop);\n  const filteredIndices = matchedExcludedObjects.map(({\n    object,\n    instanceIndex\n  }) => instanceIndex).filter(instanceIndex => typeof instanceIndex === \"number\");\n\n  const hitmapProp = _objectSpread({}, prop);\n\n  const instanceCount = hitmapProp.points && Math.ceil(hitmapProp.points.length / pointCountPerInstance) || 1; // This returns 1 color per instance.\n\n  const idColors = assignNextColors(prop, instanceCount);\n  const startColor = idColors[0]; // We have to map these instance colors to `pointCountPerInstance` number of points\n\n  if (hitmapProp.points && hitmapProp.points.length) {\n    const allColors = new Array(hitmapProp.points.length).fill().map(() => startColor);\n\n    for (let i = 0; i < instanceCount; i++) {\n      for (let j = 0; j < pointCountPerInstance; j++) {\n        const idx = i * pointCountPerInstance + j;\n\n        if (idx < allColors.length) {\n          allColors[idx] = idColors[i];\n        }\n      }\n    }\n\n    hitmapProp.colors = allColors;\n\n    if (filteredIndices.length) {\n      hitmapProp.points = hitmapProp.points.filter((_, index) => !filteredIndices.includes(Math.floor(index / pointCountPerInstance)));\n      hitmapProp.colors = hitmapProp.colors.filter((_, index) => !filteredIndices.includes(Math.floor(index / pointCountPerInstance)));\n    } else if (matchedExcludedObjects.length) {\n      // if we don't have instance indices, just filter out the whole object.\n      return null;\n    }\n  } else {\n    hitmapProp.color = startColor;\n\n    if (matchedExcludedObjects.length) {\n      return null;\n    }\n  }\n\n  return hitmapProp;\n}\n\nconst createInstancedGetChildrenForHitmap = pointCountPerInstance => (props, assignNextColors, excludedObjects) => {\n  if (Array.isArray(props)) {\n    return props.map(prop => instancedGetChildrenForHitmapFromSingleProp(prop, assignNextColors, excludedObjects, pointCountPerInstance)).filter(Boolean);\n  }\n\n  return instancedGetChildrenForHitmapFromSingleProp(props, assignNextColors, excludedObjects, pointCountPerInstance);\n};\n\nfunction createCylinderGeometry(numSegments, cone) {\n  // \"poles\" are the centers of top/bottom faces\n  const northPole = [0, 0, 0.5];\n  const southPole = [0, 0, -0.5];\n  const points = [northPole, southPole]; // Keep side faces separate from top/bottom to improve appearance for semi-transparent colors.\n  // We don't have a good approach to transparency right now but this is a small improvement over mixing the faces.\n\n  const sideFaces = [];\n  const endCapFaces = [];\n\n  for (let i = 0; i < numSegments; i++) {\n    const theta = 2 * Math.PI * i / numSegments;\n    const x = 0.5 * Math.cos(theta);\n    const y = 0.5 * Math.sin(theta);\n    points.push([x, y, 0.5], [x, y, -0.5]);\n    const bottomLeftPt = points.length - 1;\n    const topRightPt = cone ? 0 : i + 1 === numSegments ? 2 : points.length;\n    const bottomRightPt = i + 1 === numSegments ? 3 : points.length + 1;\n    sideFaces.push([bottomLeftPt, topRightPt, bottomRightPt]);\n    endCapFaces.push([bottomLeftPt, bottomRightPt, 1]);\n\n    if (!cone) {\n      const topLeftPt = points.length - 2;\n      sideFaces.push([topLeftPt, bottomLeftPt, topRightPt]);\n      endCapFaces.push([topLeftPt, topRightPt, 0]);\n    }\n  }\n\n  return {\n    points,\n    sideFaces,\n    endCapFaces\n  };\n}\n\nconst {\n  points,\n  sideFaces,\n  endCapFaces\n} = createCylinderGeometry(30, false);\nconst cylinders = fromGeometry(points, sideFaces.concat(endCapFaces));\nconst getChildrenForHitmap = createInstancedGetChildrenForHitmap(1);\n\nfunction Cylinders(props) {\n  return createElement(Command, _extends({\n    getChildrenForHitmap: getChildrenForHitmap\n  }, props, {\n    reglCommand: cylinders\n  }));\n}\n\nconst {\n  points: points$1,\n  sideFaces: sideFaces$1,\n  endCapFaces: endCapFaces$1\n} = createCylinderGeometry(30, true);\nconst cones = fromGeometry(points$1, sideFaces$1.concat(endCapFaces$1));\nconst getChildrenForHitmap$1 = createInstancedGetChildrenForHitmap(1);\n\nfunction Cones(props) {\n  return createElement(Command, _extends({\n    getChildrenForHitmap: getChildrenForHitmap$1\n  }, props, {\n    reglCommand: cones\n  }));\n}\n\nconst UNIT_X_VECTOR$1 = Object.freeze([0, 0, 1]);\n\nfunction Arrows(props) {\n  const passedProps = omit(props, \"children\");\n  const cylinders = [];\n  const cones = [];\n\n  for (const marker of props.children) {\n    let shaftWidthX;\n    let shaftWidthY;\n    let shaftLength;\n    let headWidthX;\n    let headWidthY;\n    let headLength;\n    let basePosition;\n    let orientation;\n    let dir;\n\n    if (marker.points && marker.points.length === 2) {\n      const [start, end] = marker.points;\n      basePosition = [start.x, start.y, start.z];\n      const tipPosition = [end.x, end.y, end.z];\n      const length = vec3.distance(basePosition, tipPosition);\n      dir = vec3.subtract([0, 0, 0], tipPosition, basePosition);\n      vec3.normalize(dir, dir);\n      orientation = quat.rotationTo([0, 0, 0, 0], UNIT_X_VECTOR$1, dir);\n      headWidthX = headWidthY = marker.scale.y;\n      headLength = marker.scale.z || length * 0.3;\n      shaftWidthX = shaftWidthY = marker.scale.x;\n      shaftLength = length - headLength;\n    } else {\n      basePosition = pointToVec3(marker.pose.position);\n      orientation = orientationToVec4(marker.pose.orientation);\n      quat.rotateY(orientation, orientation, Math.PI / 2);\n      dir = vec3.transformQuat([0, 0, 0], UNIT_X_VECTOR$1, orientation);\n      shaftWidthX = marker.scale.y || 1;\n      shaftWidthY = marker.scale.z || 1;\n      headWidthX = 2 * shaftWidthX;\n      headWidthY = 2 * shaftWidthY; // these magic numbers taken from\n      // https://github.com/ros-visualization/rviz/blob/57325fa075893de70f234f4676cdd08b411858ff/src/rviz/default_plugin/markers/arrow_marker.cpp#L113\n\n      headLength = 0.23 * (marker.scale.x || 1);\n      shaftLength = 0.77 * (marker.scale.x || 1);\n    }\n\n    const shaftPosition = vec3.scaleAndAdd([0, 0, 0], basePosition, dir, shaftLength / 2);\n    const headPosition = vec3.scaleAndAdd([0, 0, 0], basePosition, dir, shaftLength + headLength / 2);\n    cylinders.push({\n      // Set the original marker so we can use it in mouse events\n      originalMarker: marker,\n      scale: {\n        x: shaftWidthX,\n        y: shaftWidthY,\n        z: shaftLength\n      },\n      color: marker.color,\n      pose: {\n        position: vec3ToPoint(shaftPosition),\n        orientation: vec4ToOrientation(orientation)\n      }\n    });\n    cones.push({\n      // Set the original marker so we can use it in mouse events\n      originalMarker: marker,\n      scale: {\n        x: headWidthX,\n        y: headWidthY,\n        z: headLength\n      },\n      color: marker.color,\n      pose: {\n        position: vec3ToPoint(headPosition),\n        orientation: vec4ToOrientation(orientation)\n      }\n    });\n  }\n\n  return React__default.createElement(Fragment, null, React__default.createElement(Cylinders, _extends({\n    getChildrenForHitmap: getChildrenForHitmapWithOriginalMarker\n  }, passedProps), cylinders), React__default.createElement(Cones, _extends({\n    getChildrenForHitmap: getChildrenForHitmapWithOriginalMarker\n  }, passedProps), cones));\n}\n\nvar Arrows$1 = memo(Arrows);\n/*\nTriangle-based line drawing.\n\n4 points (a strip of 2 triangles) are drawn for each segment of the line using instanced arrays.\nEach of the 4 points has a distinct \"point type\" which informs how the input point is offset to\nyield the vertices of the triangle.\n\nPassing the input point as an attribute with {divisor: 1} tells GL to use each point for 1 instance,\nthen move on to the next point -- something like `points.map((p) => draw2Triangles(p))`.\n\n4 attributes are used so the vertex shader can see 4 input points at once (reading from the same\nbuffer with different offsets). This is because the positions of the TL/BL endpoints depend on the\nangle ABC, and the positions of TR/BR depend on the angle BCD.\n\nRoughly the segment looks like:\n\n     TL   -   -   -  .TR\n      |          ,.-' |\nA - - B - - -,.-' - - C - - D\n      |  ,.-'         |\n     BL-' -   -   -   BR\n\nWhen two adjacent segments form an obtuse angle, we draw a miter join:\n\n                      TR/TL.\n                 , '   _/|   ' .\n             , '     _/  |       ' .\n         , '       _/    C           ' .\n     , '         _/      |               ' .\n   TL          _/        |        ______,----'TR\n    \\        _/       ,BR/BL.----'            /\n     B     _/    , '          ' .            D\n      \\  _/ , '                   ' .       /\n       BL'                            ' . BR\n\nBut when the angle gets too sharp, we switch to a \"fold\" join, where the two segments overlap at\nthe corner:\n\n        ,TR/BL---C--BR/TL\n       ,    |.\\__  ,     .\n      ,     | .  \\,_      .\n     ,      |  . ,  \\_     .\n    ,       |   ,     \\__   .\n   ,        |  , .       \\__ .\n  TL._      | ,   .        _.TR\n      'B._  |,     .   _.C'\n          'BL       BR'\n\n(A regular bevel join without any overlaps is harder to achieve without artifacts in the sharp-angle\nedge cases.)\n\n*/\n\nconst FLOAT_BYTES = Float32Array.BYTES_PER_ELEMENT;\nconst POINT_BYTES = 3 * FLOAT_BYTES;\nconst DEFAULT_MONOCHROME_COLOR = [1, 1, 1, 0.2]; // The four points forming the triangles' vertices.\n// Values do not matter, they just need to be distinct.\n\nconst POINT_TYPES = {\n  BL: 0,\n  TR: 1,\n  BR: 2,\n  TL: 3\n};\nconst VERTICES_PER_INSTANCE = Object.keys(POINT_TYPES).length;\nconst vert = `\nprecision mediump float;\n\nattribute float pointType;\n\n// per-instance attributes\nattribute vec4 colorB;\nattribute vec4 colorC;\nattribute vec3 positionA;\nattribute vec3 positionB;\nattribute vec3 positionC;\nattribute vec3 positionD;\n// per-instance pose attributes\nattribute vec3 posePosition;\nattribute vec4 poseRotation;\n\nuniform mat4 projection, view;\nuniform float viewportWidth;\nuniform float viewportHeight;\nuniform float alpha;\nuniform float thickness;\nuniform bool joined;\nuniform bool scaleInvariant;\n\nvarying vec4 vColor;\n\n${Object.keys(POINT_TYPES).map(k => `const float POINT_${k} = ${POINT_TYPES[k]}.0;`).join(\"\\n\")}\n\n#WITH_POSE\n\nvec3 applyPoseInstance(vec3 point, vec4 rotation, vec3 position) {\n  // rotate the point and then add the position of the pose\n  // this function is defined in WITH_POSE\n  return rotate(point, rotation) + position;\n}\n\nvec2 rotateCCW(vec2 v) {\n  return vec2(-v.y, v.x);\n}\n\nvec2 normalizeOrZero(vec2 v) {\n  return length(v) < 0.00001 ? vec2(0, 0) : normalize(v);\n}\n\nvoid setPosition(vec4 proj, vec2 offset) {\n  gl_Position = proj;\n\n  offset *= thickness / 2.;\n\n  if (scaleInvariant) {\n    // The given thickness is a number of pixels on screen. Divide x by width/2 and\n    // y by height/2 so that they correspond to pixel distances when scaled from clip space to NDC.\n    offset.x /= viewportWidth / 2.0;\n    offset.y /= viewportHeight / 2.0;\n    // Compensate for automatic division by w\n    offset *= proj.w;\n  } else {\n    // The line thickness should be scaled the same way the camera scales other distances.\n    // projection[0].xyz is the result of projecting a unit x-vector, so its length represents\n    // how much distances are scaled by the camera projection.\n    offset *= length(projection[0].xyz);\n    offset.y *= viewportWidth / viewportHeight;\n  }\n\n  gl_Position.xy += offset;\n}\n\nvoid main () {\n  bool isStart = positionA == positionB;\n  bool isEnd = positionC == positionD;\n  bool isLeft = (pointType == POINT_TL || pointType == POINT_BL);\n  bool isTop = (pointType == POINT_TL || pointType == POINT_TR);\n  bool isEndpoint = isLeft ? isStart : isEnd;\n\n  float scale = isTop ? 1. : -1.;\n\n  mat4 projView = projection * view;\n  vec4 projA = projView * vec4(applyPose(applyPoseInstance(positionA, poseRotation, posePosition)), 1);\n  vec4 projB = projView * vec4(applyPose(applyPoseInstance(positionB, poseRotation, posePosition)), 1);\n  vec4 projC = projView * vec4(applyPose(applyPoseInstance(positionC, poseRotation, posePosition)), 1);\n  vec4 projD = projView * vec4(applyPose(applyPoseInstance(positionD, poseRotation, posePosition)), 1);\n\n  vec2 aspectVec = vec2(viewportWidth / viewportHeight, 1.0);\n  vec2 screenA = projA.xy / projA.w * aspectVec;\n  vec2 screenB = projB.xy / projB.w * aspectVec;\n  vec2 screenC = projC.xy / projC.w * aspectVec;\n  vec2 screenD = projD.xy / projD.w * aspectVec;\n\n  vec2 dirAB = normalizeOrZero(screenB - screenA);\n  vec2 dirBC = normalizeOrZero(screenC - screenB);\n  vec2 dirCD = normalizeOrZero(screenD - screenC);\n\n  vec2 perpAB = rotateCCW(dirAB); // vector perpendicular to AB\n  vec2 perpBC = rotateCCW(dirBC); // vector perpendicular to BC\n\n  vColor = isLeft ? colorB : colorC;\n  vColor.a *= alpha;\n\n  vec4 proj = isLeft ? projB : projC;\n\n  // simple case: non-joined line list\n  if (!joined || isEndpoint) {\n    setPosition(proj, scale * perpBC);\n    return;\n  }\n\n  // clamp to prevent rounding errors from breaking the sqrt()s below\n  float cosB = clamp(-dot(dirAB, dirBC), -1., 1.);\n  float cosC = clamp(-dot(dirBC, dirCD), -1., 1.);\n\n  bool tooSharpB = cosB > 0.01;\n  bool tooSharpC = cosC > 0.01;\n  bool tooSharp = isLeft ? tooSharpB : tooSharpC;\n\n  bool turningRightB = dot(dirAB, rotateCCW(dirBC)) > 0.;\n  bool turningRightC = dot(dirBC, rotateCCW(dirCD)) > 0.;\n  bool turningRight = isLeft ? turningRightB : turningRightC;\n\n  if (tooSharp) {\n    // \"fold join\"\n    vec2 perp = isLeft ? perpAB : perpBC;\n    vec2 dir = isLeft ? dirAB : dirBC;\n    float scalePerp = isLeft ? -1. : 1.;\n    float scaleDir = (turningRight == isLeft) ? 1. : -1.;\n    float tanHalfB = sqrt((1. - cosB) / (1. + cosB));\n    float tanHalfC = sqrt((1. - cosC) / (1. + cosC));\n    float tanHalf = isLeft ? tanHalfB : tanHalfC;\n    setPosition(proj, scale * (scalePerp * perp + scaleDir * dir * tanHalf));\n  } else {\n    // miter join\n    vec2 bisectorB = rotateCCW(normalize(dirAB + dirBC)); // angle bisector of ABC\n    vec2 bisectorC = rotateCCW(normalize(dirBC + dirCD)); // angle bisector of BCD\n    vec2 bisector = isLeft ? bisectorB : bisectorC;\n    float sinHalfB = sqrt((1. - cosB) / 2.);\n    float sinHalfC = sqrt((1. - cosC) / 2.);\n    float sinHalf = isLeft ? sinHalfB : sinHalfC;\n    setPosition(proj, scale * bisector / sinHalf);\n  }\n}\n`;\nconst frag = `\nprecision mediump float;\nvarying vec4 vColor;\nvoid main () {\n  gl_FragColor = vColor;\n}\n`;\n\nfunction pointsEqual(a, b) {\n  const [ax, ay, az] = shouldConvert(a) ? pointToVec3(a) : a;\n  const [bx, by, bz] = shouldConvert(b) ? pointToVec3(b) : b;\n  return ax === bx && ay === by && az === bz;\n}\n\nconst lines = regl => {\n  // The point type attribute, reused for each instance\n  const pointTypeBuffer = regl.buffer({\n    type: \"uint16\",\n    usage: \"static\",\n    data: [POINT_TYPES.TL, POINT_TYPES.BL, POINT_TYPES.TR, POINT_TYPES.BR]\n  });\n  const debugColorBuffer = regl.buffer({\n    type: \"float\",\n    usage: \"static\",\n    data: [[0, 1, 1, 1], // cyan\n    [1, 0, 0, 1], // red\n    [0, 1, 0, 1], // green\n    [1, 0, 1, 1]]\n  }); // The pose position and rotation buffers contain the identity position/rotation, for use when we don't have instanced\n  // poses.\n\n  const defaultPosePositionBuffer = regl.buffer({\n    type: \"float\",\n    usage: \"static\",\n    data: flatten(new Array(VERTICES_PER_INSTANCE).fill([0, 0, 0]))\n  });\n  const defaultPoseRotationBuffer = regl.buffer({\n    type: \"float\",\n    usage: \"static\",\n    // Rotation array identity is [x: 0, y: 0, z: 0, w: 1]\n    data: flatten(new Array(VERTICES_PER_INSTANCE).fill([0, 0, 0, 1]))\n  }); // The buffers used for input position & color data\n\n  const colorBuffer$$1 = regl.buffer({\n    type: \"float\"\n  }); // All invocations of the vertex shader share data from the positions buffer, but with different\n  // offsets. However, when offset and stride are combined, 3 or 4 attributes reading from the same\n  // buffer produces incorrect results on certain Lenovo hardware running Ubuntu. As a workaround,\n  // we upload the same data into two buffers and have only two attributes reading from each buffer.\n\n  const positionBuffer1 = regl.buffer({\n    type: \"float\"\n  });\n  const positionBuffer2 = regl.buffer({\n    type: \"float\"\n  });\n  const posePositionBuffer = regl.buffer({\n    type: \"float\"\n  });\n  const poseRotationBuffer = regl.buffer({\n    type: \"float\"\n  });\n  const command = regl(withPose({\n    vert,\n    frag,\n    blend: defaultBlend,\n    uniforms: {\n      thickness: regl.prop(\"scale.x\"),\n      viewportWidth: regl.context(\"viewportWidth\"),\n      viewportHeight: regl.context(\"viewportHeight\"),\n      alpha: regl.prop(\"alpha\"),\n      joined: regl.prop(\"joined\"),\n      scaleInvariant: regl.prop(\"scaleInvariant\")\n    },\n    attributes: {\n      pointType: pointTypeBuffer,\n      colorB: (context, {\n        joined,\n        monochrome,\n        debug\n      }) => ({\n        buffer: debug ? debugColorBuffer : colorBuffer$$1,\n        offset: 0,\n        stride: (joined || monochrome || debug ? 1 : 2) * 4 * FLOAT_BYTES,\n        divisor: monochrome || debug ? 0 : 1\n      }),\n      colorC: (context, {\n        joined,\n        monochrome,\n        debug\n      }) => ({\n        buffer: debug ? debugColorBuffer : colorBuffer$$1,\n        offset: monochrome || debug ? 0 : 4 * FLOAT_BYTES,\n        stride: (joined || monochrome || debug ? 1 : 2) * 4 * FLOAT_BYTES,\n        divisor: monochrome || debug ? 0 : 1\n      }),\n      positionA: (context, {\n        joined\n      }) => ({\n        buffer: positionBuffer1,\n        offset: 0,\n        stride: (joined ? 1 : 2) * POINT_BYTES,\n        divisor: 1\n      }),\n      positionB: (context, {\n        joined\n      }) => ({\n        buffer: positionBuffer1,\n        offset: POINT_BYTES,\n        stride: (joined ? 1 : 2) * POINT_BYTES,\n        divisor: 1\n      }),\n      positionC: (context, {\n        joined\n      }) => ({\n        buffer: positionBuffer2,\n        offset: 2 * POINT_BYTES,\n        stride: (joined ? 1 : 2) * POINT_BYTES,\n        divisor: 1\n      }),\n      positionD: (context, {\n        joined\n      }) => ({\n        buffer: positionBuffer2,\n        offset: 3 * POINT_BYTES,\n        stride: (joined ? 1 : 2) * POINT_BYTES,\n        divisor: 1\n      }),\n      posePosition: (context, {\n        hasInstancedPoses\n      }) => ({\n        buffer: hasInstancedPoses ? posePositionBuffer : defaultPosePositionBuffer,\n        divisor: hasInstancedPoses ? 1 : 0\n      }),\n      poseRotation: (context, {\n        hasInstancedPoses\n      }) => ({\n        buffer: hasInstancedPoses ? poseRotationBuffer : defaultPoseRotationBuffer,\n        divisor: hasInstancedPoses ? 1 : 0\n      })\n    },\n    count: VERTICES_PER_INSTANCE,\n    instances: regl.prop(\"instances\"),\n    primitive: regl.prop(\"primitive\")\n  }));\n  let colorArray = new Float32Array(VERTICES_PER_INSTANCE * 4);\n  let pointArray = new Float32Array(0);\n  let allocatedPoints = 0;\n  let positionArray = new Float32Array(0);\n  let rotationArray = new Float32Array(0);\n\n  function fillPointArray(points, alreadyClosed, shouldClose) {\n    const numTotalPoints = points.length + (shouldClose ? 3 : 2);\n\n    if (allocatedPoints < numTotalPoints) {\n      pointArray = new Float32Array(numTotalPoints * 3);\n      allocatedPoints = numTotalPoints;\n    }\n\n    points.forEach((point, i) => {\n      const [x, y, z] = shouldConvert(point) ? pointToVec3(point) : point;\n      const off = 3 + i * 3;\n      pointArray[off + 0] = x;\n      pointArray[off + 1] = y;\n      pointArray[off + 2] = z;\n    }); // The \"prior\" point (A) and \"next\" point (D) need to be set when rendering the first & last\n    // segments, so we copy data from the last point(s) to the beginning of the array, and from the\n    // first point(s) to the end of the array.\n\n    const n = numTotalPoints * 3;\n\n    if (alreadyClosed) {\n      // First and last points already match; \"prior\" should be the second-to-last\n      // and \"next\" should be the second.\n      pointArray.copyWithin(0, n - 9, n - 6);\n      pointArray.copyWithin(n - 3, 6, 9);\n    } else if (shouldClose) {\n      // First point is being reused after last point; first *two* points need to be copied at the end\n      pointArray.copyWithin(0, n - 9, n - 6);\n      pointArray.copyWithin(n - 6, 3, 9);\n    } else {\n      // Endpoints are separate; just duplicate first & last points, resulting in square-looking endcaps\n      pointArray.copyWithin(0, 3, 6);\n      pointArray.copyWithin(n - 3, n - 6, n - 3);\n    }\n  }\n\n  function fillPoseArrays(instances, poses) {\n    if (positionArray.length < instances * 3) {\n      positionArray = new Float32Array(instances * 3);\n      rotationArray = new Float32Array(instances * 4);\n    }\n\n    for (let index = 0; index < poses.length; index++) {\n      const positionOffset = index * 3;\n      const rotationOffset = index * 4;\n      const {\n        position,\n        orientation: r\n      } = poses[index];\n      const convertedPosition = Array.isArray(position) ? position : pointToVec3(position);\n      positionArray[positionOffset + 0] = convertedPosition[0];\n      positionArray[positionOffset + 1] = convertedPosition[1];\n      positionArray[positionOffset + 2] = convertedPosition[2];\n      const convertedRotation = Array.isArray(r) ? r : [r.x, r.y, r.z, r.w];\n      rotationArray[rotationOffset + 0] = convertedRotation[0];\n      rotationArray[rotationOffset + 1] = convertedRotation[1];\n      rotationArray[rotationOffset + 2] = convertedRotation[2];\n      rotationArray[rotationOffset + 3] = convertedRotation[3];\n    }\n  }\n\n  function convertColors(colors) {\n    return shouldConvert(colors) ? colors.map(toRGBA) : colors;\n  }\n\n  function fillColorArray(color, colors, monochrome, shouldClose) {\n    if (monochrome) {\n      if (colorArray.length < VERTICES_PER_INSTANCE * 4) {\n        colorArray = new Float32Array(VERTICES_PER_INSTANCE * 4);\n      }\n\n      const monochromeColor = color || DEFAULT_MONOCHROME_COLOR;\n      const [convertedMonochromeColor] = convertColors([monochromeColor]);\n      const [r, g, b, a] = convertedMonochromeColor;\n\n      for (let index = 0; index < VERTICES_PER_INSTANCE; index++) {\n        const offset = index * 4;\n        colorArray[offset + 0] = r;\n        colorArray[offset + 1] = g;\n        colorArray[offset + 2] = b;\n        colorArray[offset + 3] = a;\n      }\n    } else if (colors) {\n      const length = shouldClose ? colors.length + 1 : colors.length;\n\n      if (colorArray.length < length * 4) {\n        colorArray = new Float32Array(length * 4);\n      }\n\n      const convertedColors = convertColors(colors);\n\n      for (let index = 0; index < convertedColors.length; index++) {\n        const offset = index * 4;\n        const [r, g, b, a] = convertedColors[index];\n        colorArray[offset + 0] = r;\n        colorArray[offset + 1] = g;\n        colorArray[offset + 2] = b;\n        colorArray[offset + 3] = a;\n      }\n\n      if (shouldClose) {\n        const [r, g, b, a] = convertedColors[0];\n        const lastIndex = length - 1;\n        colorArray[lastIndex * 4 + 0] = r;\n        colorArray[lastIndex * 4 + 1] = g;\n        colorArray[lastIndex * 4 + 2] = b;\n        colorArray[lastIndex * 4 + 3] = a;\n      }\n    }\n  } // Disable depth for debug rendering (so lines stay visible)\n\n\n  const render = (debug, commands) => {\n    if (debug) {\n      regl({\n        depth: {\n          enable: false\n        }\n      })(commands);\n    } else {\n      commands();\n    }\n  }; // Render one line list/strip\n\n\n  function renderLine(props) {\n    const {\n      debug,\n      primitive = \"lines\",\n      scaleInvariant = false\n    } = props;\n    const numInputPoints = props.points.length;\n\n    if (numInputPoints < 2) {\n      return;\n    }\n\n    const alreadyClosed = numInputPoints > 2 && pointsEqual(props.points[0], props.points[numInputPoints - 1]); // whether the first point needs to be duplicated after the last point\n\n    const shouldClose = !alreadyClosed && props.closed;\n    fillPointArray(props.points, alreadyClosed, shouldClose);\n    positionBuffer1({\n      data: pointArray,\n      usage: \"dynamic\"\n    });\n    positionBuffer2({\n      data: pointArray,\n      usage: \"dynamic\"\n    });\n    const monochrome = !(props.colors && props.colors.length);\n    fillColorArray(props.color, props.colors, monochrome, shouldClose);\n    colorBuffer$$1({\n      data: colorArray,\n      usage: \"dynamic\"\n    });\n    const joined = primitive === \"line strip\";\n    const effectiveNumPoints = numInputPoints + (shouldClose ? 1 : 0);\n    const instances = joined ? effectiveNumPoints - 1 : Math.floor(effectiveNumPoints / 2); // fill instanced pose buffers\n\n    const {\n      poses\n    } = props;\n    const hasInstancedPoses = !!poses && poses.length > 0;\n\n    if (hasInstancedPoses && poses) {\n      if (instances !== poses.length) {\n        console.error(`Expected ${instances} poses but given ${poses.length} poses: will result in webgl error.`);\n        return;\n      }\n\n      fillPoseArrays(instances, poses);\n      posePositionBuffer({\n        data: positionArray,\n        usage: \"dynamic\"\n      });\n      poseRotationBuffer({\n        data: rotationArray,\n        usage: \"dynamic\"\n      });\n    }\n\n    render(debug, () => {\n      // Use Object.assign because it's actually faster than babel's object spread polyfill.\n      command(Object.assign({}, props, {\n        joined,\n        primitive: \"triangle strip\",\n        alpha: debug ? 0.2 : 1,\n        monochrome,\n        instances,\n        scaleInvariant,\n        hasInstancedPoses\n      }));\n\n      if (debug) {\n        command(Object.assign({}, props, {\n          joined,\n          primitive: \"line strip\",\n          alpha: 1,\n          monochrome,\n          instances,\n          scaleInvariant,\n          hasInstancedPoses\n        }));\n      }\n    });\n  }\n\n  return inProps => {\n    if (Array.isArray(inProps)) {\n      inProps.forEach(renderLine);\n    } else {\n      renderLine(inProps);\n    }\n  };\n};\n\nfunction Lines(props) {\n  return createElement(Command, _extends({\n    getChildrenForHitmap: nonInstancedGetChildrenForHitmap\n  }, props, {\n    reglCommand: lines\n  }));\n}\n\nconst pointToVec3$1 = p => ({\n  x: p[0],\n  y: p[1],\n  z: p[2]\n});\n\nconst scale = 100;\nconst x = 1 * scale;\nconst xAxisPoints = [[-x, 0, 0], [x, 0, 0]].map(pointToVec3$1);\nconst yAxisPoints = [[0, -100, 0], [0, 100, 0]].map(pointToVec3$1);\nconst zAxisPoints = [[0, 0, -100], [0, 0, 100]].map(pointToVec3$1);\nconst pose = {\n  orientation: {\n    x: 0,\n    y: 0,\n    z: 0,\n    w: 0\n  },\n  position: {\n    x: 0,\n    y: 0,\n    z: 0\n  }\n};\nconst xAxis = {\n  pose,\n  points: xAxisPoints,\n  scale: {\n    x: 0.5,\n    y: 0.5,\n    z: 0.5\n  },\n  color: {\n    r: 0.95,\n    g: 0.26,\n    b: 0.4,\n    a: 1\n  }\n};\nconst yAxis = {\n  pose,\n  points: yAxisPoints,\n  scale: {\n    x: 0.5,\n    y: 0.5,\n    z: 0.5\n  },\n  color: {\n    r: 0.02,\n    g: 0.82,\n    b: 0.49,\n    a: 1\n  }\n};\nconst zAxis = {\n  pose,\n  points: zAxisPoints,\n  scale: {\n    x: 0.5,\n    y: 0.5,\n    z: 0.5\n  },\n  color: {\n    r: 0.11,\n    g: 0.51,\n    b: 0.92,\n    a: 1\n  }\n}; // Renders lines along the x, y, and z axes; useful for debugging.\n\nclass Axes extends React__default.Component {\n  render() {\n    return React__default.createElement(Lines, null, this.props.children);\n  }\n\n}\n\n_defineProperty(Axes, \"defaultProps\", {\n  children: [xAxis, yAxis, zAxis]\n});\n\nconst cubes = fromGeometry([// bottom face corners\n[-0.5, -0.5, -0.5], [-0.5, 0.5, -0.5], [0.5, -0.5, -0.5], [0.5, 0.5, -0.5], // top face corners\n[-0.5, -0.5, 0.5], [-0.5, 0.5, 0.5], [0.5, -0.5, 0.5], [0.5, 0.5, 0.5]], [// bottom\n[0, 1, 2], [1, 2, 3], // top\n[4, 5, 6], [5, 6, 7], // left\n[0, 2, 4], [2, 4, 6], // right\n[1, 3, 5], [3, 5, 7], //front\n[2, 3, 6], [3, 6, 7], //back\n[0, 1, 4], [1, 4, 5]]);\nconst getChildrenForHitmap$2 = createInstancedGetChildrenForHitmap(1);\n\nfunction Cubes(props) {\n  return createElement(Command, _extends({\n    getChildrenForHitmap: getChildrenForHitmap$2\n  }, props, {\n    reglCommand: cubes\n  }));\n}\n\nconst NUM_PARALLELS = 15;\nconst NUM_MERIDIANS = 15;\nconst RADIUS = 0.5;\nconst northPole = [0, 0, RADIUS];\nconst southPole = [0, 0, -RADIUS];\nconst points$2 = [northPole, southPole];\nconst faces = [];\n\nfor (let i = 0; i < NUM_PARALLELS; i++) {\n  for (let j = 0; j < NUM_MERIDIANS; j++) {\n    const phi = (i + 1) / (NUM_PARALLELS + 1) * Math.PI;\n    const z = RADIUS * Math.cos(phi);\n    const width = RADIUS * Math.sin(phi);\n    const theta = j * 2 * Math.PI / NUM_MERIDIANS;\n    const x = width * Math.cos(theta);\n    const y = width * Math.sin(theta);\n    points$2.push([x, y, z]);\n\n    if (j > 0) {\n      // connect to previous parallel (or north pole)\n      const prevMeridianPt = i === 0 ? 0 : points$2.length - 1 - NUM_MERIDIANS;\n      faces.push([points$2.length - 2, points$2.length - 1, prevMeridianPt]);\n\n      if (i > 0) {\n        faces.push([points$2.length - 2, prevMeridianPt - 1, prevMeridianPt]);\n      }\n    }\n  } // connect to previous parallel (or north pole)\n\n\n  const prevMeridianPt = i === 0 ? 0 : points$2.length - 2 * NUM_MERIDIANS;\n  faces.push([points$2.length - 1, points$2.length - NUM_MERIDIANS, prevMeridianPt]);\n\n  if (i > 0) {\n    faces.push([points$2.length - 1, points$2.length - NUM_MERIDIANS - 1, prevMeridianPt]);\n  }\n} // connect last parallel to south pole\n\n\nfor (let j = 0; j < NUM_MERIDIANS; j++) {\n  const pt = points$2.length - NUM_MERIDIANS + j;\n  const prevPt = j === 0 ? points$2.length - 1 : pt - 1;\n  faces.push([pt, prevPt, 1]);\n}\n\nconst spheres = fromGeometry(points$2, faces);\nconst getChildrenForHitmap$3 = createInstancedGetChildrenForHitmap(1);\n\nfunction Spheres(props) {\n  return createElement(Command, _extends({\n    getChildrenForHitmap: getChildrenForHitmap$3\n  }, props, {\n    reglCommand: spheres\n  }));\n}\n\nfunction multiplyScale(scale, factor) {\n  return {\n    x: scale.x * factor,\n    y: scale.y * factor,\n    z: scale.z * factor\n  };\n}\n\nconst DEFAULT_COLOR = [1, 1, 1, 1];\nconst ACTIVE_POLYGON_COLOR = [0.8, 0, 0.8, 1];\nconst ACTIVE_POINT_COLOR = [1, 0.2, 1, 1];\nconst LINE_STRIP = \"line strip\";\nconst POINT_SIZE_FACTOR = 1.3;\nconst DRAW_SCALE = {\n  x: 0.1,\n  y: 0.1,\n  z: 0.1\n};\nconst DRAW_POINT_SCALE = multiplyScale(DRAW_SCALE, POINT_SIZE_FACTOR);\nconst HITMAP_SCALE = {\n  x: 0.5,\n  y: 0.5,\n  z: 0.5\n};\nconst HITMAP_POINT_SCALE = multiplyScale(HITMAP_SCALE, POINT_SIZE_FACTOR);\nconst POSE = {\n  position: {\n    x: 0,\n    y: 0,\n    z: 0\n  },\n  orientation: {\n    x: 0,\n    y: 0,\n    z: 0,\n    w: 0\n  }\n};\nlet count = 1;\n\nclass PolygonPoint {\n  constructor(points) {\n    _defineProperty(this, \"id\", void 0);\n\n    _defineProperty(this, \"point\", void 0);\n\n    _defineProperty(this, \"active\", false);\n\n    this.id = count++;\n    this.point = points;\n  }\n\n}\n\nclass Polygon {\n  constructor(name = \"\") {\n    _defineProperty(this, \"id\", void 0);\n\n    _defineProperty(this, \"name\", void 0);\n\n    _defineProperty(this, \"points\", []);\n\n    _defineProperty(this, \"active\", false);\n\n    this.name = name;\n    this.id = count++;\n  }\n\n}\n\nconst polygonLinesGetChildrenForHitmap = (props, assignNextColors, excludedObjects) => {\n  // This is almost identical to the default nonInstancedGetChildrenForHitmap, with changes marked.\n  return props.map(prop => {\n    if (excludedObjects.some(({\n      object\n    }) => object === prop)) {\n      return null;\n    }\n\n    const hitmapProp = _objectSpread({}, prop); // Change from original: pass the original marker as a callback object instead of this marker.\n\n\n    const [hitmapColor] = assignNextColors(prop.originalMarker, 1); // Change from original: increase scale for hitmap\n\n    hitmapProp.scale = HITMAP_SCALE;\n    hitmapProp.color = hitmapColor;\n\n    if (hitmapProp.colors && hitmapProp.points && hitmapProp.points.length) {\n      hitmapProp.colors = new Array(hitmapProp.points.length).fill(hitmapColor);\n    }\n\n    return hitmapProp;\n  }).filter(Boolean);\n};\n/**\n * Draw the polygon lines\n */\n\n\nclass PolygonLines extends React__default.Component {\n  render() {\n    const polygons = this.props.children;\n    const lines = [];\n\n    for (const poly of polygons) {\n      const color = poly.active ? ACTIVE_POLYGON_COLOR : DEFAULT_COLOR;\n      const points = poly.points.map(({\n        point\n      }) => vec3ToPoint(point));\n      lines.push({\n        primitive: LINE_STRIP,\n        pose: POSE,\n        points,\n        scale: DRAW_SCALE,\n        color: vec4ToRGBA(color),\n        originalMarker: poly\n      });\n    }\n\n    return React__default.createElement(Lines, {\n      getChildrenForHitmap: polygonLinesGetChildrenForHitmap\n    }, lines);\n  }\n\n}\n\nconst polygonPointsGetChildrenForHitmap = (props, assignNextColors, excludedObjects) => {\n  // This is similar to the default nonInstancedGetChildrenForHitmap, with changes marked.\n  return props.map(prop => {\n    if (excludedObjects.some(({\n      object\n    }) => object === prop)) {\n      return null;\n    }\n\n    const hitmapProp = _objectSpread({}, prop); // Change from original: assign a non-instanced color to each point color, even though this marker uses\n    // instancing.\n    // This is so that we can have a unique callback object for each point.\n\n\n    hitmapProp.colors = hitmapProp.colors.map((color, index) => {\n      return assignNextColors(prop.originalMarkers[index], 1);\n    }); // Change from original: increase scale for hitmap\n\n    hitmapProp.scale = HITMAP_POINT_SCALE;\n    return hitmapProp;\n  }).filter(Boolean);\n};\n/**\n * Draw the polygon points at the end of each lines\n */\n\n\nclass PolygonPoints extends React__default.Component {\n  render() {\n    const polygons = this.props.children;\n    const points = [];\n    const colors = [];\n    const originalMarkers = [];\n\n    for (const poly of polygons) {\n      const color = poly.active ? ACTIVE_POLYGON_COLOR : DEFAULT_COLOR;\n\n      for (const point of poly.points) {\n        const convertedPoint = vec3ToPoint(point.point);\n        points.push(convertedPoint);\n        colors.push(point.active ? ACTIVE_POINT_COLOR : color);\n        originalMarkers.push(point);\n      }\n    }\n\n    const sphereList = {\n      points,\n      colors,\n      pose: POSE,\n      scale: DRAW_POINT_SCALE,\n      originalMarkers\n    };\n    return React__default.createElement(Spheres, {\n      getChildrenForHitmap: polygonPointsGetChildrenForHitmap\n    }, [sphereList]);\n  }\n\n}\n\nfunction DrawPolygons({\n  children: polygons = []\n}) {\n  if (polygons.length === 0) {\n    return null;\n  }\n\n  return React__default.createElement(React__default.Fragment, null, React__default.createElement(PolygonLines, null, polygons), React__default.createElement(PolygonPoints, null, polygons));\n}\n\nfunction areEqual(point1, point2) {\n  const [x1, y1, z1] = point1.point;\n  const [x2, y2, z2] = point2.point;\n  return x1 === x2 && y1 === y2 && z1 === z2;\n}\n\nfunction isClosed(polygon) {\n  const {\n    points\n  } = polygon;\n\n  for (let i = 0; i < points.length - 1; i++) {\n    if (areEqual(points[i], points[i + 1])) {\n      return true;\n    }\n  }\n\n  const firstPoint = points[0];\n  const lastPoint = points[points.length - 1];\n  return areEqual(firstPoint, lastPoint);\n} // Has listeners you can pass to Worldview for mouse interactions\n// internally builds a list of polygons and modifies the polygons\n// based on mouse & keyboard interactions. For now we use mututation internally\n// instead of immutability to keep the number of allocations lower and make\n// the implementation a bit more straightforward\n\n\nclass PolygonBuilder {\n  constructor(polygons = []) {\n    _defineProperty(this, \"mouseDown\", false);\n\n    _defineProperty(this, \"polygons\", void 0);\n\n    _defineProperty(this, \"onChange\", () => {});\n\n    _defineProperty(this, \"activePolygon\", void 0);\n\n    _defineProperty(this, \"activePoint\", void 0);\n\n    _defineProperty(this, \"mouseDownPoint\", void 0);\n\n    _defineProperty(this, \"onMouseMove\", (e, args) => {\n      // prevent the camera from responding to move if we\n      // have an active object being edited\n      if (this.activePolygon) {\n        e.preventDefault();\n        e.stopPropagation();\n      } //const cursor = e.ctrlKey ? 'crosshair' : '';\n      //document.body.style.cursor = cursor;\n\n\n      if (!this.mouseDown) {\n        return;\n      }\n\n      if (!args) {\n        return;\n      } // early return to only raycast when mouse moves during interaction\n\n\n      if (!this.activePoint && !this.activePolygon) {\n        return;\n      }\n\n      const {\n        ray\n      } = args;\n      const point = ray.planeIntersection([0, 0, 0], [0, 0, 1]); // satisfy flow\n\n      if (!point) {\n        return;\n      } // satisfy flow\n\n\n      const {\n        activePolygon\n      } = this;\n\n      if (this.activePoint) {\n        this.updateActivePoint(point);\n      } else if (activePolygon && this.mouseDownPoint) {\n        // move polygon\n        const [pointX, pointY] = point;\n        const [mouseX, mouseY] = this.mouseDownPoint; // figure out how far the mouse has moved\n\n        const dX = pointX - mouseX;\n        const dY = pointY - mouseY; // save the new mouse position as for the next computation\n\n        this.mouseDownPoint = point; // only update the 'overlap' point once\n\n        const uniquePoints = activePolygon.points.reduce((acc, point) => {\n          if (!acc.includes(point)) {\n            acc.push(point);\n          }\n\n          return acc;\n        }, []); // adjust each point's location\n\n        for (const polygonPoint of uniquePoints) {\n          const {\n            point\n          } = polygonPoint;\n          point[0] = point[0] + dX;\n          point[1] = point[1] + dY;\n        }\n\n        this.onChange();\n      }\n    });\n\n    _defineProperty(this, \"onKeyDown\", e => {\n      // only respond to key events if we have a selected polygon\n      const {\n        activePolygon\n      } = this;\n\n      if (!activePolygon) {\n        return;\n      }\n\n      switch (e.key) {\n        case \"Delete\":\n        case \"Backspace\":\n          if (this.activePoint) {\n            this.deletePoint(this.activePoint);\n          } else {\n            this.deletePolygon(activePolygon);\n          }\n\n          this.onChange();\n          break;\n\n        default:\n          break;\n      }\n    });\n\n    _defineProperty(this, \"onMouseUp\", (e, args) => {\n      if (!e.ctrlKey) {\n        this.mouseDown = false;\n      }\n    });\n\n    _defineProperty(this, \"onDoubleClick\", (e, args) => {\n      // satisfy flow\n      if (!args) {\n        return;\n      }\n\n      if (!args.objects.length) {\n        return;\n      }\n\n      this.selectObject(args.objects[0].object); // if a point was double-clicked, delete it\n\n      if (this.activePoint) {\n        this.deletePoint(this.activePoint);\n        return;\n      } // otherwise insert a new point into the nearest line of the active polygon\n\n\n      const {\n        activePolygon\n      } = this; // if no polygon is active, don't do anything w/ the double-click\n\n      if (!activePolygon) {\n        return;\n      }\n\n      let shortestDistance = Number.MAX_SAFE_INTEGER;\n      let shortestIndex = -1;\n      const {\n        ray\n      } = args;\n      const point = ray.planeIntersection([0, 0, 0], [0, 0, 1]);\n\n      if (!point) {\n        return;\n      }\n\n      const [px, py] = point; // find the closest line segment of the active polygon\n\n      const {\n        points\n      } = activePolygon;\n\n      for (let i = 0; i < points.length - 1; i++) {\n        const point1 = points[i];\n        const point2 = points[i + 1];\n        const [x1, y1] = point1.point;\n        const [x2, y2] = point2.point; // distance.squared is faster since we don't care about the\n        // actual distance, just which line produces the shortest distance\n\n        const dist = distance.squared(x1, y1, x2, y2, px, py);\n\n        if (dist < shortestDistance) {\n          shortestDistance = dist;\n          shortestIndex = i;\n        }\n      } // insert a new point in the nearest line\n\n\n      if (shortestIndex > -1) {\n        const newPoint = new PolygonPoint(point);\n        activePolygon.points.splice(shortestIndex + 1, 0, newPoint);\n        this.activePoint = newPoint;\n      }\n\n      this.onChange();\n    });\n\n    _defineProperty(this, \"onMouseDown\", (e, args) => {\n      if (!args) {\n        return;\n      }\n\n      const {\n        ray\n      } = args;\n      const point = ray.planeIntersection([0, 0, 0], [0, 0, 1]); // satisfy flow but raycasting should always work\n\n      if (!point) {\n        return;\n      }\n\n      const isFirstClick = !this.mouseDown;\n      this.mouseDown = true;\n      this.mouseDownPoint = point;\n      const isCtrlClick = e.ctrlKey; // single click or click+drag is for selection & moving\n\n      if (isFirstClick && !isCtrlClick) {\n        const clickObject = args.objects[0];\n        this.selectObject(clickObject && clickObject.object);\n        return this.onChange();\n      } // ctrl+click always inserts a point\n\n\n      if (isCtrlClick) {\n        this.pushPoint(point);\n        return this.onChange();\n      } // if mouse was down & we have a non-control click, close the active polygon\n\n\n      this.closeActivePolygon();\n      return this.onChange();\n    });\n\n    this.polygons = polygons;\n  }\n\n  isActivePolygonClosed() {\n    return !!this.activePolygon && isClosed(this.activePolygon);\n  } // adds a polygon to the builder, transforming it into the internal representation\n\n\n  addPolygon(cmd) {\n    const {\n      points,\n      name\n    } = cmd;\n\n    if (points.length < 3) {\n      return;\n    } // clear any selections\n\n\n    this.selectObject();\n    const polygon = new Polygon(name);\n    polygon.points = points.map(p => new PolygonPoint([p.x, p.y, p.z || 0]));\n\n    if (!isClosed(polygon)) {\n      polygon.points.push(polygon.points[0]);\n    }\n\n    this.polygons.push(polygon);\n  } // push a new point - either adds to the active polygon\n  // or creates a new polygon at this point\n\n\n  pushPoint(point) {\n    const {\n      activePolygon\n    } = this;\n\n    if (activePolygon) {\n      // do not push a point on a closed polygon\n      if (!isClosed(activePolygon)) {\n        const newPoint = new PolygonPoint(point);\n        activePolygon.points.push(newPoint);\n        this.selectObject(newPoint);\n        return;\n      }\n    }\n\n    const polygon = new Polygon();\n    polygon.points.push(new PolygonPoint(point));\n    const floatingPoint = new PolygonPoint(point);\n    polygon.points.push(floatingPoint);\n    this.polygons.push(polygon);\n    this.selectObject(floatingPoint);\n    this.onChange();\n  } // updates the active point to the new position\n\n\n  updateActivePoint(point) {\n    if (this.activePoint) {\n      this.activePoint.point = point;\n      this.onChange();\n    }\n  } // closes the active polygon by either deleting it if\n  // is only 2 points (no \"single sided\" polygons...)\n  // or inserts an 'overlap' point by making the first point\n  // and last point a reference to the same point in the list\n  // this structure of overlap is similar to the structure used by geoJSON\n  // though \"left to right\" ordering is not enforced\n\n\n  closeActivePolygon() {\n    const polygon = this.activePolygon;\n\n    if (!polygon) {\n      return;\n    } // remove single lines\n\n\n    if (polygon.points.length === 2) {\n      this.deletePolygon(polygon);\n    } else {\n      polygon.points.push(polygon.points[0]);\n    }\n\n    this.onChange();\n  } // mouse move handler - should be added to Worldview as a prop\n  // deletes a polygon\n\n\n  deletePolygon(polygon) {\n    this.polygons = this.polygons.filter(poly => poly !== polygon);\n    this.activePolygon = null;\n  } // deletes a point in the active polygon\n  // if the point is the 'overlap point' create a new one\n  // also deletes the entire polygon if the polygon becomes a 1-sided polygon\n\n\n  deletePoint(point) {\n    const {\n      activePolygon\n    } = this;\n\n    if (!activePolygon) {\n      return;\n    }\n\n    const newPoints = activePolygon.points.filter(p => p.id !== point.id); // if the 'overlap' point is deleted, create a new start/end overlap point\n\n    if (newPoints.length === activePolygon.points.length - 2) {\n      newPoints.push(newPoints[0]);\n    }\n\n    activePolygon.points = newPoints;\n    this.activePoint = null;\n\n    if (activePolygon.points.length < 4) {\n      this.deletePolygon(activePolygon);\n    }\n\n    this.onChange();\n  } // key down handler - to be passed to Worldview as a prop\n  // select either a point or polygon by id\n\n\n  selectObject(object) {\n    // clear out any previously active objects\n    this.activePolygon = null;\n\n    if (this.activePoint) {\n      this.activePoint.active = false;\n    }\n\n    this.activePoint = null;\n\n    for (const polygon of this.polygons) {\n      let isActive = polygon === object;\n      polygon.active = isActive;\n\n      if (isActive) {\n        this.activePolygon = polygon;\n      }\n\n      for (const point of polygon.points) {\n        if (point === object) {\n          // if a point is selected, activate both it\n          // and the polygon it belongs to\n          this.activePoint = point;\n          point.active = true;\n          polygon.active = true;\n          this.activePolygon = polygon;\n          isActive = true;\n        }\n      }\n    }\n\n    this.onChange();\n  } // mouse up handler - to be passed to Worldview as a prop\n\n\n}\n\nconst defaultSingleColorDepth = {\n  enable: true,\n  mask: false\n};\nconst defaultVetexColorDepth = {\n  enable: true,\n  mask: true,\n  func: \"<=\"\n};\n\nconst singleColor = regl => withPose({\n  primitive: \"triangles\",\n  vert: `\n  precision mediump float;\n\n  attribute vec3 point;\n\n  uniform mat4 projection, view;\n\n  #WITH_POSE\n\n  void main () {\n    vec3 pos = applyPose(point);\n    gl_Position = projection * view * vec4(pos, 1);\n  }\n  `,\n  frag: `\n  precision mediump float;\n  uniform vec4 color;\n  void main () {\n    gl_FragColor = color;\n  }\n  `,\n  attributes: {\n    point: (context, props) => {\n      if (shouldConvert(props.points)) {\n        return pointToVec3Array(props.points);\n      }\n\n      return props.points;\n    },\n    color: (context, props) => {\n      if (shouldConvert(props.colors) || shouldConvert(props.color)) {\n        return getVertexColors(props);\n      }\n\n      return props.color || props.colors;\n    }\n  },\n  uniforms: {\n    color: (context, props) => {\n      if (shouldConvert(props.color)) {\n        return toRGBA(props.color);\n      }\n\n      return props.color;\n    }\n  },\n  // can pass in { enable: true, depth: false } to turn off depth to prevent flicker\n  // because multiple items are rendered to the same z plane\n  depth: {\n    enable: (context, props) => {\n      return props.depth && props.depth.enable || defaultSingleColorDepth.enable;\n    },\n    mask: (context, props) => {\n      return props.depth && props.depth.mask || defaultSingleColorDepth.mask;\n    }\n  },\n  blend: defaultBlend,\n  count: (context, props) => props.points.length\n});\n\nconst vertexColors = regl => withPose({\n  primitive: \"triangles\",\n  vert: `\n  precision mediump float;\n\n  attribute vec3 point;\n  attribute vec4 color;\n\n  uniform mat4 projection, view;\n\n  varying vec4 vColor;\n\n  #WITH_POSE\n\n  void main () {\n    vec3 pos = applyPose(point);\n    vColor = color;\n    gl_Position = projection * view * vec4(pos, 1);\n  }\n  `,\n  frag: `\n  precision mediump float;\n  varying vec4 vColor;\n  void main () {\n    gl_FragColor = vColor;\n  }\n  `,\n  attributes: {\n    point: (context, props) => {\n      if (shouldConvert(props.points)) {\n        return pointToVec3Array(props.points);\n      }\n\n      return props.points;\n    },\n    color: (context, props) => {\n      if (shouldConvert(props.colors) || shouldConvert(props.color)) {\n        return getVertexColors(props);\n      }\n\n      return props.color || props.colors;\n    }\n  },\n  depth: {\n    enable: (context, props) => {\n      return props.depth && props.depth.enable || defaultVetexColorDepth.enable;\n    },\n    mask: (context, props) => {\n      return props.depth && props.depth.mask || defaultVetexColorDepth.mask;\n    }\n  },\n  blend: defaultBlend,\n  count: (context, props) => props.points.length\n}); // command to render triangle lists optionally supporting vertex colors for each triangle\n\n\nconst triangles = regl => {\n  const single = regl(singleColor(regl));\n  const vertex = regl(vertexColors(regl));\n  return (props, isHitmap) => {\n    const items = Array.isArray(props) ? props : [props];\n    const singleColorItems = [];\n    const vertexColorItems = [];\n    items.forEach(item => {\n      // If the item has onlyRenderInHitmap set, only render it in the hitmap.\n      if (isHitmap || !item.onlyRenderInHitmap) {\n        if (item.colors && item.colors.length) {\n          vertexColorItems.push(item);\n        } else {\n          singleColorItems.push(item);\n        }\n      }\n    });\n    single(singleColorItems);\n    vertex(vertexColorItems);\n  };\n};\n\nconst getChildrenForHitmap$4 = createInstancedGetChildrenForHitmap(3);\n\nfunction Triangles(props) {\n  return createElement(Command, _extends({\n    getChildrenForHitmap: getChildrenForHitmap$4\n  }, props, {\n    reglCommand: triangles\n  }));\n}\n\nconst NO_POSE = {\n  position: {\n    x: 0,\n    y: 0,\n    z: 0\n  },\n  orientation: {\n    x: 0,\n    y: 0,\n    z: 0,\n    w: 0\n  }\n};\nconst DEFAULT_SCALE = {\n  x: 1,\n  y: 1,\n  z: 1\n};\n\nfunction flatten3D(points) {\n  const array = new Float32Array(points.length * 3);\n\n  for (let i = 0; i < points.length; i++) {\n    const [x, y, z] = points[i];\n    array[i * 3] = x;\n    array[i * 3 + 1] = y;\n    array[i * 3 + 2] = z;\n  }\n\n  return array;\n}\n\nfunction getEarcutPoints(points) {\n  const flattenedPoints = flatten3D(points);\n  const indices = earcut(flattenedPoints, null, 3);\n  const newPoints = [];\n\n  for (let i = 0; i < indices.length; i++) {\n    const originalIndex = indices[i];\n    newPoints.push(points[originalIndex]);\n  }\n\n  return newPoints;\n} // command to draw a filled polygon\n\n\nfunction FilledPolygons(_ref) {\n  let {\n    children: polygons = []\n  } = _ref,\n      rest = _objectWithoutProperties(_ref, [\"children\"]);\n\n  const triangles = polygons.map(poly => {\n    // $FlowFixMe flow doesn't know how shouldConvert works\n    const points = shouldConvert(poly.points) ? poly.points.map(pointToVec3) : poly.points;\n    const pose = poly.pose ? poly.pose : NO_POSE;\n    const earcutPoints = getEarcutPoints(points);\n    return _objectSpread({}, poly, {\n      points: earcutPoints,\n      pose,\n      scale: DEFAULT_SCALE,\n      originalMarker: poly\n    });\n  }); // Overwrite the triangle's default getChildrenForHitmap because we want to event as if each triangle is a single\n  // polygon.\n\n  return React__default.createElement(Triangles, _extends({\n    getChildrenForHitmap: getChildrenForHitmapWithOriginalMarker\n  }, rest), triangles);\n}\n\nconst BG_COLOR_LIGHT = \"#ffffff\";\nconst BG_COLOR_DARK = \"rgba(0,0,0,0.8)\";\nconst BRIGHTNESS_THRESHOLD = 128;\nconst DEFAULT_TEXT_COLOR$1 = {\n  r: 1,\n  g: 1,\n  b: 1,\n  a: 1\n};\nconst DEFAULT_BG_COLOR = {\n  r: 0,\n  g: 0,\n  b: 0,\n  a: 0.8\n};\nlet cssHasBeenInserted = false;\n\nfunction insertGlobalCss() {\n  if (cssHasBeenInserted) {\n    return;\n  }\n\n  const style = document.createElement(\"style\");\n  style.innerHTML = `\n    .regl-worldview-text-wrapper {\n      position: absolute;\n      white-space: nowrap;\n      z-index: 100;\n      pointer-events: none;\n      top: 0;\n      left: 0;\n      will-change: transform;\n    }\n    .regl-worldview-text-inner {\n      position: relative;\n      left: -50%;\n      top: -0.5em;\n      white-space: pre-line;\n    }\n  `;\n\n  if (document.body) {\n    document.body.appendChild(style);\n  }\n\n  cssHasBeenInserted = true;\n}\n\nfunction isColorDark({\n  r,\n  g,\n  b\n}) {\n  // ITU-R BT.709 https://en.wikipedia.org/wiki/Rec._709\n  // 0.2126 * 255 * r + 0.7152 * 255 * g + 0.0722 * 255 * b\n  const luma = 54.213 * r + 182.376 * g + 18.411 * b;\n  return luma < BRIGHTNESS_THRESHOLD;\n}\n\nfunction isColorEqual(a, b) {\n  return a.r === b.r && a.g === b.g && a.b === b.b && a.a === b.a;\n}\n\nclass TextElement {\n  // store prev colors to improve perf\n  constructor() {\n    _defineProperty(this, \"wrapper\", document.createElement(\"span\"));\n\n    _defineProperty(this, \"_inner\", document.createElement(\"span\"));\n\n    _defineProperty(this, \"_text\", document.createTextNode(\"\"));\n\n    _defineProperty(this, \"_prevTextColor\", DEFAULT_TEXT_COLOR$1);\n\n    _defineProperty(this, \"_prevBgColor\", DEFAULT_BG_COLOR);\n\n    _defineProperty(this, \"_prevAutoBackgroundColor\", null);\n\n    insertGlobalCss();\n    this.wrapper.className = \"regl-worldview-text-wrapper\";\n    this._inner.className = \"regl-worldview-text-inner\";\n    this.wrapper.appendChild(this._inner);\n\n    this._inner.appendChild(this._text);\n\n    this.wrapper.style.color = getCSSColor(DEFAULT_TEXT_COLOR$1);\n  }\n\n  update(marker, left, top, autoBackgroundColor) {\n    this.wrapper.style.transform = `translate(${left.toFixed()}px,${top.toFixed()}px)`;\n    const {\n      color,\n      colors = []\n    } = marker;\n    const hasBgColor = colors.length >= 2;\n    const textColor = hasBgColor ? colors[0] : color;\n\n    if (textColor) {\n      if (!isColorEqual(this._prevTextColor, textColor)) {\n        this._prevTextColor = textColor;\n        this.wrapper.style.color = getCSSColor(textColor);\n      }\n\n      if (!autoBackgroundColor && autoBackgroundColor !== this._prevAutoBackgroundColor) {\n        // remove background color if autoBackgroundColor has changed\n        this._inner.style.background = \"transparent\";\n        this._prevBgColor = null;\n      } else {\n        if (autoBackgroundColor && (!this._prevBgColor || this._prevBgColor && !isColorEqual(textColor, this._prevBgColor))) {\n          // update background color with automatic dark/light color\n          this._prevBgColor = textColor;\n          const isTextColorDark = isColorDark(textColor);\n          const hexBgColor = isTextColorDark ? BG_COLOR_LIGHT : BG_COLOR_DARK;\n          this._inner.style.background = hexBgColor;\n        } else if (hasBgColor && this._prevBgColor && !isColorEqual(colors[1], this._prevBgColor)) {\n          // update background color with colors[1] data\n          this._prevBgColor = colors[1];\n          this._inner.style.background = getCSSColor(colors[1]);\n        }\n      }\n    }\n\n    this._prevAutoBackgroundColor = autoBackgroundColor;\n\n    if (this._text.textContent !== marker.text) {\n      this._text.textContent = marker.text || \"\";\n    }\n  }\n\n} // Render text on a scene using DOM nodes, similar to the Overlay command.\n// Implementation uses manual DOM manipulation to avoid the performance hit from React tree reconciliation.\n\n\nclass Text extends React__default.Component {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"_context\", void 0);\n\n    _defineProperty(this, \"_textComponents\", new Map());\n\n    _defineProperty(this, \"_textContainerRef\", React__default.createRef());\n\n    _defineProperty(this, \"componentWillUnmount\", () => {\n      if (this._context) {\n        this._context.unregisterPaintCallback(this.paint);\n      }\n    });\n\n    _defineProperty(this, \"paint\", () => {\n      const context = this._context;\n      const textComponents = this._textComponents;\n      const {\n        children: markers,\n        autoBackgroundColor\n      } = this.props;\n      const {\n        current: textContainer\n      } = this._textContainerRef;\n      const initializedData = context && context.initializedData;\n\n      if (!textContainer || !context || !initializedData) {\n        return;\n      }\n\n      const {\n        dimension,\n        dimension: {\n          width,\n          height\n        }\n      } = context;\n      const {\n        camera\n      } = initializedData;\n      const componentsToRemove = new Set(textComponents.keys());\n\n      for (const marker of markers) {\n        const {\n          pose,\n          name\n        } = marker;\n        const {\n          position\n        } = pose;\n        const coord = this.project(position, camera, dimension);\n\n        if (!coord) {\n          continue;\n        }\n\n        const [left, top] = coord;\n\n        if (left < -10 || top < -10 || left > width + 10 || top > height + 10) {\n          continue;\n        }\n\n        let el = textComponents.get(name || marker);\n\n        if (el) {\n          componentsToRemove.delete(name || marker);\n        } else {\n          el = new TextElement();\n          textComponents.set(name || marker, el);\n          textContainer.appendChild(el.wrapper);\n        }\n\n        el.update(marker, left, top, autoBackgroundColor);\n      }\n\n      for (const key of componentsToRemove) {\n        const el = textComponents.get(key);\n\n        if (!el) {\n          continue;\n        }\n\n        el.wrapper.remove();\n        textComponents.delete(key);\n      }\n    });\n\n    _defineProperty(this, \"project\", (point, camera, dimension) => {\n      const vec = [point.x, point.y, point.z];\n      const {\n        left,\n        top,\n        width,\n        height\n      } = dimension;\n      const viewport = [left, top, width, height];\n      return camera.toScreenCoord(viewport, vec);\n    });\n  }\n\n  componentDidMount() {\n    if (this._context) {\n      this._context.registerPaintCallback(this.paint);\n    }\n  }\n\n  render() {\n    return React__default.createElement(React__default.Fragment, null, React__default.createElement(\"div\", {\n      ref: this._textContainerRef\n    }), React__default.createElement(WorldviewReactContext.Consumer, null, ctx => {\n      if (ctx) {\n        this._context = ctx;\n      }\n\n      return null;\n    }));\n  }\n\n}\n\n_defineProperty(Text, \"defaultProps\", {\n  children: []\n}); // There are many external resources about SDFs and text rendering in WebGL, including:\n// https://steamcdn-a.akamaihd.net/apps/valve/2007/SIGGRAPH2007_AlphaTestedMagnification.pdf\n// https://blog.mapbox.com/drawing-text-with-signed-distance-fields-in-mapbox-gl-b0933af6f817\n// http://hack.chrons.me/opengl-text-rendering/\n// https://stackoverflow.com/questions/25956272/better-quality-text-in-webgl\n//\n// Approach\n// ========\n// Characters from the font are measured using a <canvas> and the SDFs are drawn into a texture up front\n// (and whenever new characters are being rendered). Then one instanced draw call is made with an instance\n// per character which reads from the corresponding place in the texture atlas.\n//\n// Possible future improvements\n// ============================\n// - Add hitmap support.\n// - Allow customization of font style, maybe highlight ranges.\n// - Add a scaleInvariant option.\n// - Consider a solid rectangular background instead of an outline. This is challenging because the\n//   instances currently overlap, so there will be z-fighting, but might be possible using the stencil buffer and multiple draw calls.\n// - Somehow support kerning and more advanced font metrics. However, the web font APIs may not\n//   provide support for this. Some font info could be generated/stored offline, possibly including the atlas.\n// - Explore multi-channel SDFs.\n// Font size used in rendering the atlas. This is independent of the `scale` of the rendered text.\n\n\nconst FONT_SIZE = 40;\nconst MAX_ATLAS_WIDTH = 512;\nconst SDF_RADIUS = 8;\nconst CUTOFF = 0.25;\nconst BUFFER = 10;\nconst BG_COLOR_LIGHT$1 = Object.freeze({\n  r: 1,\n  g: 1,\n  b: 1,\n  a: 1\n});\nconst BG_COLOR_DARK$1 = Object.freeze({\n  r: 0,\n  g: 0,\n  b: 0,\n  a: 1\n});\nconst memoizedCreateCanvas = memoizeOne(font => {\n  const canvas = document.createElement(\"canvas\");\n  const ctx = canvas.getContext(\"2d\");\n  ctx.font = font;\n  return ctx;\n}); // Build a single font atlas: a texture containing all characters and position/size data for each character.\n\nconst createMemoizedBuildAtlas = () => memoizeOne(charSet => {\n  const tinySDF = new TinySDF(FONT_SIZE, BUFFER, SDF_RADIUS, CUTOFF, \"sans-serif\", \"normal\");\n  const ctx = memoizedCreateCanvas(`${FONT_SIZE}px sans-serif`);\n  let textureWidth = 0;\n  const rowHeight = FONT_SIZE + 2 * BUFFER;\n  const charInfo = {}; // Measure and assign positions to all characters\n\n  let x = 0;\n  let y = 0;\n\n  for (const char of charSet) {\n    const width = ctx.measureText(char).width;\n    const dx = Math.ceil(width) + 2 * BUFFER;\n\n    if (x + dx > MAX_ATLAS_WIDTH) {\n      x = 0;\n      y += rowHeight;\n    }\n\n    charInfo[char] = {\n      x,\n      y,\n      width\n    };\n    x += dx;\n    textureWidth = Math.max(textureWidth, x);\n  }\n\n  const textureHeight = y + rowHeight;\n  const textureData = new Uint8Array(textureWidth * textureHeight); // Use tiny-sdf to create SDF images for each character and copy them into a single texture\n\n  for (const char of charSet) {\n    const {\n      x,\n      y\n    } = charInfo[char];\n    const data = tinySDF.draw(char);\n\n    for (let i = 0; i < tinySDF.size; i++) {\n      for (let j = 0; j < tinySDF.size; j++) {\n        // if this character is near the right edge, we don't actually copy the whole square of data\n        if (x + j < textureWidth) {\n          textureData[textureWidth * (y + i) + x + j] = data[i * tinySDF.size + j];\n        }\n      }\n    }\n  }\n\n  return {\n    textureData,\n    textureWidth,\n    textureHeight,\n    charInfo\n  };\n});\n\nconst vert$1 = `\n  precision mediump float;\n\n  uniform mat4 projection, view, billboardRotation;\n  uniform float fontSize;\n  uniform vec2 atlasSize;\n\n  // per-vertex attributes\n  attribute vec2 texCoord;\n  attribute vec2 position;\n\n  // per-instance (character) attributes\n  attribute vec2 srcOffset;\n  attribute float srcWidth;\n  attribute vec2 destOffset;\n\n  // per-marker attributes\n  attribute vec3 scale;\n  attribute float billboard;\n  attribute vec2 alignmentOffset;\n  attribute float enableBackground;\n  attribute float enableHighlight;\n  attribute vec4 foregroundColor;\n  attribute vec4 backgroundColor;\n  attribute vec4 highlightColor;\n  attribute vec3 posePosition;\n  attribute vec4 poseOrientation;\n\n  varying vec2 vTexCoord;\n  varying float vEnableBackground;\n  varying vec4 vForegroundColor;\n  varying vec4 vBackgroundColor;\n  varying vec4 vHighlightColor;\n  varying float vEnableHighlight;\n\n  // rotate a 3d point v by a rotation quaternion q\n  // like applyPose(), but we need to use a custom per-instance pose\n  vec3 rotate(vec3 v, vec4 q) {\n    vec3 temp = cross(q.xyz, v) + q.w * v;\n    return v + (2.0 * cross(q.xyz, temp));\n  }\n\n  void main () {\n    vec2 srcSize = vec2(srcWidth, fontSize);\n    vec3 markerSpacePos = scale * vec3((destOffset + position * srcSize + alignmentOffset) / fontSize, 0);\n    vec3 pos;\n    if (billboard == 1.0) {\n      pos = (billboardRotation * vec4(markerSpacePos, 1)).xyz + posePosition;\n    } else {\n      pos = rotate(markerSpacePos, poseOrientation) + posePosition;\n    }\n    gl_Position = projection * view * vec4(pos, 1);\n    vTexCoord = (srcOffset + texCoord * srcSize) / atlasSize;\n    vEnableBackground = enableBackground;\n    vForegroundColor = foregroundColor;\n    vBackgroundColor = backgroundColor;\n    vHighlightColor = highlightColor;\n    vEnableHighlight = enableHighlight;\n  }\n`;\nconst frag$1 = `\n  #extension GL_OES_standard_derivatives : enable\n  precision mediump float;\n  uniform mat4 projection;\n  uniform sampler2D atlas;\n  uniform float cutoff;\n\n  varying vec2 vTexCoord;\n  varying float vEnableBackground;\n  varying vec4 vForegroundColor;\n  varying vec4 vBackgroundColor;\n  varying vec4 vHighlightColor;\n  varying float vEnableHighlight;\n  void main() {\n    float dist = texture2D(atlas, vTexCoord).a;\n\n    // fwidth(dist) is used to provide some anti-aliasing. However it's currently only used\n    // when the solid background is enabled, because the alpha blending and\n    // depth test don't work together nicely for partially-transparent pixels.\n    float edgeStep = smoothstep(1.0 - cutoff - fwidth(dist), 1.0 - cutoff, dist);\n    if (vEnableHighlight > 0.5) {\n      gl_FragColor = mix(vHighlightColor, vec4(0, 0, 0, 1), edgeStep);\n    } else if (vEnableBackground > 0.5) {\n      float screenSize = fwidth(vTexCoord.x);\n      gl_FragColor = mix(vBackgroundColor, vForegroundColor, edgeStep);\n    } else {\n      gl_FragColor = vForegroundColor;\n      gl_FragColor.a *= step(1.0 - cutoff, dist);\n    }\n\n    if (gl_FragColor.a == 0.) {\n      discard;\n    }\n  }\n`;\n\nfunction makeTextCommand() {\n  // Keep the set of rendered characters around so we don't have to rebuild the font atlas too often.\n  const charSet = new Set();\n  const memoizedBuildAtlas = createMemoizedBuildAtlas();\n\n  const command = regl => {\n    const atlasTexture = regl.texture();\n    const drawText = regl({\n      depth: defaultDepth,\n      blend: defaultBlend,\n      primitive: \"triangle strip\",\n      vert: vert$1,\n      frag: frag$1,\n      uniforms: {\n        atlas: atlasTexture,\n        atlasSize: () => [atlasTexture.width, atlasTexture.height],\n        fontSize: FONT_SIZE,\n        cutoff: CUTOFF\n      },\n      instances: regl.prop(\"instances\"),\n      count: 4,\n      attributes: {\n        position: [[0, 0], [0, -1], [1, 0], [1, -1]],\n        texCoord: [[0, 0], [0, 1], [1, 0], [1, 1]],\n        // flipped\n        srcOffset: (ctx, props) => ({\n          buffer: props.srcOffsets,\n          divisor: 1\n        }),\n        destOffset: (ctx, props) => ({\n          buffer: props.destOffsets,\n          divisor: 1\n        }),\n        srcWidth: (ctx, props) => ({\n          buffer: props.srcWidths,\n          divisor: 1\n        }),\n        scale: (ctx, props) => ({\n          buffer: props.scale,\n          divisor: 1\n        }),\n        alignmentOffset: (ctx, props) => ({\n          buffer: props.alignmentOffset,\n          divisor: 1\n        }),\n        billboard: (ctx, props) => ({\n          buffer: props.billboard,\n          divisor: 1\n        }),\n        foregroundColor: (ctx, props) => ({\n          buffer: props.foregroundColor,\n          divisor: 1\n        }),\n        backgroundColor: (ctx, props) => ({\n          buffer: props.backgroundColor,\n          divisor: 1\n        }),\n        highlightColor: (ctx, props) => ({\n          buffer: props.highlightColor,\n          divisor: 1\n        }),\n        enableBackground: (ctx, props) => ({\n          buffer: props.enableBackground,\n          divisor: 1\n        }),\n        enableHighlight: (ctx, props) => ({\n          buffer: props.enableHighlight,\n          divisor: 1\n        }),\n        posePosition: (ctx, props) => ({\n          buffer: props.posePosition,\n          divisor: 1\n        }),\n        poseOrientation: (ctx, props) => ({\n          buffer: props.poseOrientation,\n          divisor: 1\n        })\n      }\n    });\n    return props => {\n      let estimatedInstances = 0;\n      const prevNumChars = charSet.size;\n\n      for (const _ref of props) {\n        const {\n          text\n        } = _ref;\n\n        if (typeof text !== \"string\") {\n          throw new Error(`Expected typeof 'text' to be a string. But got type '${typeof text}' instead.`);\n        }\n\n        for (const char of text) {\n          ++estimatedInstances;\n          charSet.add(char);\n        }\n      }\n\n      const charsChanged = charSet.size !== prevNumChars;\n      const {\n        textureData,\n        textureWidth,\n        textureHeight,\n        charInfo\n      } = memoizedBuildAtlas( // only use a new set if the characters changed, since memoizeOne uses shallow equality\n      charsChanged ? new Set(charSet) : charSet); // re-upload texture only if characters were added\n\n      if (charsChanged) {\n        atlasTexture({\n          data: textureData,\n          width: textureWidth,\n          height: textureHeight,\n          format: \"alpha\",\n          wrap: \"clamp\",\n          mag: \"linear\",\n          min: \"linear\"\n        });\n      }\n\n      const destOffsets = new Float32Array(estimatedInstances * 2);\n      const srcWidths = new Float32Array(estimatedInstances);\n      const srcOffsets = new Float32Array(estimatedInstances * 2); // These don't vary across characters within a marker, but the divisor can't be dynamic so we have to duplicate the data for each character.\n\n      const alignmentOffset = new Float32Array(estimatedInstances * 2);\n      const scale = new Float32Array(estimatedInstances * 3);\n      const foregroundColor = new Float32Array(estimatedInstances * 4);\n      const backgroundColor = new Float32Array(estimatedInstances * 4);\n      const highlightColor = new Float32Array(estimatedInstances * 4);\n      const enableBackground = new Float32Array(estimatedInstances);\n      const billboard = new Float32Array(estimatedInstances);\n      const posePosition = new Float32Array(estimatedInstances * 3);\n      const poseOrientation = new Float32Array(estimatedInstances * 4);\n      const enableHighlight = new Float32Array(estimatedInstances);\n      let totalInstances = 0;\n\n      for (const marker of props) {\n        var _marker$colors, _marker$colors2, _marker$colors3;\n\n        let totalWidth = 0;\n        let x = 0;\n        let y = 0;\n        let markerInstances = 0;\n        const fgColor = ((_marker$colors = marker.colors) === null || _marker$colors === void 0 ? void 0 : _marker$colors[0]) || marker.color || BG_COLOR_LIGHT$1;\n        const outline = ((_marker$colors2 = marker.colors) === null || _marker$colors2 === void 0 ? void 0 : _marker$colors2[1]) != null || command.autoBackgroundColor;\n        const bgColor = ((_marker$colors3 = marker.colors) === null || _marker$colors3 === void 0 ? void 0 : _marker$colors3[1]) || (command.autoBackgroundColor && isColorDark(fgColor) ? BG_COLOR_LIGHT$1 : BG_COLOR_DARK$1);\n        const hlColor = (marker === null || marker === void 0 ? void 0 : marker.highlightColor) || {\n          r: 1,\n          b: 0,\n          g: 1,\n          a: 1\n        };\n\n        for (let i = 0; i < marker.text.length; i++) {\n          var _marker$billboard;\n\n          const char = marker.text[i];\n\n          if (char === \"\\n\") {\n            x = 0;\n            y = FONT_SIZE;\n            continue;\n          }\n\n          const info = charInfo[char];\n          const index = totalInstances + markerInstances; // Calculate per-character attributes\n\n          destOffsets[2 * index + 0] = x;\n          destOffsets[2 * index + 1] = -y;\n          srcOffsets[2 * index + 0] = info.x + BUFFER;\n          srcOffsets[2 * index + 1] = info.y + BUFFER;\n          srcWidths[index] = info.width;\n          x += info.width;\n          totalWidth = Math.max(totalWidth, x); // Copy per-marker attributes. These are duplicated per character so that we can draw\n          // all characters from all markers in a single draw call.\n\n          billboard[index] = ((_marker$billboard = marker.billboard) !== null && _marker$billboard !== void 0 ? _marker$billboard : true) ? 1 : 0;\n          scale[3 * index + 0] = marker.scale.x;\n          scale[3 * index + 1] = marker.scale.y;\n          scale[3 * index + 2] = marker.scale.z;\n          posePosition[3 * index + 0] = marker.pose.position.x;\n          posePosition[3 * index + 1] = marker.pose.position.y;\n          posePosition[3 * index + 2] = marker.pose.position.z;\n          poseOrientation[4 * index + 0] = marker.pose.orientation.x;\n          poseOrientation[4 * index + 1] = marker.pose.orientation.y;\n          poseOrientation[4 * index + 2] = marker.pose.orientation.z;\n          poseOrientation[4 * index + 3] = marker.pose.orientation.w;\n          foregroundColor[4 * index + 0] = fgColor.r;\n          foregroundColor[4 * index + 1] = fgColor.g;\n          foregroundColor[4 * index + 2] = fgColor.b;\n          foregroundColor[4 * index + 3] = fgColor.a;\n          backgroundColor[4 * index + 0] = bgColor.r;\n          backgroundColor[4 * index + 1] = bgColor.g;\n          backgroundColor[4 * index + 2] = bgColor.b;\n          backgroundColor[4 * index + 3] = bgColor.a;\n          highlightColor[4 * index + 0] = hlColor.r;\n          highlightColor[4 * index + 1] = hlColor.g;\n          highlightColor[4 * index + 2] = hlColor.b;\n          highlightColor[4 * index + 3] = hlColor.a;\n          enableHighlight[index] = marker.highlightedIndices && marker.highlightedIndices.includes(i) ? 1 : 0;\n          enableBackground[index] = outline ? 1 : 0;\n          ++markerInstances;\n        }\n\n        const totalHeight = y + FONT_SIZE;\n\n        for (let i = 0; i < markerInstances; i++) {\n          alignmentOffset[2 * (totalInstances + i) + 0] = -totalWidth / 2;\n          alignmentOffset[2 * (totalInstances + i) + 1] = totalHeight / 2;\n        }\n\n        totalInstances += markerInstances;\n      }\n\n      drawText({\n        instances: totalInstances,\n        // per-character\n        srcOffsets,\n        destOffsets,\n        srcWidths,\n        // per-marker\n        alignmentOffset,\n        billboard,\n        enableBackground,\n        enableHighlight,\n        foregroundColor,\n        backgroundColor,\n        highlightColor,\n        poseOrientation,\n        posePosition,\n        scale\n      });\n    };\n  };\n\n  command.autoBackgroundColor = false;\n  return command;\n}\n\nfunction GLText(props) {\n  const [command] = useState(() => makeTextCommand()); // HACK: Worldview doesn't provide an easy way to pass a command-level prop into the regl commands,\n  // so just attach it to the command object for now.\n\n  command.autoBackgroundColor = props.autoBackgroundColor;\n  return React__default.createElement(Command, _extends({\n    reglCommand: command\n  }, props));\n}\n\nfunction glConstantToRegl(value) {\n  if (value === undefined) {\n    return undefined;\n  } // prettier-ignore\n\n\n  switch (value) {\n    // min/mag filters\n    case WebGLRenderingContext.NEAREST:\n      return \"nearest\";\n\n    case WebGLRenderingContext.LINEAR:\n      return \"linear\";\n\n    case WebGLRenderingContext.NEAREST_MIPMAP_NEAREST:\n      return \"nearest mipmap nearest\";\n\n    case WebGLRenderingContext.NEAREST_MIPMAP_LINEAR:\n      return \"nearest mipmap linear\";\n\n    case WebGLRenderingContext.LINEAR_MIPMAP_NEAREST:\n      return \"linear mipmap nearest\";\n\n    case WebGLRenderingContext.LINEAR_MIPMAP_LINEAR:\n      return \"linear mipmap linear\";\n    // texture wrapping modes\n\n    case WebGLRenderingContext.REPEAT:\n      return \"repeat\";\n\n    case WebGLRenderingContext.CLAMP_TO_EDGE:\n      return \"clamp\";\n\n    case WebGLRenderingContext.MIRRORED_REPEAT:\n      return \"mirror\";\n  }\n\n  throw new Error(`unhandled constant value ${JSON.stringify(value)}`);\n}\n\nconst drawModel = regl => {\n  const command = regl({\n    primitive: \"triangles\",\n    blend: defaultBlend,\n    uniforms: {\n      globalAlpha: regl.context(\"globalAlpha\"),\n      poseMatrix: regl.context(\"poseMatrix\"),\n      baseColorTexture: regl.prop(\"baseColorTexture\"),\n      baseColorFactor: regl.prop(\"baseColorFactor\"),\n      nodeMatrix: regl.prop(\"nodeMatrix\"),\n      \"light.direction\": [0, 0, -1],\n      \"light.ambientIntensity\": 0.5,\n      \"light.diffuseIntensity\": 0.5,\n      hitmapColor: regl.context(\"hitmapColor\"),\n      isHitmap: regl.context(\"isHitmap\")\n    },\n    attributes: {\n      position: regl.prop(\"positions\"),\n      normal: regl.prop(\"normals\"),\n      texCoord: regl.prop(\"texCoords\")\n    },\n    elements: regl.prop(\"indices\"),\n    vert: `\n  uniform mat4 projection, view;\n  uniform mat4 nodeMatrix;\n  uniform mat4 poseMatrix;\n  attribute vec3 position, normal;\n  varying vec3 vNormal;\n  attribute vec2 texCoord;\n  varying vec2 vTexCoord;\n\n  void main() {\n    // using the projection matrix for normals breaks lighting for orthographic mode\n    mat4 mv = view * poseMatrix * nodeMatrix;\n    vNormal = normalize((mv * vec4(normal, 0)).xyz);\n    vTexCoord = texCoord;\n    gl_Position = projection * mv * vec4(position, 1);\n  }\n  `,\n    frag: `\n  precision mediump float;\n  uniform bool isHitmap;\n  uniform vec4 hitmapColor;\n  uniform float globalAlpha;\n  uniform sampler2D baseColorTexture;\n  uniform vec4 baseColorFactor;\n  varying mediump vec2 vTexCoord;\n  varying mediump vec3 vNormal;\n\n  // Basic directional lighting from:\n  // http://ogldev.atspace.co.uk/www/tutorial18/tutorial18.html\n  struct DirectionalLight {\n    mediump vec3 direction;\n    lowp float ambientIntensity;\n    lowp float diffuseIntensity;\n  };\n  uniform DirectionalLight light;\n\n  void main() {\n    vec4 baseColor = texture2D(baseColorTexture, vTexCoord) * baseColorFactor;\n    float diffuse = light.diffuseIntensity * max(0.0, dot(vNormal, -light.direction));\n    gl_FragColor = isHitmap ? hitmapColor : vec4((light.ambientIntensity + diffuse) * baseColor.rgb, baseColor.a * globalAlpha);\n  }\n  `\n  }); // default values for when baseColorTexture is not specified\n\n  const singleTexCoord = regl.buffer([0, 0]);\n  const whiteTexture = regl.texture({\n    data: [255, 255, 255, 255],\n    width: 1,\n    height: 1\n  }); // build the draw calls needed to draw the model. This will happen whenever the model changes.\n\n  const getDrawCalls = memoizeWeak(model => {\n    // upload textures to the GPU\n    const {\n      accessors\n    } = model;\n    const textures = model.json.textures && model.json.textures.map(textureInfo => {\n      const sampler = model.json.samplers[textureInfo.sampler];\n      const bitmap = model.images && model.images[textureInfo.source];\n      const texture = regl.texture({\n        data: bitmap,\n        min: glConstantToRegl(sampler.minFilter),\n        mag: glConstantToRegl(sampler.magFilter),\n        wrapS: glConstantToRegl(sampler.wrapS),\n        wrapT: glConstantToRegl(sampler.wrapT)\n      });\n      return texture;\n    });\n\n    if (model.images) {\n      model.images.forEach(bitmap => bitmap.close());\n    }\n\n    const drawCalls = []; // helper to draw the primitives comprising a mesh\n\n    function drawMesh(mesh, nodeMatrix) {\n      for (const primitive of mesh.primitives) {\n        const material = model.json.materials[primitive.material];\n        const texInfo = material.pbrMetallicRoughness.baseColorTexture;\n\n        if (!accessors) {\n          throw new Error(\"Error decoding GLB model: Missing `accessors` in JSON data\");\n        }\n\n        drawCalls.push({\n          indices: accessors[primitive.indices],\n          positions: accessors[primitive.attributes.POSITION],\n          normals: accessors[primitive.attributes.NORMAL],\n          texCoords: texInfo ? accessors[primitive.attributes[`TEXCOORD_${texInfo.texCoord || 0}`]] : {\n            divisor: 1,\n            buffer: singleTexCoord\n          },\n          baseColorTexture: texInfo ? textures[texInfo.index] : whiteTexture,\n          baseColorFactor: material.pbrMetallicRoughness.baseColorFactor || [1, 1, 1, 1],\n          nodeMatrix\n        });\n      }\n    } // helper to draw all the meshes contained in a node and its child nodes\n\n\n    function drawNode(node, parentMatrix) {\n      const nodeMatrix = node.matrix ? mat4.clone(node.matrix) : mat4.fromRotationTranslationScale(mat4.create(), node.rotation || [0, 0, 0, 1], node.translation || [0, 0, 0], node.scale || [1, 1, 1]);\n      mat4.mul(nodeMatrix, parentMatrix, nodeMatrix);\n\n      if (node.mesh != null) {\n        drawMesh(model.json.meshes[node.mesh], nodeMatrix);\n      }\n\n      if (node.children) {\n        for (const childIdx of node.children) {\n          drawNode(model.json.nodes[childIdx], nodeMatrix);\n        }\n      }\n    } // finally, draw each of the main scene's nodes\n\n\n    for (const nodeIdx of model.json.scenes[model.json.scene].nodes) {\n      const rootTransform = mat4.create();\n      mat4.rotateX(rootTransform, rootTransform, Math.PI / 2);\n      mat4.rotateY(rootTransform, rootTransform, Math.PI / 2);\n      drawNode(model.json.nodes[nodeIdx], rootTransform);\n    }\n\n    return drawCalls;\n  }); // create a regl command to set the context for each draw call\n\n  const withContext = regl({\n    context: {\n      poseMatrix: (context, props) => mat4.fromRotationTranslationScale(mat4.create(), orientationToVec4(props.pose.orientation), pointToVec3(props.pose.position), props.scale ? pointToVec3(props.scale) : [1, 1, 1]),\n      globalAlpha: (context, props) => props.alpha == null ? 1 : props.alpha,\n      hitmapColor: (context, props) => props.color || [0, 0, 0, 1],\n      isHitmap: (context, props) => !!props.isHitmap\n    }\n  });\n  return (props, isHitmap) => {\n    const drawCalls = getDrawCalls(props.model);\n    withContext(isHitmap ? _objectSpread({}, props, {\n      isHitmap\n    }) : props, () => {\n      command(drawCalls);\n    });\n  };\n};\n\nfunction useAsyncValue(fn, deps) {\n  const [value, setValue] = useState();\n  useEffect(useCallback(() => {\n    let unloaded = false;\n    fn().then(result => {\n      if (!unloaded) {\n        setValue(result);\n      }\n    });\n    return () => {\n      unloaded = true;\n      setValue(undefined);\n    };\n  }, deps || [fn]), deps || [fn]);\n  return value;\n}\n\nfunction useModel(model) {\n  useDebugValue(model);\n  return useAsyncValue(async () => {\n    if (typeof model === \"function\") {\n      return model();\n    }\n\n    if (typeof model === \"string\") {\n      const response = await fetch(model);\n\n      if (!response.ok) {\n        throw new Error(`failed to fetch GLTF model: ${response.status}`);\n      }\n\n      return parseGLB((await response.arrayBuffer()));\n    }\n    /*:: (model: empty) */\n\n\n    throw new Error(`unsupported model prop: ${typeof model}`);\n  }, [model]);\n}\n\nfunction GLTFScene(props) {\n  const {\n    children,\n    model\n  } = props,\n        rest = _objectWithoutProperties(props, [\"children\", \"model\"]);\n\n  const context = useContext(WorldviewReactContext);\n  const loadedModel = useModel(model);\n  useEffect(() => {\n    if (context) {\n      context.onDirty();\n    }\n  }, [context, loadedModel]);\n\n  if (!loadedModel) {\n    return null;\n  }\n\n  return React__default.createElement(Command, _extends({}, rest, {\n    reglCommand: drawModel,\n    getChildrenForHitmap: getChildrenForHitmapWithOriginalMarker\n  }), _objectSpread({}, children, {\n    model: loadedModel,\n    originalMarker: children\n  }));\n}\n\nconst DEFAULT_GRID_COLOR = [0.3, 0.3, 0.3, 1];\n\nfunction grid() {\n  return withPose({\n    vert: `\n    precision mediump float;\n    uniform mat4 projection, view;\n\n    attribute vec3 point;\n    attribute vec4 color;\n    varying vec4 fragColor;\n\n    void main () {\n      fragColor = color;\n      vec3 p = point;\n      gl_Position = projection * view * vec4(p, 1);\n    }\n    `,\n    frag: `\n      precision mediump float;\n      varying vec4 fragColor;\n      void main () {\n        gl_FragColor = fragColor;\n      }\n    `,\n    primitive: \"lines\",\n    attributes: {\n      point: (context, props) => {\n        const points = [];\n        const bound = props.count;\n\n        for (let i = -props.count; i < props.count; i++) {\n          points.push([-bound, i, 0]);\n          points.push([bound, i, 0]);\n          points.push([i, -bound, 0]);\n          points.push([i, bound, 0]);\n        }\n\n        return points;\n      },\n      color: (context, props) => {\n        const color = props.color || DEFAULT_GRID_COLOR;\n        return new Array(props.count * 4 * 2).fill(color);\n      }\n    },\n    count: (context, props) => {\n      // 8 points per count\n      const count = props.count * 4 * 2;\n      return count;\n    }\n  });\n} // useful for rendering a grid for debugging in stories\n\n\nfunction Grid(_ref) {\n  let {\n    count\n  } = _ref,\n      rest = _objectWithoutProperties(_ref, [\"count\"]);\n\n  const children = {\n    count\n  };\n  return React__default.createElement(Command, _extends({\n    getChildrenForHitmap: nonInstancedGetChildrenForHitmap\n  }, rest, {\n    reglCommand: grid\n  }), children);\n}\n\nGrid.defaultProps = {\n  count: 6\n}; // A command that renders arbitrary DOM nodes on top of the Worldview 3D scene.\n// It supplies coordinates to the `renderItem` prop for positioning DOM nodes relative to the canvas.\n\nclass Overlay extends Component {\n  constructor(...args) {\n    super(...args);\n\n    _defineProperty(this, \"_context\", void 0);\n\n    _defineProperty(this, \"state\", {\n      items: []\n    });\n\n    _defineProperty(this, \"componentWillUnmount\", () => {\n      if (this._context) {\n        this._context.unregisterPaintCallback(this.paint);\n      }\n    });\n\n    _defineProperty(this, \"paint\", () => {\n      const context = this._context;\n      const dimension = context && context.dimension;\n      const {\n        renderItem,\n        children\n      } = this.props;\n\n      if (!context || !dimension) {\n        return;\n      }\n\n      const items = children.map((item, index) => {\n        const coordinates = this.project(item.pose.position, context);\n        return renderItem({\n          item,\n          index,\n          coordinates,\n          dimension\n        });\n      });\n      this.setState({\n        items\n      });\n    });\n\n    _defineProperty(this, \"project\", (point, context) => {\n      if (!context || !context.initializedData) {\n        return;\n      }\n\n      const {\n        dimension\n      } = context;\n      const {\n        camera\n      } = context.initializedData;\n      const vec = [point.x, point.y, point.z];\n      const {\n        left,\n        top,\n        width,\n        height\n      } = dimension;\n      const viewport = [left, top, width, height];\n      return camera.toScreenCoord(viewport, vec);\n    });\n  }\n\n  componentDidMount() {\n    if (this._context) {\n      this._context.registerPaintCallback(this.paint);\n    }\n  }\n\n  render() {\n    return createElement(Fragment, null, createElement(WorldviewReactContext.Consumer, null, ctx => {\n      if (ctx) {\n        this._context = ctx;\n      }\n\n      return this.state.items;\n    }));\n  }\n\n}\n\nconst points$3 = regl => {\n  const [min, max] = regl.limits.pointSizeDims;\n  return withPose({\n    primitive: \"points\",\n    vert: `\n    precision mediump float;\n\n    #WITH_POSE\n\n    uniform mat4 projection, view;\n    uniform float pointSize;\n\n    attribute vec3 point;\n    attribute vec4 color;\n    varying vec4 fragColor;\n    void main () {\n      gl_PointSize = pointSize;\n      vec3 pos = applyPose(point);\n      gl_Position = projection * view * vec4(pos, 1);\n      fragColor = color;\n    }\n    `,\n    frag: `\n    precision mediump float;\n    varying vec4 fragColor;\n    void main () {\n      gl_FragColor = vec4(fragColor.x, fragColor.y, fragColor.z, 1);\n    }\n    `,\n    attributes: {\n      point: (context, props) => {\n        return props.points.map(point => Array.isArray(point) ? point : pointToVec3(point));\n      },\n      color: (context, props) => {\n        const colors = getVertexColors(props);\n        return colors;\n      }\n    },\n    uniforms: {\n      pointSize: (context, props) => {\n        const size = props.scale.x || 1;\n        return Math.min(max, Math.max(min, size));\n      }\n    },\n    count: regl.prop(\"points.length\")\n  });\n};\n\nconst getChildrenForHitmap$5 = createInstancedGetChildrenForHitmap(1);\n\nfunction Points(props) {\n  return createElement(Command, _extends({\n    getChildrenForHitmap: getChildrenForHitmap$5\n  }, props, {\n    reglCommand: points$3\n  }));\n} //  Copyright (c) 2018-present, GM Cruise LLC\n//  Copyright (c) 2018-present, GM Cruise LLC\n//  Copyright (c) 2018-present, GM Cruise LLC\n\n\nexport default Worldview;\nexport { Worldview, Bounds, selectors as cameraStateSelectors, CameraStore, DEFAULT_CAMERA_STATE, eulerFromQuaternion, fromGeometry, parseGLB, WorldviewReactContext, pointToVec3, orientationToVec4, vec3ToPoint, vec4ToOrientation, pointToVec3Array, toRGBA, vec4ToRGBA, getCSSColor, defaultReglBlend, defaultReglDepth, defaultDepth, defaultBlend, blend, withPose, getVertexColors, colorBuffer, shouldConvert, intToRGB, getIdFromColor, getIdFromPixel, fromSpherical, Ray, getRayFromClick, Arrows$1 as Arrows, Axes, Command, SUPPORTED_MOUSE_EVENTS, Cones, Cubes, Cylinders, DrawPolygons, Polygon, PolygonPoint, PolygonBuilder, FilledPolygons, GLText, GLTFScene, Grid, Lines, Overlay, Points, Spheres, Text, Triangles, nonInstancedGetChildrenForHitmap, getChildrenForHitmapWithOriginalMarker, createInstancedGetChildrenForHitmap };","map":{"version":3,"sources":["../src/utils/getOrthographicBounds.js","../src/camera/cameraProject.js","../src/utils/commandUtils.js","../src/camera/cameraStateSelectors.js","../src/camera/CameraStore.js","../src/camera/camera.js","../src/camera/CameraListener.js","../src/camera/index.js","../src/utils/common.js","../src/utils/Raycast.js","../src/WorldviewReactContext.js","../src/commands/Command.js","../src/utils/aggregate.js","../src/utils/HitmapObjectIdManager.js","../src/utils/signal.js","../src/utils/queuePromise.js","../src/WorldviewContext.js","../src/Worldview.js","../src/utils/Bounds.js","../src/utils/eulerFromQuaternion.js","../src/utils/fromGeometry.js","../src/utils/parseGLB.js","../src/utils/getChildrenForHitmapDefaults.js","../src/commands/Cylinders.js","../src/commands/Cones.js","../src/commands/Arrows.js","../src/commands/Lines.js","../src/commands/Axes.js","../src/commands/Cubes.js","../src/commands/Spheres.js","../src/commands/DrawPolygon/index.js","../src/commands/DrawPolygon/PolygonBuilder.js","../src/commands/Triangles.js","../src/commands/FilledPolygons.js","../src/commands/Text.js","../src/commands/GLText.js","../src/commands/GLTFScene.js","../src/commands/Grid.js","../src/commands/Overlay.js","../src/commands/Points.js","../src/commands/index.js"],"names":["constructor","Math","aspect","width","distanceToGround","left","top","NEAR_RANGE","FAR_RANGE","tmp4","vX","viewport","vY","vWidth","vHeight","n","f","vec4","vec","w","out","rotateGLSL","DEFAULT_TEXT_COLOR","r","g","b","a","pointToVec3","z","orientationToVec4","vec3ToPoint","vec4ToOrientation","pointToVec3Array","points","result","i","toRGBA","val","vec4ToRGBA","color","toRGBAArray","colors","constantRGBAArray","count","defaultReglBlend","enable","func","src","dst","srcAlpha","dstAlpha","equation","rgb","alpha","defaultReglDepth","mask","defaultDepth","props","defaultBlend","blend","uniforms","newVert","vert","newUniforms","_position","position","Array","_rotation","orientation","shouldConvert","arr","buffer","usage","data","divisor","hasNestedArrays","isNaN","rSinPhi","UNIT_X_VECTOR","Object","TEMP_VEC3","TEMP_MAT","TEMP_QUAT","stateSelector","state","perspectiveSelector","createSelector","perspective","distanceSelector","distance","phiSelector","phi","thetaOffsetSelector","thetaOffset","targetOrientationSelector","targetOrientation","targetHeadingSelector","vec3","heading","orientationSelector","quat","positionSelector","fromSpherical","viewSelector","m","mat4","billboardRotation","targetHeading","view","UNIT_Z_VECTOR","DEFAULT_CAMERA_STATE","target","targetOffset","fovy","near","far","startingDistance","zoomPercent","handler","initialCameraState","x","y","offset","newDistance","distanceAfterZoom","regl","getProjection","bounds","getOrthographicBounds","getView","selectors","toScreenCoord","projection","combinedProjView","project","diffY","diffX","context","viewportHeight","PAN_SPEED","MOUSE_ZOOM_SPEED","KEYBOARD_MOVE_SPEED","KEYBOARD_ZOOM_SPEED","KEYBOARD_SPIN_SPEED","DEFAULT_KEYMAP","KeyA","KeyD","KeyE","KeyF","KeyQ","KeyR","KeyS","KeyW","KeyX","KeyZ","componentDidMount","_el","listen","fn","passive","componentWillUnmount","listener","mouse","clientY","height","clientX","e","_isLeftMouseDown","_isRightMouseDown","_getMagnitude","base","_getMoveMagnitude","cameraStore","document","moveX","moveY","magnitude","cameraRotate","cameraMove","startDragging","window","_endDragging","code","moveSpeed","zoomSpeed","spinSpeed","shiftKeys","action","keyMap","zoom","yaw","tilt","console","_moveKeyboard","motion","cameraZoom","_startKeyTimer","requestAnimationFrame","stamp","lastStamp","_stopKeyTimer","cancelAnimationFrame","pixelY","normalizeWheel","wheelAmount","dir","amount","percentage","zoomPercentage","render","children","outline","el","_onKeyUp","process","tempVec","tempMat","distanceToPoint","planeIntersection","d","cosine","contact","projectionMatrix","camera","viewMatrix","vp","invVp","mouseX","mouseY","rayPoint","rayOrigin","rayDir","React","SUPPORTED_MOUSE_EVENTS","Command","getNodeEnv","nextProps","componentDidUpdate","_updateContext","getChildrenForHitmap","instance","handleMouseEvent","mouseHandler","objects","ctx","aggregationMap","array","existingItems","start","ids","fillArray","last","id","intToRGB","objectHitmapId","object","instanceIndex","promise","resolve","reject","calling","nextCalls","returnPromise","signal","queuedFn","args","nextArgs","nextPromise","error","cmd","undefined","onCameraStateChange","cameraState","initialize","createREGL","extensions","profile","uncompiledCommand","compiledCommand","compile","Camera","compiledCameraCommand","fbo","_fbo","destroy","onMount","initializedData","onUnmount","unregisterPaintCallback","registerDrawCall","drawInput","registerPaintCallback","setDimension","getRayFromClick","paint","Date","paintCall","debounce","queuePromise","Promise","cachedReadHitmapCall","shallowequal","framebuffer","depth","currentObjectId","excludedObjects","mouseEventsWithCommands","counter","maxStackedObjectCount","pixel","getIdFromPixel","mouseEventObject","command","arguments","drawCalls","isHitmap","assignNextColorsFn","hitmapProps","_instrumentCommands","apply","DEFAULT_BACKGROUND_COLOR","DEFAULT_MOUSE_CLICK_RADIUS","DEFAULT_MAX_NUMBER_OF_HITMAP_LAYERS","WorldviewBase","backgroundColor","style","defaultCameraState","worldviewContext","dimension","canvasBackgroundColor","_dragStartPos","deltaX","deltaY","worldviewHandler","clientLeft","canvasX","canvasY","ray","mouseEventName","handleWorldviewMouseInteraction","mouseEventsByCommand","aggregate","mouseEvents","_renderDebug","mem","bottom","right","fontFamily","fontSize","reglCommandObjects","mapValues","total","pickBy","rows","key","React.createElement","border","paddingRight","isFixedCamera","canvasHtml","maxWidth","maxHeight","_onMouseMove","showDebug","overflow","Worldview","Number","update","point","scratch","mat3","m11","m12","m13","m22","m23","m32","m33","vertexArray","Float32Array","elements","face","elementsArray","Uint16Array","buff","colorBuff","colorBuffer","withPose","frag","attributes","scale","instances","value","magic","readUint32","version","totalLength","byteLength","chunkLength","chunkType","chunkData","jsonData","findNextChunkOfType","json","JSON","binary","accessors","accessorInfo","WebGLRenderingContext","arrayType","componentType","numComponents","type","bufferView","images","imgInfo","mimeType","useOriginalMarkerProp","eventCallbackMarker","prop","hitmapProp","assignNextColors","nonInstancedGetChildrenForHitmap","nonInstancedGetChildrenForHitmapFromSingleProp","getChildrenForHitmapWithOriginalMarker","matchedExcludedObjects","filteredIndices","instanceCount","idColors","startColor","allColors","j","idx","index","createInstancedGetChildrenForHitmap","pointCountPerInstance","instancedGetChildrenForHitmapFromSingleProp","northPole","southPole","sideFaces","endCapFaces","theta","bottomLeftPt","topRightPt","cone","bottomRightPt","topLeftPt","createCylinderGeometry","cylinders","fromGeometry","cones","passedProps","omit","marker","basePosition","tipPosition","end","length","headWidthX","headWidthY","headLength","shaftWidthX","shaftWidthY","shaftLength","shaftPosition","headPosition","originalMarker","pose","memo","FLOAT_BYTES","POINT_BYTES","DEFAULT_MONOCHROME_COLOR","POINT_TYPES","BL","TR","BR","TL","VERTICES_PER_INSTANCE","k","ax","ay","az","lines","pointTypeBuffer","debugColorBuffer","defaultPosePositionBuffer","flatten","defaultPoseRotationBuffer","positionBuffer1","positionBuffer2","posePositionBuffer","poseRotationBuffer","thickness","viewportWidth","joined","scaleInvariant","pointType","colorB","debug","stride","monochrome","colorC","positionA","positionB","positionC","positionD","posePosition","hasInstancedPoses","poseRotation","primitive","colorArray","pointArray","allocatedPoints","positionArray","rotationArray","numTotalPoints","shouldClose","off","poses","positionOffset","rotationOffset","convertedPosition","convertedRotation","monochromeColor","convertColors","convertedColors","lastIndex","commands","numInputPoints","alreadyClosed","pointsEqual","fillPointArray","fillColorArray","effectiveNumPoints","fillPoseArrays","inProps","renderLine","p","xAxisPoints","yAxisPoints","zAxisPoints","xAxis","yAxis","zAxis","Axes","cubes","NUM_PARALLELS","NUM_MERIDIANS","RADIUS","faces","prevMeridianPt","pt","prevPt","spheres","factor","DEFAULT_COLOR","ACTIVE_POLYGON_COLOR","ACTIVE_POINT_COLOR","LINE_STRIP","POINT_SIZE_FACTOR","DRAW_SCALE","DRAW_POINT_SCALE","multiplyScale","HITMAP_SCALE","HITMAP_POINT_SCALE","POSE","name","polygonLinesGetChildrenForHitmap","polygons","poly","polygonPointsGetChildrenForHitmap","originalMarkers","convertedPoint","sphereList","point1","point2","x1","y1","z1","areEqual","firstPoint","lastPoint","isActivePolygonClosed","isClosed","addPolygon","polygon","pushPoint","activePolygon","newPoint","floatingPoint","updateActivePoint","closeActivePolygon","dX","pointX","dY","pointY","uniquePoints","acc","deletePolygon","deletePoint","newPoints","selectObject","isActive","shortestDistance","shortestIndex","dist","isFirstClick","isCtrlClick","clickObject","defaultSingleColorDepth","defaultVetexColorDepth","singleColor","getVertexColors","vertexColors","triangles","single","vertex","items","singleColorItems","vertexColorItems","item","NO_POSE","DEFAULT_SCALE","flattenedPoints","flatten3D","indices","earcut","originalIndex","rest","earcutPoints","getEarcutPoints","BG_COLOR_LIGHT","BG_COLOR_DARK","BRIGHTNESS_THRESHOLD","DEFAULT_BG_COLOR","cssHasBeenInserted","luma","insertGlobalCss","getCSSColor","hasBgColor","textColor","isColorEqual","autoBackgroundColor","isTextColorDark","isColorDark","hexBgColor","Text","textComponents","current","textContainer","componentsToRemove","coord","_textContainerRef","FONT_SIZE","MAX_ATLAS_WIDTH","SDF_RADIUS","CUTOFF","BUFFER","memoizedCreateCanvas","memoizeOne","font","canvas","createMemoizedBuildAtlas","charSet","tinySDF","textureWidth","rowHeight","charInfo","dx","textureHeight","textureData","memoizedBuildAtlas","atlasTexture","drawText","atlas","atlasSize","cutoff","texCoord","srcOffset","destOffset","srcWidth","alignmentOffset","billboard","foregroundColor","highlightColor","enableBackground","enableHighlight","poseOrientation","estimatedInstances","prevNumChars","text","charsChanged","format","wrap","mag","min","destOffsets","srcWidths","srcOffsets","totalInstances","totalWidth","markerInstances","fgColor","bgColor","hlColor","char","info","totalHeight","useState","makeTextCommand","drawModel","globalAlpha","poseMatrix","baseColorTexture","baseColorFactor","nodeMatrix","hitmapColor","normal","singleTexCoord","whiteTexture","getDrawCalls","memoizeWeak","model","textures","textureInfo","sampler","bitmap","texture","glConstantToRegl","wrapS","wrapT","mesh","material","texInfo","positions","normals","texCoords","node","drawMesh","drawNode","rootTransform","withContext","useEffect","useCallback","unloaded","setValue","deps","useDebugValue","useAsyncValue","response","fetch","status","parseGLB","useContext","loadedModel","useModel","DEFAULT_GRID_COLOR","bound","grid","Grid","coordinates","renderItem","pointSize","size"],"mappings":"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","sourcesContent":["// @flow\n\n//  Copyright (c) 2018-present, GM Cruise LLC\n//\n//  This source code is licensed under the Apache License, Version 2.0,\n//  found in the LICENSE file in the root directory of this source tree.\n//  You may not use this file except in compliance with the License.\n\nclass BoundingBox {\n  left: number;\n  right: number;\n  top: number;\n  bottom: number;\n  width: number;\n  height: number;\n\n  constructor(left: number, top: number) {\n    this.left = left;\n    this.top = top;\n    this.right = -left;\n    this.bottom = -top;\n    this.width = Math.abs(left) * 2;\n    this.height = Math.abs(top) * 2;\n  }\n}\n\nexport default function getOrthographicBounds(zDistance: number, width: number, height: number): BoundingBox {\n  const aspect = width / height;\n  // never go below ground level\n  const distanceToGround = Math.abs(zDistance);\n  const left = (-distanceToGround / 2) * aspect;\n  const top = distanceToGround / 2;\n  return new BoundingBox(left, top);\n}\n","// @flow\n\n//  Copyright (c) 2018-present, GM Cruise LLC\n//\n//  This source code is licensed under the Apache License, Version 2.0,\n//  found in the LICENSE file in the root directory of this source tree.\n//  You may not use this file except in compliance with the License.\n\n// Copied from Jam3/camera-project\n// in order to replace gl-vec4 dependency with gl-matrix\n\nimport { vec4 } from \"gl-matrix\";\n\nimport type { Vec3, Vec4, Mat4 } from \"../types\";\n\nconst NEAR_RANGE = 0;\nconst FAR_RANGE = 1;\nconst tmp4 = [0, 0, 0, 0];\n\nexport default function cameraProject(out: any, vec: Vec3, viewport: Vec4, combinedProjView: Mat4): Vec4 {\n  const vX = viewport[0],\n    vY = viewport[1],\n    vWidth = viewport[2],\n    vHeight = viewport[3],\n    n = NEAR_RANGE,\n    f = FAR_RANGE;\n\n  // convert: clip space -> NDC -> window coords\n  // implicit 1.0 for w component\n  vec4.set(tmp4, vec[0], vec[1], vec[2], 1.0);\n\n  // transform into clip space\n  vec4.transformMat4(tmp4, tmp4, combinedProjView);\n\n  // now transform into NDC\n  const w = tmp4[3];\n  if (w !== 0) {\n    // how to handle infinity here?\n    tmp4[0] = tmp4[0] / w;\n    tmp4[1] = tmp4[1] / w;\n    tmp4[2] = tmp4[2] / w;\n  }\n\n  // and finally into window coordinates\n  // the foruth component is (1/clip.w)\n  // which is the same as gl_FragCoord.w\n  out[0] = vX + (vWidth / 2) * tmp4[0] + (0 + vWidth / 2);\n  out[1] = vY + (vHeight / 2) * tmp4[1] + (0 + vHeight / 2);\n  out[2] = ((f - n) / 2) * tmp4[2] + (f + n) / 2;\n  out[3] = w === 0 ? 0 : 1 / w;\n  return out;\n}\n","// @flow\n\n//  Copyright (c) 2018-present, GM Cruise LLC\n//\n//  This source code is licensed under the Apache License, Version 2.0,\n//  found in the LICENSE file in the root directory of this source tree.\n//  You may not use this file except in compliance with the License.\n\nimport type { Color, Point, Orientation, ReglCommand, Vec4, Vec3 } from \"../types\";\n\nconst rotateGLSL = `\n  uniform vec3 _position;\n  uniform vec4 _rotation;\n\n  // rotate a 3d point v by a rotation quaternion q\n  vec3 rotate(vec3 v, vec4 q) {\n    vec3 temp = cross(q.xyz, v) + q.w * v;\n    return v + (2.0 * cross(q.xyz, temp));\n  }\n\n  vec3 applyPose(vec3 point) {\n    // rotate the point and then add the position of the pose\n    return rotate(point, _rotation) + _position;\n  }\n`;\n\nconst DEFAULT_TEXT_COLOR = { r: 1, g: 1, b: 1, a: 1 };\n\nexport const pointToVec3 = ({ x, y, z }: Point): Vec3 => {\n  return [x, y, z];\n};\nexport const orientationToVec4 = ({ x, y, z, w }: Orientation): Vec4 => {\n  return [x, y, z, w];\n};\n\nexport const vec3ToPoint = ([x, y, z]: Vec3): Point => ({ x, y, z });\n\nexport const vec4ToOrientation = ([x, y, z, w]: Vec4): Orientation => ({ x, y, z, w });\n\nexport const pointToVec3Array = (points: Point[]) => {\n  const result = new Float32Array(points.length * 3);\n  let i = 0;\n  for (const { x, y, z } of points) {\n    result[i++] = x;\n    result[i++] = y;\n    result[i++] = z;\n  }\n  return result;\n};\n\nexport const toRGBA = (val: Color) => {\n  return [val.r, val.g, val.b, val.a];\n};\n\nexport const vec4ToRGBA = (color: Vec4): Color => ({ r: color[0], g: color[1], b: color[2], a: color[3] });\n\nexport function getCSSColor(color: Color = DEFAULT_TEXT_COLOR) {\n  const { r, g, b, a } = color;\n  return `rgba(${(r * 255).toFixed()}, ${(g * 255).toFixed()}, ${(b * 255).toFixed()}, ${a.toFixed(3)})`;\n}\n\nconst toRGBAArray = (colors: $ReadOnlyArray<Color>): Float32Array => {\n  const result = new Float32Array(colors.length * 4);\n  let i = 0;\n  for (const { r, g, b, a } of colors) {\n    result[i++] = r;\n    result[i++] = g;\n    result[i++] = b;\n    result[i++] = a;\n  }\n  return result;\n};\n\nconst constantRGBAArray = (count: number, { r, g, b, a }: Color): Float32Array => {\n  const result = new Float32Array(count * 4);\n  for (let i = 0; i < count; i++) {\n    result[4 * i + 0] = r;\n    result[4 * i + 1] = g;\n    result[4 * i + 2] = b;\n    result[4 * i + 3] = a;\n  }\n  return result;\n};\n\n// default blend func params to be mixed into regl commands\nexport const defaultReglBlend = {\n  enable: true,\n  // this is the same gl.BlendFunc used by three.js by default\n  func: {\n    src: \"src alpha\",\n    dst: \"one minus src alpha\",\n    srcAlpha: 1,\n    dstAlpha: \"one minus src alpha\",\n  },\n  equation: {\n    rgb: \"add\",\n    alpha: \"add\",\n  },\n};\n\nexport const defaultReglDepth = {\n  enable: true,\n  mask: true,\n};\n\nexport const defaultDepth = {\n  enable: (context: any, props: any) => (props.depth && props.depth.enable) || defaultReglDepth.enable,\n  mask: (context: any, props: any) => (props.depth && props.depth.mask) || defaultReglDepth.mask,\n};\n\nexport const defaultBlend = {\n  ...defaultReglBlend,\n  enable: (context: any, props: any) => (props.blend && props.blend.enable) || defaultReglBlend.enable,\n  func: (context: any, props: any) => (props.blend && props.blend.func) || defaultReglBlend.func,\n};\n\n// TODO: deprecating, remove before 1.x release\nexport const blend = defaultBlend;\n\n// takes a regl command definition object and injects\n// position and rotation from the object pose and also\n// inserts some glsl helpers to apply the pose to points in a fragment shader\nexport function withPose(command: ReglCommand): ReglCommand {\n  const { vert, uniforms } = command;\n  const newVert = vert.replace(\"#WITH_POSE\", rotateGLSL);\n  const newUniforms = {\n    ...uniforms,\n    _position: (context, props) => {\n      const { position } = props.pose;\n      return Array.isArray(position) ? position : pointToVec3(position);\n    },\n    _rotation: (context, props) => {\n      const { orientation: r } = props.pose;\n      return Array.isArray(r) ? r : [r.x, r.y, r.z, r.w];\n    },\n  };\n  return {\n    ...command,\n    vert: newVert,\n    uniforms: newUniforms,\n  };\n}\n\nexport function getVertexColors({\n  colors,\n  color,\n  points,\n}: {\n  colors?: $ReadOnlyArray<Color> | $ReadOnlyArray<Vec4>,\n  color: Color,\n  points: $ReadOnlyArray<Point>,\n}): Float32Array | $ReadOnlyArray<Vec4> {\n  if ((!colors || !colors.length) && color) {\n    return constantRGBAArray(points.length, color);\n  }\n  if (colors) {\n    // $FlowFixMe this will go away once we consolidate getVertexColors and colorBuffer\n    return shouldConvert(colors) ? toRGBAArray(colors) : colors;\n  }\n  return [];\n}\n\nfunction hasNestedArrays(arr: any[]) {\n  return arr.length && Array.isArray(arr[0]);\n}\n\n// Returns a function which accepts a single color, an array of colors, and the number of instances,\n// and returns a color attribute buffer for use in regl.\n// If there are multiple colors in the colors array, one color will be assigned to each instance.\n// In the case of a single color, the same color will be used for all instances.\nexport function colorBuffer(regl: any) {\n  const buffer = regl.buffer({\n    usage: \"dynamic\",\n    data: [],\n  });\n\n  return function(color: any, colors: any, length: number) {\n    let data, divisor;\n    if (!colors || !colors.length) {\n      data = shouldConvert(color) ? toRGBA(color) : color;\n      divisor = length;\n    } else {\n      data = shouldConvert(colors) ? toRGBAArray(colors) : colors;\n      divisor = 1;\n    }\n    return {\n      buffer: buffer({\n        usage: \"dynamic\",\n        data,\n      }),\n      divisor,\n    };\n  };\n}\n\n// used to determine if the input/array of inputs is an object like {r: 0, g: 0, b: 0} or [0,0,0]\nexport function shouldConvert(props: any) {\n  if (!props || hasNestedArrays(props) || !isNaN(props[0])) {\n    return false;\n  }\n  return true;\n}\n\nexport function intToRGB(i: number = 0): Vec4 {\n  const r = ((i >> 16) & 255) / 255;\n  const g = ((i >> 8) & 255) / 255;\n  const b = (i & 255) / 255;\n  return [r, g, b, 1];\n}\n\nexport function getIdFromColor(rgb: Vec4): number {\n  const r = rgb[0] * 255;\n  const g = rgb[1] * 255;\n  const b = rgb[2] * 255;\n  return b | (g << 8) | (r << 16);\n}\n\nexport function getIdFromPixel(rgb: Uint8Array): number {\n  const r = rgb[0];\n  const g = rgb[1];\n  const b = rgb[2];\n  return b | (g << 8) | (r << 16);\n}\n\n// gl-matrix clone of three.js Vector3.setFromSpherical\n// phi: polar angle (between poles, 0 - pi)\n// theta: azimuthal angle (around equator, 0 - 2pi)\nexport function fromSpherical(out: number[], r: number, theta: number, phi: number): Vec3 {\n  const rSinPhi = r * Math.sin(phi);\n  out[0] = rSinPhi * Math.sin(theta);\n  out[1] = r * Math.cos(phi);\n  out[2] = rSinPhi * Math.cos(theta);\n  return (out: any);\n}\n","// @flow\n\n//  Copyright (c) 2018-present, GM Cruise LLC\n//\n//  This source code is licensed under the Apache License, Version 2.0,\n//  found in the LICENSE file in the root directory of this source tree.\n//  You may not use this file except in compliance with the License.\n\nimport { vec3, quat, mat4 } from \"gl-matrix\";\nimport { createSelector } from \"reselect\";\n\nimport type { CameraState, Vec4, Vec3, Mat4 } from \"../types\";\nimport { fromSpherical } from \"../utils/commandUtils\";\n\nconst UNIT_X_VECTOR = Object.freeze([1, 0, 0]);\n\n// reusable arrays for intermediate calculations\nconst TEMP_VEC3 = [0, 0, 0];\nconst TEMP_MAT = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\nconst TEMP_QUAT = [0, 0, 0, 0];\n\nconst stateSelector = (state: CameraState) => state;\n\nconst perspectiveSelector = createSelector(\n  stateSelector,\n  ({ perspective }) => perspective\n);\nconst distanceSelector = createSelector(\n  stateSelector,\n  ({ distance }) => distance\n);\nconst phiSelector = createSelector(\n  stateSelector,\n  ({ phi }) => phi\n);\nconst thetaOffsetSelector = createSelector(\n  stateSelector,\n  ({ thetaOffset }) => thetaOffset\n);\nconst targetOrientationSelector = createSelector(\n  stateSelector,\n  ({ targetOrientation }) => targetOrientation\n);\n\n// the heading direction of the target\nconst targetHeadingSelector: (CameraState) => number = createSelector(\n  targetOrientationSelector,\n  (targetOrientation) => {\n    const out = vec3.transformQuat(TEMP_VEC3, UNIT_X_VECTOR, targetOrientation);\n    const heading = -Math.atan2(out[1], out[0]);\n    return heading;\n  }\n);\n\n// orientation of the camera\nconst orientationSelector: (CameraState) => Vec4 = createSelector(\n  perspectiveSelector,\n  phiSelector,\n  thetaOffsetSelector,\n  (perspective, phi, thetaOffset) => {\n    const result = quat.identity([0, 0, 0, 0]);\n    quat.rotateZ(result, result, -thetaOffset);\n\n    // phi is ignored in 2D mode\n    if (perspective) {\n      quat.rotateX(result, result, phi);\n    }\n    return result;\n  }\n);\n\n// position of the camera\nconst positionSelector: (CameraState) => Vec3 = createSelector(\n  thetaOffsetSelector,\n  phiSelector,\n  distanceSelector,\n  (thetaOffset, phi, distance) => {\n    const position = fromSpherical([], distance, thetaOffset, phi);\n\n    // poles are on the y-axis in spherical coordinates; rearrange so they are on the z axis\n    const [x, y, z] = position;\n    position[0] = -x;\n    position[1] = -z;\n    position[2] = y;\n\n    return position;\n  }\n);\n\n/*\nGet the view matrix, which transforms points from world coordinates to camera coordinates.\n\nAn equivalent and easier way to think about this transformation is that it takes the camera from\nits actual position/orientation in the world, and moves it to have position=0,0,0 and orientation=0,0,0,1.\n\nWe build up this transformation in 5 steps as demonstrated below:\n   T = target\n   < = direction of target\n   * = target with offset (position that the camera is looking at)\n   C = camera (always points toward *)\n\nStarting point: actual positions in world coordinates\n\n  |      *\n  |  <T   C\n  |\n  +--------\n\nStep 1: translate target to the origin\n\n  |\n  |  *\n <T---C----\n\nStep 2: rotate around the origin so the target points forward\n(Here we use the target's heading only, ignoring other components of its rotation)\n\n  |\n  ^\n  T--------\n  |\n  | *\n  C\n\nStep 3: translate the target-with-offset point to be at the origin\n\n ^\n T|\n  |\n  *--------\n C|\n  |\n\n\nStep 4: translate the camera to be at the origin\n(Steps 3 and 4 are both translations, but they're kept separate because it's easier\nto conceptualize: 3 uses the targetOffset and 4 uses the distance+thetaOffset+phi.)\n\n ^\n T\n |\n |*\n C--------\n |\n\nStep 5: rotate the camera to point forward\n\n \\\n  T  |\n     *\n     C--------\n     |\n\n*/\nconst viewSelector: (CameraState) => Mat4 = createSelector(\n  stateSelector,\n  orientationSelector,\n  positionSelector,\n  targetHeadingSelector,\n  ({ target, targetOffset, perspective }, orientation, position, targetHeading) => {\n    const m = mat4.identity([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);\n\n    // apply the steps described above in reverse because we use right-multiplication\n\n    // 5. rotate camera to point forward\n    mat4.multiply(m, m, mat4.fromQuat(TEMP_MAT, quat.invert(TEMP_QUAT, orientation)));\n\n    // 4. move camera to the origin\n    if (perspective) {\n      mat4.translate(m, m, vec3.negate(TEMP_VEC3, position));\n    }\n\n    // 3. move center to the origin\n    mat4.translate(m, m, vec3.negate(TEMP_VEC3, targetOffset));\n\n    // 2. rotate target to point forward\n    mat4.rotateZ(m, m, targetHeading);\n\n    // 1. move target to the origin\n    vec3.negate(TEMP_VEC3, target);\n    if (!perspective) {\n      // if using orthographic camera ensure the distance from \"ground\"\n      // stays large so no reasonably tall item goes past the camera\n      TEMP_VEC3[2] = -2500;\n    }\n    mat4.translate(m, m, TEMP_VEC3);\n\n    return m;\n  }\n);\n\nconst billboardRotation: (CameraState) => Mat4 = createSelector(\n  orientationSelector,\n  targetHeadingSelector,\n  (orientation, targetHeading) => {\n    const m = mat4.identity(mat4.create());\n    mat4.rotateZ(m, m, -targetHeading);\n    mat4.multiply(m, m, mat4.fromQuat(TEMP_MAT, orientation));\n    return m;\n  }\n);\n\nexport default {\n  orientation: orientationSelector,\n  position: positionSelector,\n  targetHeading: targetHeadingSelector,\n  view: viewSelector,\n  billboardRotation,\n};\n","// @flow\n\n//  Copyright (c) 2018-present, GM Cruise LLC\n//\n//  This source code is licensed under the Apache License, Version 2.0,\n//  found in the LICENSE file in the root directory of this source tree.\n//  You may not use this file except in compliance with the License.\n\nimport { vec3, quat } from \"gl-matrix\";\n\nimport type { Vec2, Vec3, Vec4 } from \"../types\";\nimport selectors from \"./cameraStateSelectors\";\n\nexport type CameraState = {|\n  distance: number,\n  perspective: boolean,\n  phi: number,\n  target: Vec3,\n  targetOffset: Vec3,\n  targetOrientation: Vec4,\n  thetaOffset: number,\n  fovy: number,\n  near: number,\n  far: number,\n|};\n\n//  we use up on the +z axis\nconst UNIT_Z_VECTOR = Object.freeze([0, 0, 1]);\n// reusable array for intermediate calculations\nconst TEMP_QUAT = [0, 0, 0, 0];\n\nexport const DEFAULT_CAMERA_STATE: CameraState = {\n  distance: 75,\n  perspective: true,\n  phi: Math.PI / 4,\n  target: [0, 0, 0],\n  targetOffset: [0, 0, 0],\n  targetOrientation: [0, 0, 0, 1],\n  thetaOffset: 0,\n  fovy: Math.PI / 4,\n  near: 0.01,\n  far: 5000,\n};\n\nfunction distanceAfterZoom(startingDistance: number, zoomPercent: number): number {\n  // keep distance above 0 so that percentage-based zoom always works\n  return Math.max(0.001, startingDistance * (1 - zoomPercent / 100));\n}\n\nexport default class CameraStore {\n  state: CameraState;\n\n  _onChange: (CameraState) => void;\n\n  constructor(\n    handler: (CameraState) => void = () => {},\n    initialCameraState: $Shape<CameraState> = DEFAULT_CAMERA_STATE\n  ) {\n    this._onChange = handler;\n    this.setCameraState(initialCameraState);\n  }\n\n  setCameraState = (state: $Shape<CameraState>) => {\n    // Fill in missing properties from DEFAULT_CAMERA_STATE.\n    // Mutate the `state` parameter instead of copying -- this\n    // matches the previous behavior of this method, which didn't\n    // fill in missing properties but also didn't copy `state`.\n    for (const [key, value] of Object.entries(DEFAULT_CAMERA_STATE)) {\n      if (state[key] == null) {\n        state[key] = value;\n      }\n    }\n    // `state` must be a valid CameraState now, because we filled in\n    // missing properties from DEFAULT_CAMERA_STATE.\n    this.state = (state: any);\n  };\n\n  cameraRotate = ([x, y]: Vec2) => {\n    // This can happen in 2D mode, when both e.movementX and e.movementY are evaluated as negative and mouseX move is 0\n    if (x === 0 && y === 0) {\n      return;\n    }\n    const { thetaOffset, phi } = this.state;\n    this.setCameraState({\n      ...this.state,\n      thetaOffset: thetaOffset - x,\n      phi: Math.max(0, Math.min(phi + y, Math.PI)),\n    });\n    this._onChange(this.state);\n  };\n\n  // move the camera along x, y axis; do not move up/down\n  cameraMove = ([x, y]: Vec2) => {\n    // moveX and moveY both be 0 sometimes\n    if (x === 0 && y === 0) {\n      return;\n    }\n\n    const { targetOffset, thetaOffset } = this.state;\n\n    // rotate around z axis so the offset is in the target's reference frame\n    const result = [x, y, 0];\n    const offset = vec3.transformQuat(result, result, quat.setAxisAngle(TEMP_QUAT, UNIT_Z_VECTOR, -thetaOffset));\n\n    this.setCameraState({\n      ...this.state,\n      targetOffset: vec3.add(offset, targetOffset, offset),\n    });\n    this._onChange(this.state);\n  };\n\n  cameraZoom = (zoomPercent: number) => {\n    const { distance } = this.state;\n    const newDistance: number = distanceAfterZoom(distance, zoomPercent);\n    if (distance === newDistance) {\n      return;\n    }\n\n    this.setCameraState({\n      ...this.state,\n      distance: newDistance,\n    });\n    this._onChange(this.state);\n  };\n}\n\nexport { selectors };\n","// @flow\n\n//  Copyright (c) 2018-present, GM Cruise LLC\n//\n//  This source code is licensed under the Apache License, Version 2.0,\n//  found in the LICENSE file in the root directory of this source tree.\n//  You may not use this file except in compliance with the License.\n\nimport { mat4 } from \"gl-matrix\";\n\nimport type { Vec3, Mat4, CameraCommand, Viewport } from \"../types\";\nimport getOrthographicBounds from \"../utils/getOrthographicBounds\";\nimport project from \"./cameraProject\";\nimport { selectors, DEFAULT_CAMERA_STATE, type CameraState } from \"./CameraStore\";\n\nconst TEMP_MAT = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n\n// This is the regl command which encapsulates the camera projection and view matrices.\n// It adds the matrices to the regl context so they can be used by other commands.\nexport default (regl: any) => {\n  return class Camera implements CameraCommand {\n    viewportWidth: number = 0;\n    viewportHeight: number = 0;\n    cameraState: CameraState = DEFAULT_CAMERA_STATE;\n\n    getProjection(): Mat4 {\n      const { near, far, distance, fovy } = this.cameraState;\n      if (!this.cameraState.perspective) {\n        const bounds = getOrthographicBounds(distance, this.viewportWidth, this.viewportHeight);\n        const { left, right, bottom, top } = bounds;\n        return mat4.ortho([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], left, right, bottom, top, near, far);\n      }\n      const aspect = this.viewportWidth / this.viewportHeight;\n      return mat4.perspective([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], fovy, aspect, near, far);\n    }\n\n    getView(): Mat4 {\n      return selectors.view(this.cameraState);\n    }\n\n    // convert a point in 3D space to a point on the screen\n    toScreenCoord(viewport: Viewport, point: Vec3) {\n      const projection = this.getProjection();\n      const view = selectors.view(this.cameraState);\n      const combinedProjView = mat4.multiply(TEMP_MAT, projection, view);\n      const [x, y, z, w] = project([], point, viewport, combinedProjView);\n      if (z < 0 || z > 1 || w < 0) {\n        // resulting point is outside the window depth range\n        return undefined;\n      }\n      const diffY = viewport[3] + viewport[1];\n      const diffX = viewport[0];\n      // move the x value over based on the left of the viewport\n      // and move the y value over based on the bottom of the viewport\n      return [x - diffX, diffY - y, z];\n    }\n\n    draw = regl({\n      // adds context variables to the regl context so they are accessible from commands\n      context: {\n        // use functions, not lambdas here to make sure we can access\n        // the regl supplied this scope: http://regl.party/api#this\n        projection(context, props) {\n          const { viewportWidth, viewportHeight } = context;\n          // save these variables on the camera instance\n          // because we need them for raycasting\n          this.viewportWidth = viewportWidth;\n          this.viewportHeight = viewportHeight;\n          this.cameraState = props;\n          return this.getProjection();\n        },\n\n        view(context, props) {\n          return this.getView();\n        },\n\n        // inverse of the view rotation, used for making objects always face the camera\n        billboardRotation(context, props) {\n          return selectors.billboardRotation(this.cameraState);\n        },\n      },\n\n      // adds view and projection as uniforms to every command\n      // and makes them available in the shaders\n      uniforms: {\n        view: regl.context(\"view\"),\n        billboardRotation: regl.context(\"billboardRotation\"),\n        projection: regl.context(\"projection\"),\n      },\n    });\n  };\n};\n","// @flow\n\n//  Copyright (c) 2018-present, GM Cruise LLC\n//\n//  This source code is licensed under the Apache License, Version 2.0,\n//  found in the LICENSE file in the root directory of this source tree.\n//  You may not use this file except in compliance with the License.\n\nimport normalizeWheel from \"normalize-wheel\";\nimport * as React from \"react\";\n\nimport type { CameraKeyMap, CameraAction, Vec2 } from \"../types\";\nimport getOrthographicBounds from \"../utils/getOrthographicBounds\";\nimport CameraStore from \"./CameraStore\";\n\nconst PAN_SPEED = 4;\nconst MOUSE_ZOOM_SPEED = 0.3;\nconst KEYBOARD_MOVE_SPEED = 0.3;\nconst KEYBOARD_ZOOM_SPEED = 150;\nconst KEYBOARD_SPIN_SPEED = 1.5;\n\nconst DEFAULT_KEYMAP: CameraKeyMap = {\n  KeyA: \"moveLeft\",\n  KeyD: \"moveRight\",\n  KeyE: \"rotateRight\",\n  KeyF: \"tiltUp\",\n  KeyQ: \"rotateLeft\",\n  KeyR: \"tiltDown\",\n  KeyS: \"moveDown\",\n  KeyW: \"moveUp\",\n  KeyX: \"zoomOut\",\n  KeyZ: \"zoomIn\",\n};\n\ntype KeyMotion = { x?: number, y?: number, zoom?: number, yaw?: number, tilt?: number };\n\ntype Props = {|\n  cameraStore: CameraStore,\n  keyMap?: CameraKeyMap,\n  shiftKeys: boolean,\n  children?: React.ChildrenArray<React.Element<any> | null>,\n|};\n\n// attaches mouse and keyboard listeners to allow for moving the camera on user input\nexport default class CameraListener extends React.Component<Props> {\n  _keyTimer: ?AnimationFrameID;\n  _keys: Set<string> = new Set();\n  _buttons: Set<number> = new Set();\n  _listeners = [];\n  _shiftKey = false;\n  _metaKey = false;\n  _ctrlKey = false;\n\n  _el: ?HTMLDivElement;\n  _rect: ClientRect | DOMRect;\n  _initialMouse: Vec2;\n\n  componentDidMount() {\n    const { _el } = this;\n    if (!_el) {\n      return;\n    }\n\n    this._rect = _el.getBoundingClientRect();\n    const listen = (target: any, name: string, fn) => {\n      target.addEventListener(name, fn);\n      this._listeners.push({ target, name, fn });\n    };\n    listen(document, \"blur\", this._onBlur);\n    listen(window, \"mouseup\", this._onWindowMouseUp);\n    _el.addEventListener(\"wheel\", this._onWheel, { passive: false });\n  }\n\n  componentWillUnmount() {\n    this._listeners.forEach((listener) => {\n      listener.target.removeEventListener(listener.name, listener.fn);\n    });\n    this._endDragging();\n    const { _el } = this;\n    if (!_el) {\n      return;\n    }\n    _el.removeEventListener(\"wheel\", this._onWheel, { passive: false });\n  }\n\n  _getMouseOnScreen = (mouse: MouseEvent) => {\n    const { clientX, clientY } = mouse;\n    const { top, left, width, height } = this._rect;\n    const x = (clientX - left) / width;\n    const y = (clientY - top) / height;\n    return [x, y];\n  };\n\n  _onMouseDown = (e: MouseEvent) => {\n    const { _el } = this;\n    if (!_el) {\n      return;\n    }\n\n    e.preventDefault();\n    this._buttons.add(e.button);\n    _el.focus();\n    this._rect = _el.getBoundingClientRect();\n    this._initialMouse = this._getMouseOnScreen(e);\n    this.startDragging(e);\n  };\n\n  _isLeftMouseDown() {\n    return this._buttons.has(0);\n  }\n\n  _isRightMouseDown() {\n    return this._buttons.has(2);\n  }\n\n  _getMagnitude(base: number = 1) {\n    return this._shiftKey ? base / 10 : base;\n  }\n\n  _getMoveMagnitude() {\n    // avoid interference with drawing tools\n    if (this._ctrlKey) {\n      return { x: 0, y: 0 };\n    }\n\n    const {\n      cameraStore: {\n        state: { distance, perspective },\n      },\n    } = this.props;\n    if (perspective) {\n      // in perspective mode its more like flying, so move by the magnitude\n      // we use the camera distance as a heuristic\n      return { x: distance, y: distance };\n    }\n    // in orthographic mode we know the exact viewable area\n    // which is a square so we can move exactly percentage within it\n    const { width, height } = this._rect;\n    const bounds = getOrthographicBounds(distance, width, height);\n    return { x: bounds.width, y: bounds.height };\n  }\n\n  _onWindowMouseMove = (e: MouseEvent) => {\n    if (!this._buttons.size) {\n      return;\n    }\n    this._shiftKey = e.shiftKey;\n    const {\n      cameraStore: {\n        cameraMove,\n        cameraRotate,\n        state: { perspective },\n      },\n    } = this.props;\n\n    // compute the amount the mouse has moved\n    let moveX, moveY;\n    const mouse = this._getMouseOnScreen(e);\n    // when pointer lock is enabled, we get movementX and movementY (with direction reversed)\n    // instead of the screenX/screenY changing... except, when using synergy, they come through\n    // like regular mousemove events.\n    if ((document: any).pointerLockElement && (e.movementX || e.movementY)) {\n      moveX = -e.movementX / this._rect.width;\n      moveY = -e.movementY / this._rect.height;\n    } else {\n      moveX = this._initialMouse[0] - mouse[0];\n      moveY = this._initialMouse[1] - mouse[1];\n    }\n    this._initialMouse = mouse;\n\n    if (this._isRightMouseDown()) {\n      const magnitude = this._getMagnitude(PAN_SPEED);\n      // in orthographic mode, flip the direction of rotation so \"left\" means \"counterclockwise\"\n      const x = (perspective ? moveX : -moveX) * magnitude;\n      // do not rotate vertically in orthograhpic mode\n      const y = perspective ? moveY * magnitude : 0;\n      cameraRotate([x, y]);\n    }\n\n    if (this._isLeftMouseDown()) {\n      const { x, y } = this._getMoveMagnitude();\n      cameraMove([this._getMagnitude(moveX * x), this._getMagnitude(-moveY * y)]);\n    }\n  };\n\n  _onMouseUp = (e: MouseEvent) => {\n    this._buttons.delete(e.button);\n    this._endDragging();\n  };\n\n  _onWindowMouseUp = (e: MouseEvent) => {\n    const { _el } = this;\n    if (!_el) {\n      return;\n    }\n\n    // do nothing if this container had a mouseup, because we catch it in the onMouseUp handler\n    if (_el.contains((e.target: any)) || e.target === _el) {\n      return;\n    }\n    // If mouseup triggers on the window outside this container, clear any active interactions.\n    // This will allow a mouseup outside the browser window to be handled; otherwise the mouse\n    // \"sticks\" in a down position until another click on this element is received.\n    this._buttons.clear();\n    this._endDragging();\n  };\n\n  startDragging(e: MouseEvent) {\n    if (e.button !== 0 && this._el && typeof this._el.requestPointerLock === \"function\") {\n      this._el.requestPointerLock();\n    }\n    window.addEventListener(\"mousemove\", this._onWindowMouseMove);\n  }\n\n  _endDragging() {\n    window.removeEventListener(\"mousemove\", this._onWindowMouseMove);\n    if (typeof (document: any).exitPointerLock === \"function\") {\n      (document: any).exitPointerLock();\n    }\n  }\n\n  _getKeyMotion = (code: string): ?KeyMotion => {\n    const moveSpeed = this._getMagnitude(KEYBOARD_MOVE_SPEED);\n    const zoomSpeed = this._getMagnitude(KEYBOARD_ZOOM_SPEED);\n    const spinSpeed = this._getMagnitude(KEYBOARD_SPIN_SPEED);\n    const { keyMap, shiftKeys } = this.props;\n    const action: CameraAction | false = (keyMap && keyMap[code]) || DEFAULT_KEYMAP[code] || false;\n\n    if (this._shiftKey && !shiftKeys) {\n      return null;\n    }\n\n    switch (action) {\n      case \"moveRight\":\n        return { x: moveSpeed };\n      case \"moveLeft\":\n        return { x: -moveSpeed };\n      case \"moveUp\":\n        return { y: moveSpeed };\n      case \"moveDown\":\n        return { y: -moveSpeed };\n      case \"zoomIn\":\n        return { zoom: zoomSpeed };\n      case \"zoomOut\":\n        return { zoom: -zoomSpeed };\n      case \"rotateLeft\":\n        return { yaw: -spinSpeed };\n      case \"rotateRight\":\n        return { yaw: spinSpeed };\n      case \"tiltUp\":\n        return { tilt: -spinSpeed };\n      case \"tiltDown\":\n        return { tilt: spinSpeed };\n      case false:\n        return null;\n      default:\n        (action: empty);\n        console.warn(\"Unrecognized key action:\", action);\n        return null;\n    }\n  };\n\n  _moveKeyboard(dt: number) {\n    const motion = { x: 0, y: 0, zoom: 0, yaw: 0, tilt: 0 };\n    this._keys.forEach((code) => {\n      const { x = 0, y = 0, zoom = 0, yaw = 0, tilt = 0 } = this._getKeyMotion(code) || {};\n      motion.x += x;\n      motion.y += y;\n      motion.zoom += zoom;\n      motion.yaw += yaw;\n      motion.tilt += tilt;\n    });\n\n    const {\n      cameraStore: {\n        cameraMove,\n        cameraRotate,\n        cameraZoom,\n        state: { perspective },\n      },\n    } = this.props;\n\n    if (motion.x || motion.y) {\n      const { x, y } = this._getMoveMagnitude();\n      cameraMove([motion.x * x * dt, motion.y * y * dt]);\n    }\n    if (motion.yaw || (perspective && motion.tilt)) {\n      cameraRotate([motion.yaw * dt, perspective ? motion.tilt * dt : 0]);\n    }\n    if (motion.zoom) {\n      cameraZoom(motion.zoom * dt);\n    }\n  }\n\n  _startKeyTimer(lastStamp: ?number) {\n    if (this._keyTimer) {\n      return;\n    }\n    this._keyTimer = requestAnimationFrame((stamp) => {\n      this._moveKeyboard((lastStamp ? stamp - lastStamp : 0) / 1000);\n      this._keyTimer = undefined;\n\n      // Only start the timer if keys are still pressed.\n      // We do this rather than stopping the timer in onKeyUp, because keys held\n      // sometimes actually trigger repeated keyup/keydown, rather than just repeated keydown.\n      // By checking currently-down keys in the requestAnimationFrame callback, we give the browser enough time to\n      // handle both the keyup and keydown before checking whether we should restart the timer.\n      if (this._keys.size) {\n        this._startKeyTimer(stamp);\n      }\n    });\n  }\n\n  _stopKeyTimer() {\n    if (this._keyTimer) {\n      cancelAnimationFrame(this._keyTimer);\n    }\n    this._keyTimer = undefined;\n  }\n\n  _onKeyDown = (e: SyntheticKeyboardEvent<HTMLDivElement>) => {\n    const { keyMap } = this.props;\n    this._shiftKey = e.shiftKey;\n    this._metaKey = e.metaKey;\n    this._ctrlKey = e.ctrlKey;\n    const code = ((e.nativeEvent: any): KeyboardEvent).code;\n\n    // ignore repeated keydown events\n    if (e.repeat || this._keys.has(code)) {\n      e.stopPropagation();\n      e.preventDefault();\n      return;\n    }\n\n    if (e.altKey || e.ctrlKey || e.metaKey) {\n      // we don't currently handle these modifiers\n      return;\n    }\n\n    // allow null, false, or empty keymappings which explicitly cancel Worldview from processing that key\n    if (keyMap && code in keyMap && !keyMap[code]) {\n      return false;\n    }\n\n    // if we respond to this key, start the update timer\n    if (this._getKeyMotion(code)) {\n      this._keys.add(code);\n      this._startKeyTimer();\n      e.stopPropagation();\n      e.preventDefault();\n    }\n  };\n\n  _onKeyUp = (e: SyntheticKeyboardEvent<HTMLDivElement>) => {\n    this._shiftKey = e.shiftKey;\n    this._metaKey = e.metaKey;\n    this._ctrlKey = e.ctrlKey;\n\n    this._keys.delete(((e.nativeEvent: any): KeyboardEvent).code);\n  };\n\n  _onWheel = (e: WheelEvent) => {\n    // stop the wheel event here, as wheel propagation through the entire dom\n    // can cause the browser to slow down & thrash\n    e.preventDefault();\n    e.stopPropagation();\n    this._shiftKey = e.shiftKey;\n\n    // with osx trackpad scrolling, slow to medium pixelY is around +/- 1 to 10\n    // external mouse wheels generally come in higher values around +/- 30 to 50\n    const { pixelX, pixelY } = normalizeWheel(e);\n\n    // shift+scroll on an external mouse may scroll in the X direction instead of Y\n    const wheelAmount = pixelY || pixelX;\n\n    // we use positive value to indicate zooming in\n    // and negative value to zoom out, so reverse the direction of the wheel\n    const dir = Math.sign(wheelAmount) * -1;\n    const amount = Math.abs(wheelAmount);\n    // restrict zoom percentage per tick to between 1 & 50 percent\n    const percentage = Math.max(1, Math.min(amount, 50));\n\n    // support shift+wheel magnitude adjustment\n    const zoomPercentage = this._getMagnitude(percentage * dir * MOUSE_ZOOM_SPEED);\n    this.props.cameraStore.cameraZoom(zoomPercentage);\n  };\n\n  // make sure all movements stop if the document loses focus by resetting modifier keys\n  // to their 'off' position\n  // (e.g. ctrl+tab leaving the page should not leave the ctrl key in the 'on' position)\n  _onBlur = (e: MouseEvent) => {\n    this._keys = new Set();\n    this._ctrlKey = false;\n    this._shiftKey = false;\n    this._metaKey = false;\n    this._stopKeyTimer();\n  };\n\n  _onContextMenu = (e: MouseEvent) => {\n    e.preventDefault();\n    e.stopPropagation();\n  };\n\n  render() {\n    const { children } = this.props;\n    return (\n      <div\n        tabIndex={0}\n        style={{ outline: \"none\" }}\n        draggable\n        ref={(el) => (this._el = el)}\n        onMouseDown={this._onMouseDown}\n        onMouseUp={this._onMouseUp}\n        onBlur={this._onBlur}\n        onContextMenu={this._onContextMenu}\n        onKeyDown={this._onKeyDown}\n        onKeyUp={this._onKeyUp}>\n        {children}\n      </div>\n    );\n  }\n}\n","// @flow\n\n//  Copyright (c) 2018-present, GM Cruise LLC\n//\n//  This source code is licensed under the Apache License, Version 2.0,\n//  found in the LICENSE file in the root directory of this source tree.\n//  You may not use this file except in compliance with the License.\n\nexport { default as camera } from \"./camera\";\nexport { default as CameraListener } from \"./CameraListener\";\nexport { default as cameraProject } from \"./cameraProject\";\nexport { default as CameraStore, DEFAULT_CAMERA_STATE } from \"./CameraStore\";\nexport { default as selectors } from \"./cameraStateSelectors\";\n","// @flow\n\n//  Copyright (c) 2018-present, GM Cruise LLC\n//\n//  This source code is licensed under the Apache License, Version 2.0,\n//  found in the LICENSE file in the root directory of this source tree.\n//  You may not use this file except in compliance with the License.\n\nexport function getNodeEnv() {\n  return process && process.env && process.env.NODE_ENV;\n}\n","// @flow\n\n//  Copyright (c) 2018-present, GM Cruise LLC\n//\n//  This source code is licensed under the Apache License, Version 2.0,\n//  found in the LICENSE file in the root directory of this source tree.\n//  You may not use this file except in compliance with the License.\n\nimport { vec3, mat4 } from \"gl-matrix\";\n\nimport type { CameraCommand, Vec3 } from \"../types\";\n\ntype ClickInfo = { clientX: number, clientY: number, width: number, height: number };\n\nconst tempVec = [0, 0, 0];\nconst tempMat = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n\nexport class Ray {\n  origin: Vec3;\n  dir: Vec3;\n  point: Vec3;\n\n  constructor(origin: Vec3, dir: Vec3, point: Vec3) {\n    this.origin = origin;\n    this.dir = dir;\n    this.point = point;\n  }\n\n  distanceToPoint(point: Vec3) {\n    return vec3.distance(this.origin, point);\n  }\n\n  // https://stackoverflow.com/questions/7168484/3d-line-segment-and-plane-intersection/35396994#35396994\n  planeIntersection(planeCoordinate: Vec3, planeNormal: Vec3): ?Vec3 {\n    const d = vec3.dot(planeNormal, planeCoordinate);\n    const cosine = vec3.dot(planeNormal, this.dir);\n\n    if (cosine === 0) {\n      return null;\n    }\n\n    const x = d - vec3.dot(planeNormal, this.origin) / cosine;\n    const contact = vec3.add([0, 0, 0], this.origin, vec3.scale(tempVec, this.dir, x));\n    return contact;\n  }\n}\n\n// adapted from https://github.com/regl-project/regl/blob/master/example/raycast.js\nexport function getRayFromClick(camera: CameraCommand, { clientX, clientY, width, height }: ClickInfo) {\n  const projectionMatrix = camera.getProjection();\n  const viewMatrix = camera.getView();\n\n  const vp = mat4.multiply(tempMat, projectionMatrix, viewMatrix);\n  const invVp = mat4.invert(tempMat, vp);\n\n  const mouseX = (2.0 * clientX) / width - 1.0;\n  const mouseY = (-2.0 * clientY) / height + 1.0;\n  // get a single point on the camera ray.\n  const rayPoint = vec3.transformMat4([0, 0, 0], [mouseX, mouseY, 0.0], invVp);\n\n  // get the position of the camera.\n  const rayOrigin = vec3.transformMat4([0, 0, 0], [0, 0, 0], mat4.invert(tempMat, viewMatrix));\n  const rayDir = vec3.normalize([0, 0, 0], vec3.subtract(tempVec, rayPoint, rayOrigin));\n\n  return new Ray(rayOrigin, rayDir, rayPoint);\n}\n","// @flow\n\n//  Copyright (c) 2018-present, GM Cruise LLC\n//\n//  This source code is licensed under the Apache License, Version 2.0,\n//  found in the LICENSE file in the root directory of this source tree.\n//  You may not use this file except in compliance with the License.\n\nimport React from \"react\";\n\nimport { type WorldviewContextType } from \"./WorldviewContext\";\n\n// $FlowFixMe\nexport default React.createContext((undefined: WorldviewContextType | void));\n","// @flow\n//  Copyright (c) 2018-present, GM Cruise LLC\n//\n//  This source code is licensed under the Apache License, Version 2.0,\n//  found in the LICENSE file in the root directory of this source tree.\n//  You may not use this file except in compliance with the License.\n\nimport * as React from \"react\";\n\nimport type {\n  ComponentMouseHandler,\n  GetChildrenForHitmap,\n  MouseEventEnum,\n  RawCommand,\n  Color,\n  Point,\n  MouseEventObject,\n} from \"../types\";\nimport { getNodeEnv } from \"../utils/common\";\nimport { Ray } from \"../utils/Raycast\";\nimport { type WorldviewContextType } from \"../WorldviewContext\";\nimport WorldviewReactContext from \"../WorldviewReactContext\";\n\nexport const SUPPORTED_MOUSE_EVENTS = [\"onClick\", \"onMouseUp\", \"onMouseMove\", \"onMouseDown\", \"onDoubleClick\"];\n\nexport type MarkerDefault = {\n  id?: number,\n  points?: Point[],\n  color?: Color,\n};\n\nexport type CommonCommandProps = {\n  [MouseEventEnum]: ComponentMouseHandler,\n  layerIndex?: number,\n  getChildrenForHitmap?: GetChildrenForHitmap,\n};\n\ntype Props<T> = {\n  ...CommonCommandProps,\n  children?: T[] | T,\n  // Deprecated, but here for backwards compatibility\n  drawProps?: T[],\n  reglCommand: RawCommand<T>,\n};\n\nexport type CommandProps<T> = Props<T>;\n\n// Component to dispatch children (for drawing) and hitmap props and a reglCommand to the render loop to render with regl.\nexport default class Command<T> extends React.Component<Props<T>> {\n  context: ?WorldviewContextType;\n  static displayName = \"Command\";\n\n  constructor(props: Props<T>) {\n    super(props);\n    // In development put a check in to make sure the reglCommand prop is not mutated.\n    // Similar to how react checks for unsupported or deprecated calls in a development build.\n    if (getNodeEnv() !== \"production\") {\n      // $FlowFixMe\n      this.shouldComponentUpdate = (nextProps: Props) => {\n        if (nextProps.reglCommand !== this.props.reglCommand) {\n          console.error(\"Changing the regl command prop on a <Command /> is not supported.\");\n        }\n        return true;\n      };\n    }\n  }\n\n  componentDidMount() {\n    const context = this.context;\n    if (!context) {\n      return;\n    }\n    context.onMount(this, this.props.reglCommand);\n    this._updateContext();\n  }\n\n  componentDidUpdate() {\n    this._updateContext();\n  }\n\n  componentWillUnmount() {\n    const context = this.context;\n    if (!context) {\n      return;\n    }\n    context.onUnmount(this);\n  }\n\n  _updateContext() {\n    const context = this.context;\n    if (!context) {\n      return;\n    }\n\n    const { reglCommand, layerIndex, getChildrenForHitmap } = this.props;\n    const children = this.props.children || this.props.drawProps;\n    if (children == null) {\n      return;\n    }\n    context.registerDrawCall({\n      instance: this,\n      reglCommand,\n      children,\n      layerIndex,\n      getChildrenForHitmap,\n    });\n  }\n\n  handleMouseEvent(\n    objects: MouseEventObject[],\n    ray: Ray,\n    e: SyntheticMouseEvent<HTMLCanvasElement>,\n    mouseEventName: MouseEventEnum\n  ) {\n    const mouseHandler = this.props[mouseEventName];\n    if (!mouseHandler || !objects.length) {\n      return;\n    }\n    mouseHandler(e, { ray, objects });\n  }\n\n  render() {\n    return (\n      <WorldviewReactContext.Consumer>\n        {(ctx: ?WorldviewContextType) => {\n          if (ctx) {\n            this.context = ctx;\n          }\n          return null;\n        }}\n      </WorldviewReactContext.Consumer>\n    );\n  }\n}\n","// @flow\n\n//  Copyright (c) 2018-present, GM Cruise LLC\n//\n//  This source code is licensed under the Apache License, Version 2.0,\n//  found in the LICENSE file in the root directory of this source tree.\n//  You may not use this file except in compliance with the License.\n\n// Takes an array of [value, key] and aggregates across the keys. Results in a Map of [key, values[]], in order of the\n// keys as seen in the array.\nexport default function aggregate<T, K>(array: Array<[T, K]>): Map<K, T[]> {\n  const aggregationMap = new Map<K, T[]>();\n  array.forEach(([item, key]) => {\n    const existingItems = aggregationMap.get(key) || [];\n    existingItems.push(item);\n    if (!aggregationMap.has(key)) {\n      aggregationMap.set(key, existingItems);\n    }\n  });\n  return aggregationMap;\n}\n","// @flow\n\n//  Copyright (c) 2018-present, GM Cruise LLC\n//\n//  This source code is licensed under the Apache License, Version 2.0,\n//  found in the LICENSE file in the root directory of this source tree.\n//  You may not use this file except in compliance with the License.\n\nimport last from \"lodash/last\";\n\nimport Command from \"../commands/Command\";\nimport type { ObjectHitmapId, Vec4, MouseEventObject } from \"../types\";\nimport { intToRGB } from \"./commandUtils\";\n\nfunction fillArray(start: number, length: number): number[] {\n  return new Array(length).fill(0).map((_, index) => start + index);\n}\n\ntype CommandType = Command<any>;\n\n/*\n * This object manages the mapping between objects that are rendered into the scene and their IDs.\n * It supplies an API for generating IDs for a rendered object and then accessing those objects based on their ID.\n */\nexport default class HitmapObjectIdManager {\n  _objectsByObjectHitmapIdMap: { [ObjectHitmapId]: Object } = {};\n  _commandsByObjectMap: Map<Object, CommandType> = new Map();\n  _nextObjectHitmapId = 1;\n  _instanceIndexByObjectHitmapIdMap: { [ObjectHitmapId]: number } = {};\n\n  assignNextColors = (command: CommandType, object: Object, count: number): Vec4[] => {\n    if (count < 1) {\n      throw new Error(\"Must get at least 1 id\");\n    }\n\n    const ids: ObjectHitmapId[] = fillArray(this._nextObjectHitmapId, count);\n    this._nextObjectHitmapId = last(ids) + 1;\n\n    // Instanced rendering - add to the instanced ID map.\n    if (count > 1) {\n      ids.forEach((id, index) => {\n        this._instanceIndexByObjectHitmapIdMap[id] = index;\n      });\n    }\n\n    // Store the mapping of ID to original marker object\n    for (const id of ids) {\n      this._objectsByObjectHitmapIdMap[id] = object;\n    }\n    this._commandsByObjectMap.set(object, command);\n\n    // Return colors from the IDs.\n    const colors = ids.map((id) => intToRGB(id));\n    return colors;\n  };\n\n  getObjectByObjectHitmapId = (objectHitmapId: ObjectHitmapId): MouseEventObject => {\n    return {\n      object: this._objectsByObjectHitmapIdMap[objectHitmapId],\n      instanceIndex: this._instanceIndexByObjectHitmapIdMap[objectHitmapId],\n    };\n  };\n\n  getCommandForObject = (object: Object): ?CommandType => {\n    return this._commandsByObjectMap.get(object);\n  };\n}\n","// @flow\n//\n//  Copyright (c) 2019-present, Cruise LLC\n//\n//  This source code is licensed under the Apache License, Version 2.0,\n//  found in the LICENSE file in the root directory of this source tree.\n//  You may not use this file except in compliance with the License.\n\nexport type Signal<T> = Promise<T> & {\n  resolve: (T) => void,\n  reject: (Error) => void,\n};\n\nexport function signal<T>(): Signal<T> {\n  let resolve;\n  let reject;\n  const promise: any = new Promise((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n  promise.resolve = resolve;\n  promise.reject = reject;\n  return promise;\n}\n","// @flow\n//\n//  Copyright (c) 2019-present, Cruise LLC\n//\n//  This source code is licensed under the Apache License, Version 2.0,\n//  found in the LICENSE file in the root directory of this source tree.\n//  You may not use this file except in compliance with the License.\n\nimport { signal, type Signal } from \"./signal\";\n\ntype QueuedFn = ((...args: any[]) => Promise<any>) & { currentPromise: ?Promise<any> };\n\n// Wait for the previous promise to resolve before starting the next call to the function.\nexport default function queuePromise(fn: (...args: any[]) => Promise<any>): QueuedFn {\n  // Whether we are currently waiting for a promise returned by `fn` to resolve.\n  let calling = false;\n  // The list of calls made to the function was made while a call was in progress.\n  const nextCalls: {| args: any[], promise: Signal<any> |}[] = [];\n\n  function queuedFn(...args) {\n    if (calling) {\n      const returnPromise = signal();\n      nextCalls.push({ args, promise: returnPromise });\n      return returnPromise;\n    }\n    return start(...args);\n  }\n\n  function start(...args) {\n    calling = true;\n\n    const promise = fn(...args).finally(() => {\n      calling = false;\n      queuedFn.currentPromise = undefined;\n      if (nextCalls.length) {\n        const { promise: nextPromise, args: nextArgs } = nextCalls.shift();\n        start(...nextArgs)\n          .then((result) => nextPromise.resolve(result))\n          .catch((error) => nextPromise.reject(error));\n      }\n    });\n    queuedFn.currentPromise = promise;\n\n    return promise;\n  }\n\n  return queuedFn;\n}\n","// @flow\n\n//  Copyright (c) 2018-present, GM Cruise LLC\n//\n//  This source code is licensed under the Apache License, Version 2.0,\n//  found in the LICENSE file in the root directory of this source tree.\n//  You may not use this file except in compliance with the License.\n\nimport debounce from \"lodash/debounce\";\nimport * as React from \"react\";\nimport createREGL from \"regl\";\nimport shallowequal from \"shallowequal\";\n\nimport { camera, CameraStore } from \"./camera/index\";\nimport Command from \"./commands/Command\";\nimport type {\n  Dimensions,\n  RawCommand,\n  CompiledReglCommand,\n  CameraCommand,\n  Vec4,\n  CameraState,\n  MouseEventObject,\n  GetChildrenForHitmap,\n  AssignNextColorsFn,\n} from \"./types\";\nimport { getIdFromPixel, intToRGB } from \"./utils/commandUtils\";\nimport { getNodeEnv } from \"./utils/common\";\nimport HitmapObjectIdManager from \"./utils/HitmapObjectIdManager\";\nimport queuePromise from \"./utils/queuePromise\";\nimport { getRayFromClick } from \"./utils/Raycast\";\n\ntype Props = any;\n\ntype ConstructorArgs = {\n  dimension: Dimensions,\n  canvasBackgroundColor: Vec4,\n  cameraState: CameraState,\n  defaultCameraState?: CameraState,\n  onCameraStateChange: ?(CameraState) => void,\n};\n\ntype InitializedData = {\n  _fbo: any,\n  regl: any,\n  camera: CameraCommand,\n};\n\nexport type DrawInput = {\n  instance: Command<any>,\n  reglCommand: RawCommand<any>,\n  children: Props,\n  layerIndex: ?number,\n  getChildrenForHitmap: ?GetChildrenForHitmap,\n};\n\nexport type PaintFn = () => void;\n\nexport type WorldviewContextType = {\n  onMount(instance: Command<any>, command: RawCommand<any>): void,\n  registerDrawCall(drawInput: DrawInput): void,\n  registerPaintCallback(PaintFn): void,\n  unregisterPaintCallback(PaintFn): void,\n  onUnmount(instance: Command<any>): void,\n  onDirty(): void,\n  +dimension: Dimensions,\n  +initializedData: ?InitializedData,\n};\n\n// Compile instructions with an initialized regl context into a regl command.\n// If the instructions are a function, pass the context to the instructions and compile the result\n// of the function; otherwise, compile the instructions directly\nfunction compile<T>(regl: any, cmd: RawCommand<T>): CompiledReglCommand<T> {\n  const src = cmd(regl);\n  return typeof src === \"function\" ? src : regl(src);\n}\n\n// This is made available to every Command component as `this.context`.\n// It contains all the regl interaction code and is responsible for collecting and executing\n// draw calls, hitmap calls, and raycasting.\n\nexport class WorldviewContext {\n  _commands: Set<RawCommand<any>> = new Set();\n  _compiled: Map<Function, CompiledReglCommand<any>> = new Map();\n  _drawCalls: Map<React.Component<any>, DrawInput> = new Map();\n  _paintCalls: Map<PaintFn, PaintFn> = new Map();\n  _hitmapObjectIdManager: HitmapObjectIdManager = new HitmapObjectIdManager();\n  _cachedReadHitmapCall: ?{\n    arguments: any[],\n    result: Array<[MouseEventObject, Command<any>]>,\n  } = undefined;\n  // store every compiled command object compiled for debugging purposes\n  reglCommandObjects: { stats: { count: number } }[] = [];\n  counters: { paint?: number, render?: number } = {};\n  dimension: Dimensions;\n  onDirty: () => void;\n  cameraStore: CameraStore;\n  canvasBackgroundColor: Vec4 = [0, 0, 0, 1];\n  // group all initialized data together so it can be checked for existence to verify initialization is complete\n  initializedData: ?InitializedData;\n\n  constructor({ dimension, canvasBackgroundColor, cameraState, onCameraStateChange }: ConstructorArgs) {\n    // used for children to call paint() directly\n    this.onDirty = this._debouncedPaint;\n    this.dimension = dimension;\n    this.canvasBackgroundColor = canvasBackgroundColor;\n    this.cameraStore = new CameraStore((cameraState: CameraState) => {\n      if (onCameraStateChange) {\n        onCameraStateChange(cameraState);\n      } else {\n        // this must be called for Worldview with defaultCameraState prop\n        this.paint();\n      }\n    }, cameraState);\n  }\n\n  initialize(canvas: HTMLCanvasElement) {\n    if (this.initializedData) {\n      throw new Error(\"can not initialize regl twice\");\n    }\n\n    const regl = this._instrumentCommands(\n      createREGL({\n        canvas,\n        extensions: [\n          \"angle_instanced_arrays\",\n          \"oes_texture_float\",\n          \"oes_element_index_uint\",\n          \"oes_standard_derivatives\",\n        ],\n        profile: getNodeEnv() !== \"production\",\n      })\n    );\n    // compile any components which mounted before regl is initialized\n    this._commands.forEach((uncompiledCommand) => {\n      const compiledCommand = compile(regl, uncompiledCommand);\n      this._compiled.set(uncompiledCommand, compiledCommand);\n    });\n\n    const Camera = compile(regl, camera);\n    const compiledCameraCommand = new Camera();\n    // framebuffer object from regl context\n    const fbo = regl.framebuffer({\n      width: Math.round(this.dimension.width),\n      height: Math.round(this.dimension.height),\n    });\n\n    this.initializedData = {\n      _fbo: fbo,\n      camera: compiledCameraCommand,\n      regl,\n    };\n  }\n\n  destroy() {\n    if (this.initializedData) {\n      this.initializedData.regl.destroy();\n    }\n  }\n\n  // compile a command when it is first mounted, and try to register in _commands and _compiled maps\n  onMount(instance: React.Component<any>, command: RawCommand<any>) {\n    const { initializedData } = this;\n    // do nothing if regl hasn't been initialized yet\n    if (!initializedData || this._commands.has(command)) {\n      return;\n    }\n    this._commands.add(command);\n\n    // for components that mount after regl is initialized\n    this._compiled.set(command, compile(initializedData.regl, command));\n  }\n\n  // unregister children hitmap and draw calls\n  onUnmount(instance: React.Component<any>) {\n    this._drawCalls.delete(instance);\n  }\n\n  unregisterPaintCallback(paintFn: PaintFn) {\n    this._paintCalls.delete(paintFn);\n  }\n\n  registerDrawCall(drawInput: DrawInput) {\n    this._drawCalls.set(drawInput.instance, drawInput);\n  }\n\n  registerPaintCallback(paintFn: PaintFn) {\n    this._paintCalls.set(paintFn, paintFn);\n  }\n\n  setDimension(dimension: Dimensions) {\n    this.dimension = dimension;\n  }\n\n  raycast = (canvasX: number, canvasY: number) => {\n    if (!this.initializedData) {\n      return undefined;\n    }\n\n    const { width, height } = this.dimension;\n    return getRayFromClick(this.initializedData.camera, {\n      clientX: canvasX,\n      clientY: canvasY,\n      width,\n      height,\n    });\n  };\n\n  paint() {\n    const start = Date.now();\n    this.reglCommandObjects.forEach((cmd) => (cmd.stats.count = 0));\n    if (!this.initializedData) {\n      return;\n    }\n    this._cachedReadHitmapCall = null; // clear the cache every time we paint\n    const { regl, camera } = this.initializedData;\n    this._clearCanvas(regl);\n    camera.draw(this.cameraStore.state, () => {\n      const x = Date.now();\n      this._drawInput();\n      this.counters.paint = Date.now() - x;\n    });\n\n    this._paintCalls.forEach((paintCall) => {\n      paintCall();\n    });\n    this.counters.render = Date.now() - start;\n  }\n\n  _debouncedPaint = debounce(this.paint, 10);\n\n  readHitmap = queuePromise(\n    (\n      canvasX: number,\n      canvasY: number,\n      enableStackedObjectEvents: boolean,\n      maxStackedObjectCount: number\n    ): Promise<Array<[MouseEventObject, Command<any>]>> => {\n      if (!this.initializedData) {\n        return Promise.reject(new Error(\"regl data not initialized yet\"));\n      }\n      const args = [canvasX, canvasY, enableStackedObjectEvents, maxStackedObjectCount];\n\n      const cachedReadHitmapCall = this._cachedReadHitmapCall;\n      if (cachedReadHitmapCall) {\n        if (shallowequal(cachedReadHitmapCall.arguments, args)) {\n          // Make sure that we aren't returning the exact object identity of the mouseEventObject - we don't know what\n          // callers have done with it.\n          const result = cachedReadHitmapCall.result.map(([mouseEventObject, command]) => [\n            { ...mouseEventObject },\n            command,\n          ]);\n          return Promise.resolve(result);\n        }\n        this._cachedReadHitmapCall = undefined;\n      }\n\n      const { regl, camera, _fbo } = this.initializedData;\n      const { width, height } = this.dimension;\n\n      const x = canvasX;\n      // 0,0 corresponds to the bottom left in the webgl context, but the top left in window coordinates\n      const y = height - canvasY;\n\n      // regl will only resize the framebuffer if the size changed\n      // it uses floored whole pixel values\n      _fbo.resize(Math.floor(width), Math.floor(height));\n\n      return new Promise((resolve) => {\n        // tell regl to use a framebuffer for this render\n        regl({ framebuffer: _fbo })(() => {\n          // clear the framebuffer\n          regl.clear({ color: intToRGB(0), depth: 1 });\n          let currentObjectId = 0;\n          const excludedObjects = [];\n          const mouseEventsWithCommands = [];\n          let counter = 0;\n\n          camera.draw(this.cameraStore.state, () => {\n            // Every iteration in this loop clears the framebuffer, draws the hitmap objects that have NOT already been\n            // seen to the framebuffer, and then reads the pixel under the cursor to find the object on top.\n            // If `enableStackedObjectEvents` is false, we only do this iteration once - we only resolve with 0 or 1\n            // objects.\n            do {\n              if (counter >= maxStackedObjectCount) {\n                // Provide a max number of layers so this while loop doesn't crash the page.\n                console.error(\n                  `Hit ${maxStackedObjectCount} iterations. There is either a bug or that number of rendered hitmap layers under the mouse cursor.`\n                );\n                break;\n              }\n              counter++;\n              regl.clear({ color: intToRGB(0), depth: 1 });\n              this._drawInput(true, excludedObjects);\n\n              // it's possible to get x/y values outside the framebuffer size\n              // if the mouse quickly leaves the draw area during a read operation\n              // reading outside the bounds of the framebuffer causes errors\n              // and puts regl into a bad internal state.\n              // https://github.com/regl-project/regl/blob/28fbf71c871498c608d9ec741d47e34d44af0eb5/lib/read.js#L57\n              if (x < Math.floor(width) && y < Math.floor(height) && x >= 0 && y >= 0) {\n                const pixel = new Uint8Array(4);\n\n                // read pixel value from the frame buffer\n                regl.read({\n                  x,\n                  y,\n                  width: 1,\n                  height: 1,\n                  data: pixel,\n                });\n\n                currentObjectId = getIdFromPixel(pixel);\n                const mouseEventObject = this._hitmapObjectIdManager.getObjectByObjectHitmapId(currentObjectId);\n\n                // Check an error case: if we see an ID/color that we don't know about, it means that some command is\n                // drawing a color into the hitmap that it shouldn't be.\n                if (currentObjectId > 0 && !mouseEventObject) {\n                  console.error(\n                    `Clicked on an unknown object with id ${currentObjectId}. This likely means that a command is painting an incorrect color into the hitmap.`\n                  );\n                }\n                // Check an error case: if we've already seen this object, then the getHitmapFromChildren function\n                // is not respecting the excludedObjects correctly and we should notify the user of a bug.\n                if (\n                  excludedObjects.some(\n                    ({ object, instanceIndex }) =>\n                      object === mouseEventObject.object && instanceIndex === mouseEventObject.instanceIndex\n                  )\n                ) {\n                  console.error(\n                    `Saw object twice when reading from hitmap. There is likely an error in getHitmapFromChildren`,\n                    mouseEventObject\n                  );\n                  break;\n                }\n\n                if (currentObjectId > 0 && mouseEventObject.object) {\n                  const command = this._hitmapObjectIdManager.getCommandForObject(mouseEventObject.object);\n                  excludedObjects.push(mouseEventObject);\n                  if (command) {\n                    mouseEventsWithCommands.push([mouseEventObject, command]);\n                  }\n                }\n              }\n              // If we haven't enabled stacked object events, break out of the loop immediately.\n              // eslint-disable-next-line no-unmodified-loop-condition\n            } while (currentObjectId !== 0 && enableStackedObjectEvents);\n\n            this._cachedReadHitmapCall = {\n              arguments: args,\n              result: mouseEventsWithCommands,\n            };\n            resolve(mouseEventsWithCommands);\n          });\n        });\n      });\n    }\n  );\n\n  _drawInput = (isHitmap?: boolean, excludedObjects?: MouseEventObject[]) => {\n    if (isHitmap) {\n      this._hitmapObjectIdManager = new HitmapObjectIdManager();\n    }\n\n    const drawCalls = Array.from(this._drawCalls.values()).sort((a, b) => (a.layerIndex || 0) - (b.layerIndex || 0));\n    drawCalls.forEach((drawInput: DrawInput) => {\n      const { reglCommand, children, instance, getChildrenForHitmap } = drawInput;\n      if (!children) {\n        return console.debug(`${isHitmap ? \"hitmap\" : \"\"} draw skipped, props was falsy`, drawInput);\n      }\n      const cmd = this._compiled.get(reglCommand);\n      if (!cmd) {\n        return console.warn(\"could not find draw command for\", instance ? instance.constructor.displayName : \"Unknown\");\n      }\n      // draw hitmap\n      if (isHitmap && getChildrenForHitmap) {\n        const assignNextColorsFn: AssignNextColorsFn = (...rest) => {\n          return this._hitmapObjectIdManager.assignNextColors(instance, ...rest);\n        };\n        const hitmapProps = getChildrenForHitmap(children, assignNextColorsFn, excludedObjects || []);\n        if (hitmapProps) {\n          cmd(hitmapProps, true);\n        }\n      } else if (!isHitmap) {\n        cmd(children, false);\n      }\n    });\n  };\n\n  _clearCanvas = (regl: any) => {\n    // Since we aren't using regl.frame and only rendering when we need to,\n    // we need to tell regl to update its internal state.\n    regl.poll();\n    regl.clear({\n      color: this.canvasBackgroundColor,\n      depth: 1,\n    });\n  };\n\n  _instrumentCommands(regl: any) {\n    if (getNodeEnv() === \"production\") {\n      return regl;\n    }\n    return new Proxy(regl, {\n      apply: (target, thisArg, args) => {\n        const command = target(...args);\n        if (typeof command.stats === \"object\") {\n          this.reglCommandObjects.push(command);\n        }\n        return command;\n      },\n    });\n  }\n}\n","// @flow\n\n//  Copyright (c) 2018-present, GM Cruise LLC\n//\n//  This source code is licensed under the Apache License, Version 2.0,\n//  found in the LICENSE file in the root directory of this source tree.\n//  You may not use this file except in compliance with the License.\n\nimport mapValues from \"lodash/mapValues\";\nimport pickBy from \"lodash/pickBy\";\nimport * as React from \"react\";\nimport ContainerDimensions from \"react-container-dimensions\";\n\nimport { CameraListener, DEFAULT_CAMERA_STATE } from \"./camera/index\";\nimport Command from \"./commands/Command\";\nimport type {\n  MouseHandler,\n  Dimensions,\n  Vec4,\n  CameraState,\n  CameraKeyMap,\n  MouseEventEnum,\n  MouseEventObject,\n} from \"./types\";\nimport aggregate from \"./utils/aggregate\";\nimport { getNodeEnv } from \"./utils/common\";\nimport { Ray } from \"./utils/Raycast\";\nimport { WorldviewContext } from \"./WorldviewContext\";\nimport WorldviewReactContext from \"./WorldviewReactContext\";\n\nconst DEFAULT_BACKGROUND_COLOR = [0, 0, 0, 1];\nexport const DEFAULT_MOUSE_CLICK_RADIUS = 3;\nconst DEFAULT_MAX_NUMBER_OF_HITMAP_LAYERS = 100;\n\nexport type BaseProps = {|\n  keyMap?: CameraKeyMap,\n  shiftKeys: boolean,\n  backgroundColor?: Vec4,\n  // rendering the hitmap on mouse move is expensive, so disable it by default\n  hitmapOnMouseMove?: boolean,\n  // getting events for objects stacked on top of each other is expensive, so disable it by default\n  enableStackedObjectEvents?: boolean,\n  // allow users to specify the max stacked object count\n  maxStackedObjectCount: number,\n  showDebug?: boolean,\n  children?: React.Node,\n  style: { [styleAttribute: string]: number | string },\n\n  cameraState?: $Shape<CameraState>,\n  onCameraStateChange?: (CameraState) => void,\n  defaultCameraState?: $Shape<CameraState>,\n  // interactions\n  onDoubleClick?: MouseHandler,\n  onMouseDown?: MouseHandler,\n  onMouseUp?: MouseHandler,\n  onMouseMove?: MouseHandler,\n  onClick?: MouseHandler,\n  ...Dimensions,\n|};\n\ntype State = {|\n  worldviewContext: WorldviewContext,\n|};\n\nfunction handleWorldviewMouseInteraction(\n  objects: MouseEventObject[],\n  ray: Ray,\n  e: SyntheticMouseEvent<HTMLCanvasElement>,\n  handler: MouseHandler\n) {\n  const args = { ray, objects };\n\n  try {\n    handler(e, args);\n  } catch (err) {\n    console.error(\"Error during mouse handler\", err);\n  }\n}\n\n// responsible for camera and scene state management\n// takes in children that declaritively define what should be rendered\nexport class WorldviewBase extends React.Component<BaseProps, State> {\n  _canvas: { current: HTMLCanvasElement | null } = React.createRef();\n  _tick: AnimationFrameID | void;\n  _dragStartPos: ?{ x: number, y: number } = null;\n\n  static defaultProps = {\n    maxStackedObjectCount: DEFAULT_MAX_NUMBER_OF_HITMAP_LAYERS,\n    backgroundColor: DEFAULT_BACKGROUND_COLOR,\n    shiftKeys: true,\n    style: {},\n  };\n\n  constructor(props: BaseProps) {\n    super(props);\n    const { width, height, top, left, backgroundColor, onCameraStateChange, cameraState, defaultCameraState } = props;\n    if (onCameraStateChange) {\n      if (!cameraState) {\n        console.warn(\n          \"You provided `onCameraStateChange` without `cameraState`. Use Worldview as a controlled component with `cameraState` and `onCameraStateChange`, or uncontrolled with `defaultCameraState`.\"\n        );\n      }\n      if (cameraState && defaultCameraState) {\n        console.warn(\"You provided both `cameraState` and `defaultCameraState`. `defaultCameraState` will be ignored.\");\n      }\n    } else {\n      if (cameraState) {\n        console.warn(\n          \"You provided `cameraState` without an `onCameraStateChange` handler. This will prevent moving the camera. If the camera should be movable, use `defaultCameraState`, otherwise set `onCameraStateChange`.\"\n        );\n      }\n    }\n\n    this.state = {\n      worldviewContext: new WorldviewContext({\n        dimension: { width, height, top, left },\n        canvasBackgroundColor: backgroundColor || DEFAULT_BACKGROUND_COLOR,\n        // DEFAULT_CAMERA_STATE is applied if both `cameraState` and `defaultCameraState` are not present\n        cameraState: props.cameraState || props.defaultCameraState || DEFAULT_CAMERA_STATE,\n        onCameraStateChange: props.onCameraStateChange || undefined,\n      }),\n    };\n  }\n\n  static getDerivedStateFromProps({ width, height, top, left }: BaseProps, { worldviewContext }: State) {\n    worldviewContext.setDimension({ width, height, top, left });\n    return null;\n  }\n\n  componentDidMount() {\n    if (!this._canvas.current) {\n      return console.warn(\"missing canvas element\");\n    }\n    const { worldviewContext } = this.state;\n    worldviewContext.initialize(this._canvas.current);\n    // trigger rendering in children that require camera to be present, e.g. Text component\n    this.setState({}); //eslint-disable-line\n    // call paint to set the correct viewportWidth and viewportHeight for camera so non-regl components\n    // such as Text can get the correct screen coordinates for the first render\n    worldviewContext.paint();\n  }\n\n  componentWillUnmount() {\n    if (this._tick) {\n      cancelAnimationFrame(this._tick);\n    }\n    this.state.worldviewContext.destroy();\n  }\n\n  componentDidUpdate() {\n    const { worldviewContext } = this.state;\n    // update internal cameraState\n    if (this.props.cameraState) {\n      worldviewContext.cameraStore.setCameraState(this.props.cameraState);\n    }\n\n    // queue up a paint operation on the next frame, if we haven't already\n    if (!this._tick) {\n      this._tick = requestAnimationFrame(() => {\n        this._tick = undefined;\n        try {\n          worldviewContext.paint();\n        } catch (error) {\n          // Regl automatically tries to reconnect when losing the canvas 3d context.\n          // We should log this error, but it's not important to throw it.\n          if (error.message === \"(regl) context lost\") {\n            console.warn(error);\n          } else {\n            throw error;\n          }\n        }\n      });\n    }\n  }\n\n  _onDoubleClick = (e: SyntheticMouseEvent<HTMLCanvasElement>) => {\n    this._onMouseInteraction(e, \"onDoubleClick\");\n  };\n\n  _onMouseDown = (e: SyntheticMouseEvent<HTMLCanvasElement>) => {\n    this._dragStartPos = { x: e.clientX, y: e.clientY };\n    this._onMouseInteraction(e, \"onMouseDown\");\n  };\n\n  _onMouseMove = (e: SyntheticMouseEvent<HTMLCanvasElement>) => {\n    this._onMouseInteraction(e, \"onMouseMove\");\n  };\n\n  _onMouseUp = (e: SyntheticMouseEvent<HTMLCanvasElement>) => {\n    this._onMouseInteraction(e, \"onMouseUp\");\n    const { _dragStartPos } = this;\n    if (_dragStartPos) {\n      const deltaX = e.clientX - _dragStartPos.x;\n      const deltaY = e.clientY - _dragStartPos.y;\n      const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n      if (distance < DEFAULT_MOUSE_CLICK_RADIUS) {\n        this._onMouseInteraction(e, \"onClick\");\n      }\n      this._dragStartPos = null;\n    }\n  };\n\n  _onMouseInteraction = (e: SyntheticMouseEvent<HTMLCanvasElement>, mouseEventName: MouseEventEnum) => {\n    const { worldviewContext } = this.state;\n    const worldviewHandler = this.props[mouseEventName];\n\n    if (!(e.target instanceof window.HTMLElement) || e.button !== 0) {\n      return;\n    }\n\n    const { top: clientTop, left: clientLeft } = e.target.getBoundingClientRect();\n    const { clientX, clientY } = e;\n\n    const canvasX = clientX - clientLeft;\n    const canvasY = clientY - clientTop;\n    const ray = worldviewContext.raycast(canvasX, canvasY);\n    if (!ray) {\n      return;\n    }\n\n    // rendering the hitmap on mouse move is expensive, so disable it by default\n    if (mouseEventName === \"onMouseMove\" && !this.props.hitmapOnMouseMove) {\n      if (worldviewHandler) {\n        return handleWorldviewMouseInteraction([], ray, e, worldviewHandler);\n      }\n      return;\n    }\n\n    // reading hitmap is async so we need to persist the event to use later in the event handler\n    (e: any).persist();\n    worldviewContext\n      .readHitmap(canvasX, canvasY, !!this.props.enableStackedObjectEvents, this.props.maxStackedObjectCount)\n      .then((mouseEventsWithCommands) => {\n        const mouseEventsByCommand: Map<Command<any>, Array<MouseEventObject>> = aggregate(mouseEventsWithCommands);\n        for (const [command, mouseEvents] of mouseEventsByCommand.entries()) {\n          command.handleMouseEvent(mouseEvents, ray, e, mouseEventName);\n          if (e.isPropagationStopped()) {\n            break;\n          }\n        }\n        if (worldviewHandler && !e.isPropagationStopped()) {\n          const mouseEvents = mouseEventsWithCommands.map(([mouseEventObject]) => mouseEventObject);\n          handleWorldviewMouseInteraction(mouseEvents, ray, e, worldviewHandler);\n        }\n      })\n      .catch((e) => {\n        console.error(e);\n      });\n  };\n\n  _renderDebug() {\n    const { worldviewContext } = this.state;\n    const initializedData = worldviewContext.initializedData;\n\n    if (getNodeEnv() === \"production\" || !initializedData) {\n      return null;\n    }\n    const { regl } = initializedData;\n    const mem = window.performance.memory;\n    const style = {\n      bottom: 5,\n      right: 10,\n      width: 200,\n      position: \"absolute\",\n      backgroundColor: \"rgba(0, 0, 0, 0.5)\",\n      color: \"white\",\n      fontFamily: \"monospace\",\n      fontSize: 10,\n    };\n    const { counters, reglCommandObjects } = worldviewContext;\n    const data = mapValues(counters, (val) => `${val} ms`);\n    data[\"draw calls\"] = reglCommandObjects.reduce((total, cmd) => total + cmd.stats.count, 0);\n    if (mem) {\n      data[\"heap used\"] = `${((mem.usedJSHeapSize / mem.jsHeapSizeLimit) * 100).toFixed(3)}%`;\n    }\n\n    Object.assign(data, pickBy(regl.stats, (val) => typeof val === \"number\" && val !== 0));\n    if (regl.stats.bufferCount > 1000) {\n      throw new Error(\"Memory leak: Buffer count > 1000.\");\n    }\n\n    const rows = Object.keys(data).map((key) => {\n      return (\n        <tr key={key} style={{ backgroundColor: \"transparent\", border: \"none\" }}>\n          <td style={{ paddingRight: 10, border: \"none\" }}>{key}</td>\n          <td style={{ width: \"100%\", border: \"none\" }}>{data[key]}</td>\n        </tr>\n      );\n    });\n    return (\n      <table style={style}>\n        <tbody>{rows}</tbody>\n      </table>\n    );\n  }\n\n  render() {\n    const { width, height, showDebug, keyMap, shiftKeys, style, cameraState, onCameraStateChange } = this.props;\n    const { worldviewContext } = this.state;\n    // If we are supplied controlled camera state and no onCameraStateChange callback\n    // then there is a 'fixed' camera from outside of worldview itself.\n    const isFixedCamera = cameraState && !onCameraStateChange;\n    const canvasHtml = (\n      <React.Fragment>\n        <canvas\n          style={{ width, height, maxWidth: \"100%\", maxHeight: \"100%\" }}\n          width={width}\n          height={height}\n          ref={this._canvas}\n          onMouseUp={this._onMouseUp}\n          onMouseDown={this._onMouseDown}\n          onDoubleClick={this._onDoubleClick}\n          onMouseMove={this._onMouseMove}\n        />\n        {showDebug && this._renderDebug()}\n      </React.Fragment>\n    );\n\n    return (\n      <div style={{ position: \"relative\", overflow: \"hidden\", ...style }}>\n        {/* skip rendering CameraListener if Worldview has a fixed camera */}\n        {isFixedCamera ? (\n          canvasHtml\n        ) : (\n          <CameraListener cameraStore={worldviewContext.cameraStore} keyMap={keyMap} shiftKeys={shiftKeys}>\n            {canvasHtml}\n          </CameraListener>\n        )}\n        {worldviewContext.initializedData && (\n          <WorldviewReactContext.Provider value={worldviewContext}>\n            {this.props.children}\n          </WorldviewReactContext.Provider>\n        )}\n      </div>\n    );\n  }\n}\n\nexport type Props = $Diff<React.ElementConfig<typeof WorldviewBase>, Dimensions>;\n\nconst Worldview = (props: Props) => (\n  <ContainerDimensions>\n    {({ width, height, left, top }) => <WorldviewBase width={width} height={height} left={left} top={top} {...props} />}\n  </ContainerDimensions>\n);\n\nWorldview.displayName = \"Worldview\";\n\nexport default Worldview;\n","// @flow\n\n//  Copyright (c) 2018-present, GM Cruise LLC\n//\n//  This source code is licensed under the Apache License, Version 2.0,\n//  found in the LICENSE file in the root directory of this source tree.\n//  You may not use this file except in compliance with the License.\n\nimport type { Point } from \"../types\";\n\n// a single min/max value\nclass Bound {\n  min: number;\n  max: number;\n\n  constructor() {\n    this.min = Number.MAX_SAFE_INTEGER;\n    this.max = Number.MIN_SAFE_INTEGER;\n  }\n  // update the bound based on a value\n  update(value: number) {\n    this.min = Math.min(this.min, value);\n    this.max = Math.max(this.max, value);\n  }\n}\n\n// represents x, y, and z min & max bounds for a 3d scene\nexport default class Bounds {\n  x: Bound;\n  y: Bound;\n  z: Bound;\n\n  constructor() {\n    this.x = new Bound();\n    this.y = new Bound();\n    this.z = new Bound();\n  }\n\n  // update the bounds based on a point\n  update(point: Point) {\n    this.x.update(point.x);\n    this.y.update(point.y);\n    this.z.update(point.z);\n  }\n}\n","// @flow\n\n//  Copyright (c) 2018-present, GM Cruise LLC\n//\n//  This source code is licensed under the Apache License, Version 2.0,\n//  found in the LICENSE file in the root directory of this source tree.\n//  You may not use this file except in compliance with the License.\n\nimport { mat3 } from \"gl-matrix\";\n\nimport type { Vec3, Vec4 } from \"../types\";\n\nconst scratch = [0, 0, 0, 0, 0, 0, 0, 0, 0];\n\n// gl-matrix clone of three.js Euler.setFromQuaternion\n// assumes default XYZ order\nexport default function eulerFromQuaternion(out: number[], q: Vec4): Vec3 {\n  const m = mat3.fromQuat(scratch, q);\n  const m11 = m[0], m12 = m[3], m13 = m[6]; // prettier-ignore\n  const             m22 = m[4], m23 = m[7]; // prettier-ignore\n  const             m32 = m[5], m33 = m[8]; // prettier-ignore\n\n  out[1] = Math.asin(m13 < -1 ? -1 : m13 > 1 ? 1 : m13);\n  if (Math.abs(m13) < 0.99999) {\n    out[0] = Math.atan2(-m23, m33);\n    out[2] = Math.atan2(-m12, m11);\n  } else {\n    out[0] = Math.atan2(m32, m22);\n    out[2] = 0;\n  }\n  return (out: any);\n}\n","// @flow\n\n//  Copyright (c) 2018-present, GM Cruise LLC\n//\n//  This source code is licensed under the Apache License, Version 2.0,\n//  found in the LICENSE file in the root directory of this source tree.\n//  You may not use this file except in compliance with the License.\n\nimport type { ReglCommand, Vec3 } from \"../types\";\nimport { withPose, pointToVec3, defaultBlend, defaultDepth, shouldConvert, colorBuffer } from \"./commandUtils\";\n\n// Creates a regl command factory which will render any geometry described by point positions\n// and elements (indexes into the array of positions), and apply the object's pose, scale, and color to it.\nexport default (positions: Vec3[], elements: Vec3[]) => (regl: any): ReglCommand => {\n  const vertexArray = Float32Array.from([].concat(...positions));\n\n  if (elements.some((face) => face.some((i) => i < 0 || i >= 1 << 16))) {\n    throw new Error(\"Element index out of bounds for Uint16\");\n  }\n  const elementsArray = Uint16Array.from([].concat(...elements));\n\n  const buff = regl.buffer({\n    // tell the gpu this buffer's contents will change frequently\n    usage: \"dynamic\",\n    data: [],\n  });\n  const colorBuff = colorBuffer(regl);\n\n  return withPose({\n    vert: `\n    precision mediump float;\n    attribute vec3 point;\n    attribute vec3 offset;\n    attribute vec4 color;\n    uniform mat4 projection, view;\n    uniform vec3 scale;\n    varying vec4 vColor;\n\n    #WITH_POSE\n\n    void main () {\n      vec3 p = applyPose(scale * point) + offset;\n      vColor = color;\n      gl_Position = projection * view * vec4(p, 1);\n    }\n    `,\n    frag: `\n    precision mediump float;\n    varying vec4 vColor;\n    void main () {\n      gl_FragColor = vColor;\n    }`,\n\n    attributes: {\n      point: vertexArray,\n      color: (context, props) => {\n        return colorBuff(props.color, props.colors, props.points ? props.points.length : 1);\n      },\n\n      offset: (context, props) => {\n        const points = shouldConvert(props.points) ? props.points.map(pointToVec3) : props.points || [0, 0, 0];\n        return {\n          buffer: buff({\n            usage: \"dynamic\",\n            data: points,\n          }),\n          divisor: 1,\n        };\n      },\n    },\n\n    elements: elementsArray,\n\n    depth: defaultDepth,\n    blend: defaultBlend,\n\n    uniforms: {\n      scale: (context, props) => (shouldConvert(props.scale) ? pointToVec3(props.scale) : props.scale),\n    },\n\n    count: elementsArray.length,\n\n    instances: (context, props) => (props.points ? props.points.length : 1),\n  });\n};\n","// @flow\n\n//  Copyright (c) 2019-present, GM Cruise LLC\n//\n//  This source code is licensed under the Apache License, Version 2.0,\n//  found in the LICENSE file in the root directory of this source tree.\n//  You may not use this file except in compliance with the License.\n\ntype TypedArray = Int8Array | Uint8Array | Int16Array | Uint16Array | Uint32Array | Float32Array;\n\nexport type GLBModel = {\n  json: Object,\n  accessors?: TypedArray[],\n  images?: ImageBitmap[],\n};\n\n// Parse a GLB file: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0\n//\n// Returns an object containing the raw json data as well as parsed images (Image) and\n// accessors (TypedArray).\nexport default async function parseGLB(arrayBuffer: ArrayBuffer): Promise<GLBModel> {\n  const data = new DataView(arrayBuffer);\n  let offset = 0;\n\n  function readUint32() {\n    const value = data.getUint32(offset, true);\n    offset += 4;\n    return value;\n  }\n\n  // magic header\n  const magic = readUint32();\n  if (magic !== 0x46546c67) {\n    throw new Error(`incorrect magic value 0x${magic.toString(16)}`);\n  }\n\n  // Binary glTF version\n  const version = readUint32();\n  if (version !== 2) {\n    throw new Error(`incorrect version ${version}`);\n  }\n\n  // total file length\n  const totalLength = readUint32();\n  if (totalLength !== data.byteLength) {\n    throw new Error(`length ${totalLength} doesn't match response length ${data.byteLength}`);\n  }\n\n  function findNextChunkOfType(type) {\n    do {\n      const chunkLength = readUint32();\n      const chunkType = readUint32();\n      if (chunkType === type) {\n        const chunkData = new DataView(data.buffer, offset, chunkLength);\n        offset += chunkLength;\n        return chunkData;\n      }\n      offset += chunkLength;\n    } while (offset < totalLength);\n  }\n\n  const jsonData = findNextChunkOfType(/* JSON */ 0x4e4f534a);\n  if (!jsonData) {\n    throw new Error(\"no JSON chunk found\");\n  }\n\n  const json = JSON.parse(new TextDecoder().decode(jsonData));\n\n  const binary = findNextChunkOfType(/* BIN */ 0x004e4942);\n  if (!binary) {\n    return { json };\n  }\n\n  if (json.buffers[0].uri !== undefined) {\n    throw new Error(\"expected GLB-stored buffer\");\n  }\n\n  // create a TypedArray for each accessor\n  const accessors = json.accessors.map((accessorInfo) => {\n    let arrayType;\n    // prettier-ignore\n    switch (accessorInfo.componentType) {\n      case WebGLRenderingContext.BYTE: arrayType = Int8Array; break;\n      case WebGLRenderingContext.UNSIGNED_BYTE: arrayType = Uint8Array; break;\n      case WebGLRenderingContext.SHORT: arrayType = Int16Array; break;\n      case WebGLRenderingContext.UNSIGNED_SHORT: arrayType = Uint16Array; break;\n      case WebGLRenderingContext.UNSIGNED_INT: arrayType = Uint32Array; break;\n      case WebGLRenderingContext.FLOAT: arrayType = Float32Array; break;\n      default:\n        throw new Error(`unrecognized componentType ${accessorInfo.componentType}`);\n    }\n    let numComponents;\n    // prettier-ignore\n    switch (accessorInfo.type) {\n      case \"SCALAR\": numComponents = 1; break;\n      case \"VEC2\": numComponents = 2; break;\n      case \"VEC3\": numComponents = 3; break;\n      case \"VEC4\": numComponents = 4; break;\n      case \"MAT2\": numComponents = 4; break;\n      case \"MAT3\": numComponents = 9; break;\n      case \"MAT4\": numComponents = 16; break;\n      default:\n        throw new Error(`unrecognized type ${accessorInfo.type}`);\n    }\n    const bufferView = json.bufferViews[accessorInfo.bufferView];\n    if (bufferView.buffer !== 0) {\n      throw new Error(\"only GLB-stored buffers are supported\");\n    }\n    if (bufferView.byteLength % arrayType.BYTES_PER_ELEMENT !== 0) {\n      throw new Error(\"bufferView.byteLength mismatch\");\n    }\n    return new arrayType(\n      binary.buffer,\n      binary.byteOffset + (bufferView.byteOffset || 0) + (accessorInfo.byteOffset || 0),\n      accessorInfo.count * numComponents\n    );\n  });\n\n  // load embedded images\n  const images =\n    json.images &&\n    (await Promise.all(\n      json.images.map((imgInfo) => {\n        const bufferView = json.bufferViews[imgInfo.bufferView];\n        const data = new DataView(binary.buffer, binary.byteOffset + bufferView.byteOffset, bufferView.byteLength);\n        return self.createImageBitmap(new Blob([data], { type: imgInfo.mimeType }));\n      })\n    ));\n\n  return { json, accessors, images };\n}\n","// @flow\n\n//  Copyright (c) 2018-present, GM Cruise LLC\n//\n//  This source code is licensed under the Apache License, Version 2.0,\n//  found in the LICENSE file in the root directory of this source tree.\n//  You may not use this file except in compliance with the License.\n\nimport type { AssignNextColorsFn, MouseEventObject } from \"../types\";\n\nfunction nonInstancedGetChildrenForHitmapFromSingleProp<T: any>(\n  prop: T,\n  assignNextColors: AssignNextColorsFn,\n  excludedObjects: MouseEventObject[],\n  useOriginalMarkerProp: boolean = false\n): ?T {\n  // The marker that we send to event callbacks.\n  const eventCallbackMarker = useOriginalMarkerProp ? prop.originalMarker : prop;\n  if (excludedObjects.some(({ object }) => object === eventCallbackMarker)) {\n    return null;\n  }\n  const hitmapProp = { ...prop };\n  const [hitmapColor] = assignNextColors(eventCallbackMarker, 1);\n  hitmapProp.color = hitmapColor;\n  if (hitmapProp.colors && hitmapProp.points && hitmapProp.points.length) {\n    hitmapProp.colors = new Array(hitmapProp.points.length).fill(hitmapColor);\n  }\n  return hitmapProp;\n}\n\nexport const nonInstancedGetChildrenForHitmap = <T: any>(\n  props: T,\n  assignNextColors: AssignNextColorsFn,\n  excludedObjects: MouseEventObject[]\n): ?T => {\n  if (Array.isArray(props)) {\n    return props\n      .map((prop) => nonInstancedGetChildrenForHitmapFromSingleProp(prop, assignNextColors, excludedObjects))\n      .filter(Boolean);\n  }\n  return nonInstancedGetChildrenForHitmapFromSingleProp(props, assignNextColors, excludedObjects);\n};\n\n// Almost identical to nonInstancedGetChildrenForHitmap, but instead the object passed to event callbacks is the object\n// at `prop.originalMarker`, not just `prop`.\nexport const getChildrenForHitmapWithOriginalMarker = <T: any>(\n  props: T,\n  assignNextColors: AssignNextColorsFn,\n  excludedObjects: MouseEventObject[]\n) => {\n  if (Array.isArray(props)) {\n    return props\n      .map((prop) => nonInstancedGetChildrenForHitmapFromSingleProp(prop, assignNextColors, excludedObjects, true))\n      .filter(Boolean);\n  }\n  return nonInstancedGetChildrenForHitmapFromSingleProp(props, assignNextColors, excludedObjects, true);\n};\n\nfunction instancedGetChildrenForHitmapFromSingleProp<T: any>(\n  prop: T,\n  assignNextColors: AssignNextColorsFn,\n  excludedObjects: MouseEventObject[],\n  pointCountPerInstance\n): ?T {\n  const matchedExcludedObjects = excludedObjects.filter(({ object, instanceIndex }) => object === prop);\n  const filteredIndices = matchedExcludedObjects\n    .map(({ object, instanceIndex }) => instanceIndex)\n    .filter((instanceIndex) => typeof instanceIndex === \"number\");\n  const hitmapProp = { ...prop };\n  const instanceCount = (hitmapProp.points && Math.ceil(hitmapProp.points.length / pointCountPerInstance)) || 1;\n  // This returns 1 color per instance.\n  const idColors = assignNextColors(prop, instanceCount);\n  const startColor = idColors[0];\n  // We have to map these instance colors to `pointCountPerInstance` number of points\n  if (hitmapProp.points && hitmapProp.points.length) {\n    const allColors = new Array(hitmapProp.points.length).fill().map(() => startColor);\n    for (let i = 0; i < instanceCount; i++) {\n      for (let j = 0; j < pointCountPerInstance; j++) {\n        const idx = i * pointCountPerInstance + j;\n        if (idx < allColors.length) {\n          allColors[idx] = idColors[i];\n        }\n      }\n    }\n    hitmapProp.colors = allColors;\n    if (filteredIndices.length) {\n      hitmapProp.points = hitmapProp.points.filter(\n        (_, index) => !filteredIndices.includes(Math.floor(index / pointCountPerInstance))\n      );\n      hitmapProp.colors = hitmapProp.colors.filter(\n        (_, index) => !filteredIndices.includes(Math.floor(index / pointCountPerInstance))\n      );\n    } else if (matchedExcludedObjects.length) {\n      // if we don't have instance indices, just filter out the whole object.\n      return null;\n    }\n  } else {\n    hitmapProp.color = startColor;\n    if (matchedExcludedObjects.length) {\n      return null;\n    }\n  }\n  return hitmapProp;\n}\n\nexport const createInstancedGetChildrenForHitmap = (pointCountPerInstance: number) => <T: any>(\n  props: T,\n  assignNextColors: AssignNextColorsFn,\n  excludedObjects: MouseEventObject[]\n): ?T => {\n  if (Array.isArray(props)) {\n    return props\n      .map((prop) =>\n        instancedGetChildrenForHitmapFromSingleProp(prop, assignNextColors, excludedObjects, pointCountPerInstance)\n      )\n      .filter(Boolean);\n  }\n  return instancedGetChildrenForHitmapFromSingleProp(props, assignNextColors, excludedObjects, pointCountPerInstance);\n};\n","// @flow\n\n//  Copyright (c) 2018-present, GM Cruise LLC\n//\n//  This source code is licensed under the Apache License, Version 2.0,\n//  found in the LICENSE file in the root directory of this source tree.\n//  You may not use this file except in compliance with the License.\n\nimport * as React from \"react\";\n\nimport type { Cylinder } from \"../types\";\nimport fromGeometry from \"../utils/fromGeometry\";\nimport { createInstancedGetChildrenForHitmap } from \"../utils/getChildrenForHitmapDefaults\";\nimport Command, { type CommonCommandProps } from \"./Command\";\n\nexport function createCylinderGeometry(numSegments: number, cone: boolean) {\n  // \"poles\" are the centers of top/bottom faces\n  const northPole = [0, 0, 0.5];\n  const southPole = [0, 0, -0.5];\n\n  const points = [northPole, southPole];\n\n  // Keep side faces separate from top/bottom to improve appearance for semi-transparent colors.\n  // We don't have a good approach to transparency right now but this is a small improvement over mixing the faces.\n  const sideFaces = [];\n  const endCapFaces = [];\n\n  for (let i = 0; i < numSegments; i++) {\n    const theta = (2 * Math.PI * i) / numSegments;\n    const x = 0.5 * Math.cos(theta);\n    const y = 0.5 * Math.sin(theta);\n    points.push([x, y, 0.5], [x, y, -0.5]);\n\n    const bottomLeftPt = points.length - 1;\n    const topRightPt = cone ? 0 : i + 1 === numSegments ? 2 : points.length;\n    const bottomRightPt = i + 1 === numSegments ? 3 : points.length + 1;\n    sideFaces.push([bottomLeftPt, topRightPt, bottomRightPt]);\n    endCapFaces.push([bottomLeftPt, bottomRightPt, 1]);\n    if (!cone) {\n      const topLeftPt = points.length - 2;\n      sideFaces.push([topLeftPt, bottomLeftPt, topRightPt]);\n      endCapFaces.push([topLeftPt, topRightPt, 0]);\n    }\n  }\n  return { points, sideFaces, endCapFaces };\n}\n\nconst { points, sideFaces, endCapFaces } = createCylinderGeometry(30, false);\n\nconst cylinders = fromGeometry(points, sideFaces.concat(endCapFaces));\n\nconst getChildrenForHitmap = createInstancedGetChildrenForHitmap(1);\nexport default function Cylinders(props: { ...CommonCommandProps, children: Cylinder[] }) {\n  return <Command getChildrenForHitmap={getChildrenForHitmap} {...props} reglCommand={cylinders} />;\n}\n","// @flow\n\n//  Copyright (c) 2018-present, GM Cruise LLC\n//\n//  This source code is licensed under the Apache License, Version 2.0,\n//  found in the LICENSE file in the root directory of this source tree.\n//  You may not use this file except in compliance with the License.\n\nimport * as React from \"react\";\n\nimport type { Cone } from \"../types\";\nimport fromGeometry from \"../utils/fromGeometry\";\nimport { createInstancedGetChildrenForHitmap } from \"../utils/getChildrenForHitmapDefaults\";\nimport Command, { type CommonCommandProps } from \"./Command\";\nimport { createCylinderGeometry } from \"./Cylinders\";\n\nconst { points, sideFaces, endCapFaces } = createCylinderGeometry(30, true);\n\nconst cones = fromGeometry(points, sideFaces.concat(endCapFaces));\n\nconst getChildrenForHitmap = createInstancedGetChildrenForHitmap(1);\nexport default function Cones(props: { ...CommonCommandProps, children: Cone[] }) {\n  return <Command getChildrenForHitmap={getChildrenForHitmap} {...props} reglCommand={cones} />;\n}\n","// @flow\n\n//  Copyright (c) 2018-present, GM Cruise LLC\n//\n//  This source code is licensed under the Apache License, Version 2.0,\n//  found in the LICENSE file in the root directory of this source tree.\n//  You may not use this file except in compliance with the License.\n\nimport { vec3, quat } from \"gl-matrix\";\nimport omit from \"lodash/omit\";\nimport React, { memo, Fragment } from \"react\";\n\nimport type { Arrow } from \"../types\";\nimport { pointToVec3, vec3ToPoint, orientationToVec4, vec4ToOrientation } from \"../utils/commandUtils\";\nimport { getChildrenForHitmapWithOriginalMarker } from \"../utils/getChildrenForHitmapDefaults\";\nimport type { CommonCommandProps } from \"./Command\";\nimport Cones from \"./Cones\";\nimport Cylinders from \"./Cylinders\";\n\nconst UNIT_X_VECTOR = Object.freeze([0, 0, 1]);\n\ntype Props = {\n  ...CommonCommandProps,\n  children: Arrow[],\n};\n\nfunction Arrows(props: Props) {\n  const passedProps = omit(props, \"children\");\n  const cylinders = [];\n  const cones = [];\n  for (const marker of props.children) {\n    let shaftWidthX;\n    let shaftWidthY;\n    let shaftLength;\n    let headWidthX;\n    let headWidthY;\n    let headLength;\n\n    let basePosition;\n    let orientation;\n    let dir;\n    if (marker.points && marker.points.length === 2) {\n      const [start, end] = marker.points;\n      basePosition = [start.x, start.y, start.z];\n      const tipPosition = [end.x, end.y, end.z];\n      const length = vec3.distance(basePosition, tipPosition);\n\n      dir = vec3.subtract([0, 0, 0], tipPosition, basePosition);\n      vec3.normalize(dir, dir);\n      orientation = quat.rotationTo([0, 0, 0, 0], UNIT_X_VECTOR, dir);\n\n      headWidthX = headWidthY = marker.scale.y;\n      headLength = marker.scale.z || length * 0.3;\n      shaftWidthX = shaftWidthY = marker.scale.x;\n      shaftLength = length - headLength;\n    } else {\n      basePosition = pointToVec3(marker.pose.position);\n      orientation = orientationToVec4(marker.pose.orientation);\n      quat.rotateY(orientation, orientation, Math.PI / 2);\n      dir = vec3.transformQuat([0, 0, 0], UNIT_X_VECTOR, orientation);\n\n      shaftWidthX = marker.scale.y || 1;\n      shaftWidthY = marker.scale.z || 1;\n      headWidthX = 2 * shaftWidthX;\n      headWidthY = 2 * shaftWidthY;\n\n      // these magic numbers taken from\n      // https://github.com/ros-visualization/rviz/blob/57325fa075893de70f234f4676cdd08b411858ff/src/rviz/default_plugin/markers/arrow_marker.cpp#L113\n      headLength = 0.23 * (marker.scale.x || 1);\n      shaftLength = 0.77 * (marker.scale.x || 1);\n    }\n\n    const shaftPosition = vec3.scaleAndAdd([0, 0, 0], basePosition, dir, shaftLength / 2);\n    const headPosition = vec3.scaleAndAdd([0, 0, 0], basePosition, dir, shaftLength + headLength / 2);\n\n    cylinders.push({\n      // Set the original marker so we can use it in mouse events\n      originalMarker: marker,\n      scale: { x: shaftWidthX, y: shaftWidthY, z: shaftLength },\n      color: marker.color,\n      pose: {\n        position: vec3ToPoint(shaftPosition),\n        orientation: vec4ToOrientation(orientation),\n      },\n    });\n    cones.push({\n      // Set the original marker so we can use it in mouse events\n      originalMarker: marker,\n      scale: { x: headWidthX, y: headWidthY, z: headLength },\n      color: marker.color,\n      pose: {\n        position: vec3ToPoint(headPosition),\n        orientation: vec4ToOrientation(orientation),\n      },\n    });\n  }\n\n  return (\n    <Fragment>\n      <Cylinders getChildrenForHitmap={getChildrenForHitmapWithOriginalMarker} {...passedProps}>\n        {cylinders}\n      </Cylinders>\n      <Cones getChildrenForHitmap={getChildrenForHitmapWithOriginalMarker} {...passedProps}>\n        {cones}\n      </Cones>\n    </Fragment>\n  );\n}\n\nexport default memo<Props>(Arrows);\n","// @flow\n\n//  Copyright (c) 2018-present, GM Cruise LLC\n//\n//  This source code is licensed under the Apache License, Version 2.0,\n//  found in the LICENSE file in the root directory of this source tree.\n//  You may not use this file except in compliance with the License.\n\nimport flatten from \"lodash/flatten\";\nimport * as React from \"react\";\n\nimport type { Line, Vec4, Color, Pose } from \"../types\";\nimport { defaultBlend, withPose, toRGBA, shouldConvert, pointToVec3 } from \"../utils/commandUtils\";\nimport { nonInstancedGetChildrenForHitmap } from \"../utils/getChildrenForHitmapDefaults\";\nimport Command, { type CommonCommandProps } from \"./Command\";\n\n/*\nTriangle-based line drawing.\n\n4 points (a strip of 2 triangles) are drawn for each segment of the line using instanced arrays.\nEach of the 4 points has a distinct \"point type\" which informs how the input point is offset to\nyield the vertices of the triangle.\n\nPassing the input point as an attribute with {divisor: 1} tells GL to use each point for 1 instance,\nthen move on to the next point -- something like `points.map((p) => draw2Triangles(p))`.\n\n4 attributes are used so the vertex shader can see 4 input points at once (reading from the same\nbuffer with different offsets). This is because the positions of the TL/BL endpoints depend on the\nangle ABC, and the positions of TR/BR depend on the angle BCD.\n\nRoughly the segment looks like:\n\n     TL   -   -   -  .TR\n      |          ,.-' |\nA - - B - - -,.-' - - C - - D\n      |  ,.-'         |\n     BL-' -   -   -   BR\n\nWhen two adjacent segments form an obtuse angle, we draw a miter join:\n\n                      TR/TL.\n                 , '   _/|   ' .\n             , '     _/  |       ' .\n         , '       _/    C           ' .\n     , '         _/      |               ' .\n   TL          _/        |        ______,----'TR\n    \\        _/       ,BR/BL.----'            /\n     B     _/    , '          ' .            D\n      \\  _/ , '                   ' .       /\n       BL'                            ' . BR\n\nBut when the angle gets too sharp, we switch to a \"fold\" join, where the two segments overlap at\nthe corner:\n\n        ,TR/BL---C--BR/TL\n       ,    |.\\__  ,     .\n      ,     | .  \\,_      .\n     ,      |  . ,  \\_     .\n    ,       |   ,     \\__   .\n   ,        |  , .       \\__ .\n  TL._      | ,   .        _.TR\n      'B._  |,     .   _.C'\n          'BL       BR'\n\n(A regular bevel join without any overlaps is harder to achieve without artifacts in the sharp-angle\nedge cases.)\n\n*/\n\nconst FLOAT_BYTES = Float32Array.BYTES_PER_ELEMENT;\nconst POINT_BYTES = 3 * FLOAT_BYTES;\nconst DEFAULT_MONOCHROME_COLOR = [1, 1, 1, 0.2];\n\n// The four points forming the triangles' vertices.\n// Values do not matter, they just need to be distinct.\nconst POINT_TYPES = { BL: 0, TR: 1, BR: 2, TL: 3 };\nconst VERTICES_PER_INSTANCE = Object.keys(POINT_TYPES).length;\n\nconst vert = `\nprecision mediump float;\n\nattribute float pointType;\n\n// per-instance attributes\nattribute vec4 colorB;\nattribute vec4 colorC;\nattribute vec3 positionA;\nattribute vec3 positionB;\nattribute vec3 positionC;\nattribute vec3 positionD;\n// per-instance pose attributes\nattribute vec3 posePosition;\nattribute vec4 poseRotation;\n\nuniform mat4 projection, view;\nuniform float viewportWidth;\nuniform float viewportHeight;\nuniform float alpha;\nuniform float thickness;\nuniform bool joined;\nuniform bool scaleInvariant;\n\nvarying vec4 vColor;\n\n${Object.keys(POINT_TYPES)\n  .map((k) => `const float POINT_${k} = ${POINT_TYPES[k]}.0;`)\n  .join(\"\\n\")}\n\n#WITH_POSE\n\nvec3 applyPoseInstance(vec3 point, vec4 rotation, vec3 position) {\n  // rotate the point and then add the position of the pose\n  // this function is defined in WITH_POSE\n  return rotate(point, rotation) + position;\n}\n\nvec2 rotateCCW(vec2 v) {\n  return vec2(-v.y, v.x);\n}\n\nvec2 normalizeOrZero(vec2 v) {\n  return length(v) < 0.00001 ? vec2(0, 0) : normalize(v);\n}\n\nvoid setPosition(vec4 proj, vec2 offset) {\n  gl_Position = proj;\n\n  offset *= thickness / 2.;\n\n  if (scaleInvariant) {\n    // The given thickness is a number of pixels on screen. Divide x by width/2 and\n    // y by height/2 so that they correspond to pixel distances when scaled from clip space to NDC.\n    offset.x /= viewportWidth / 2.0;\n    offset.y /= viewportHeight / 2.0;\n    // Compensate for automatic division by w\n    offset *= proj.w;\n  } else {\n    // The line thickness should be scaled the same way the camera scales other distances.\n    // projection[0].xyz is the result of projecting a unit x-vector, so its length represents\n    // how much distances are scaled by the camera projection.\n    offset *= length(projection[0].xyz);\n    offset.y *= viewportWidth / viewportHeight;\n  }\n\n  gl_Position.xy += offset;\n}\n\nvoid main () {\n  bool isStart = positionA == positionB;\n  bool isEnd = positionC == positionD;\n  bool isLeft = (pointType == POINT_TL || pointType == POINT_BL);\n  bool isTop = (pointType == POINT_TL || pointType == POINT_TR);\n  bool isEndpoint = isLeft ? isStart : isEnd;\n\n  float scale = isTop ? 1. : -1.;\n\n  mat4 projView = projection * view;\n  vec4 projA = projView * vec4(applyPose(applyPoseInstance(positionA, poseRotation, posePosition)), 1);\n  vec4 projB = projView * vec4(applyPose(applyPoseInstance(positionB, poseRotation, posePosition)), 1);\n  vec4 projC = projView * vec4(applyPose(applyPoseInstance(positionC, poseRotation, posePosition)), 1);\n  vec4 projD = projView * vec4(applyPose(applyPoseInstance(positionD, poseRotation, posePosition)), 1);\n\n  vec2 aspectVec = vec2(viewportWidth / viewportHeight, 1.0);\n  vec2 screenA = projA.xy / projA.w * aspectVec;\n  vec2 screenB = projB.xy / projB.w * aspectVec;\n  vec2 screenC = projC.xy / projC.w * aspectVec;\n  vec2 screenD = projD.xy / projD.w * aspectVec;\n\n  vec2 dirAB = normalizeOrZero(screenB - screenA);\n  vec2 dirBC = normalizeOrZero(screenC - screenB);\n  vec2 dirCD = normalizeOrZero(screenD - screenC);\n\n  vec2 perpAB = rotateCCW(dirAB); // vector perpendicular to AB\n  vec2 perpBC = rotateCCW(dirBC); // vector perpendicular to BC\n\n  vColor = isLeft ? colorB : colorC;\n  vColor.a *= alpha;\n\n  vec4 proj = isLeft ? projB : projC;\n\n  // simple case: non-joined line list\n  if (!joined || isEndpoint) {\n    setPosition(proj, scale * perpBC);\n    return;\n  }\n\n  // clamp to prevent rounding errors from breaking the sqrt()s below\n  float cosB = clamp(-dot(dirAB, dirBC), -1., 1.);\n  float cosC = clamp(-dot(dirBC, dirCD), -1., 1.);\n\n  bool tooSharpB = cosB > 0.01;\n  bool tooSharpC = cosC > 0.01;\n  bool tooSharp = isLeft ? tooSharpB : tooSharpC;\n\n  bool turningRightB = dot(dirAB, rotateCCW(dirBC)) > 0.;\n  bool turningRightC = dot(dirBC, rotateCCW(dirCD)) > 0.;\n  bool turningRight = isLeft ? turningRightB : turningRightC;\n\n  if (tooSharp) {\n    // \"fold join\"\n    vec2 perp = isLeft ? perpAB : perpBC;\n    vec2 dir = isLeft ? dirAB : dirBC;\n    float scalePerp = isLeft ? -1. : 1.;\n    float scaleDir = (turningRight == isLeft) ? 1. : -1.;\n    float tanHalfB = sqrt((1. - cosB) / (1. + cosB));\n    float tanHalfC = sqrt((1. - cosC) / (1. + cosC));\n    float tanHalf = isLeft ? tanHalfB : tanHalfC;\n    setPosition(proj, scale * (scalePerp * perp + scaleDir * dir * tanHalf));\n  } else {\n    // miter join\n    vec2 bisectorB = rotateCCW(normalize(dirAB + dirBC)); // angle bisector of ABC\n    vec2 bisectorC = rotateCCW(normalize(dirBC + dirCD)); // angle bisector of BCD\n    vec2 bisector = isLeft ? bisectorB : bisectorC;\n    float sinHalfB = sqrt((1. - cosB) / 2.);\n    float sinHalfC = sqrt((1. - cosC) / 2.);\n    float sinHalf = isLeft ? sinHalfB : sinHalfC;\n    setPosition(proj, scale * bisector / sinHalf);\n  }\n}\n`;\n\nconst frag = `\nprecision mediump float;\nvarying vec4 vColor;\nvoid main () {\n  gl_FragColor = vColor;\n}\n`;\n\nfunction pointsEqual(a, b) {\n  const [ax, ay, az] = shouldConvert(a) ? pointToVec3(a) : a;\n  const [bx, by, bz] = shouldConvert(b) ? pointToVec3(b) : b;\n  return ax === bx && ay === by && az === bz;\n}\n\nconst lines = (regl: any) => {\n  // The point type attribute, reused for each instance\n  const pointTypeBuffer = regl.buffer({\n    type: \"uint16\",\n    usage: \"static\",\n    data: [POINT_TYPES.TL, POINT_TYPES.BL, POINT_TYPES.TR, POINT_TYPES.BR],\n  });\n  const debugColorBuffer = regl.buffer({\n    type: \"float\",\n    usage: \"static\",\n    data: [\n      [0, 1, 1, 1], // cyan\n      [1, 0, 0, 1], // red\n      [0, 1, 0, 1], // green\n      [1, 0, 1, 1], // magenta\n    ],\n  });\n  // The pose position and rotation buffers contain the identity position/rotation, for use when we don't have instanced\n  // poses.\n  const defaultPosePositionBuffer = regl.buffer({\n    type: \"float\",\n    usage: \"static\",\n    data: flatten(new Array(VERTICES_PER_INSTANCE).fill([0, 0, 0])),\n  });\n  const defaultPoseRotationBuffer = regl.buffer({\n    type: \"float\",\n    usage: \"static\",\n    // Rotation array identity is [x: 0, y: 0, z: 0, w: 1]\n    data: flatten(new Array(VERTICES_PER_INSTANCE).fill([0, 0, 0, 1])),\n  });\n\n  // The buffers used for input position & color data\n  const colorBuffer = regl.buffer({ type: \"float\" });\n\n  // All invocations of the vertex shader share data from the positions buffer, but with different\n  // offsets. However, when offset and stride are combined, 3 or 4 attributes reading from the same\n  // buffer produces incorrect results on certain Lenovo hardware running Ubuntu. As a workaround,\n  // we upload the same data into two buffers and have only two attributes reading from each buffer.\n  const positionBuffer1 = regl.buffer({ type: \"float\" });\n  const positionBuffer2 = regl.buffer({ type: \"float\" });\n\n  const posePositionBuffer = regl.buffer({ type: \"float\" });\n  const poseRotationBuffer = regl.buffer({ type: \"float\" });\n\n  const command = regl(\n    withPose({\n      vert,\n      frag,\n      blend: defaultBlend,\n      uniforms: {\n        thickness: regl.prop(\"scale.x\"),\n        viewportWidth: regl.context(\"viewportWidth\"),\n        viewportHeight: regl.context(\"viewportHeight\"),\n        alpha: regl.prop(\"alpha\"),\n        joined: regl.prop(\"joined\"),\n        scaleInvariant: regl.prop(\"scaleInvariant\"),\n      },\n      attributes: {\n        pointType: pointTypeBuffer,\n        colorB: (context, { joined, monochrome, debug }) => ({\n          buffer: debug ? debugColorBuffer : colorBuffer,\n          offset: 0,\n          stride: (joined || monochrome || debug ? 1 : 2) * 4 * FLOAT_BYTES,\n          divisor: monochrome || debug ? 0 : 1,\n        }),\n        colorC: (context, { joined, monochrome, debug }) => ({\n          buffer: debug ? debugColorBuffer : colorBuffer,\n          offset: monochrome || debug ? 0 : 4 * FLOAT_BYTES,\n          stride: (joined || monochrome || debug ? 1 : 2) * 4 * FLOAT_BYTES,\n          divisor: monochrome || debug ? 0 : 1,\n        }),\n        positionA: (context, { joined }) => ({\n          buffer: positionBuffer1,\n          offset: 0,\n          stride: (joined ? 1 : 2) * POINT_BYTES,\n          divisor: 1,\n        }),\n        positionB: (context, { joined }) => ({\n          buffer: positionBuffer1,\n          offset: POINT_BYTES,\n          stride: (joined ? 1 : 2) * POINT_BYTES,\n          divisor: 1,\n        }),\n        positionC: (context, { joined }) => ({\n          buffer: positionBuffer2,\n          offset: 2 * POINT_BYTES,\n          stride: (joined ? 1 : 2) * POINT_BYTES,\n          divisor: 1,\n        }),\n        positionD: (context, { joined }) => ({\n          buffer: positionBuffer2,\n          offset: 3 * POINT_BYTES,\n          stride: (joined ? 1 : 2) * POINT_BYTES,\n          divisor: 1,\n        }),\n        posePosition: (context, { hasInstancedPoses }) => ({\n          buffer: hasInstancedPoses ? posePositionBuffer : defaultPosePositionBuffer,\n          divisor: hasInstancedPoses ? 1 : 0,\n        }),\n        poseRotation: (context, { hasInstancedPoses }) => ({\n          buffer: hasInstancedPoses ? poseRotationBuffer : defaultPoseRotationBuffer,\n          divisor: hasInstancedPoses ? 1 : 0,\n        }),\n      },\n      count: VERTICES_PER_INSTANCE,\n      instances: regl.prop(\"instances\"),\n      primitive: regl.prop(\"primitive\"),\n    })\n  );\n\n  let colorArray = new Float32Array(VERTICES_PER_INSTANCE * 4);\n  let pointArray = new Float32Array(0);\n  let allocatedPoints = 0;\n  let positionArray = new Float32Array(0);\n  let rotationArray = new Float32Array(0);\n\n  function fillPointArray(points: any[], alreadyClosed: boolean, shouldClose: boolean) {\n    const numTotalPoints = points.length + (shouldClose ? 3 : 2);\n    if (allocatedPoints < numTotalPoints) {\n      pointArray = new Float32Array(numTotalPoints * 3);\n      allocatedPoints = numTotalPoints;\n    }\n    points.forEach((point, i) => {\n      const [x, y, z] = shouldConvert(point) ? pointToVec3(point) : point;\n      const off = 3 + i * 3;\n      pointArray[off + 0] = x;\n      pointArray[off + 1] = y;\n      pointArray[off + 2] = z;\n    });\n\n    // The \"prior\" point (A) and \"next\" point (D) need to be set when rendering the first & last\n    // segments, so we copy data from the last point(s) to the beginning of the array, and from the\n    // first point(s) to the end of the array.\n    const n = numTotalPoints * 3;\n    if (alreadyClosed) {\n      // First and last points already match; \"prior\" should be the second-to-last\n      // and \"next\" should be the second.\n      pointArray.copyWithin(0, n - 9, n - 6);\n      pointArray.copyWithin(n - 3, 6, 9);\n    } else if (shouldClose) {\n      // First point is being reused after last point; first *two* points need to be copied at the end\n      pointArray.copyWithin(0, n - 9, n - 6);\n      pointArray.copyWithin(n - 6, 3, 9);\n    } else {\n      // Endpoints are separate; just duplicate first & last points, resulting in square-looking endcaps\n      pointArray.copyWithin(0, 3, 6);\n      pointArray.copyWithin(n - 3, n - 6, n - 3);\n    }\n  }\n\n  function fillPoseArrays(instances: number, poses: Pose[]): ?Error {\n    if (positionArray.length < instances * 3) {\n      positionArray = new Float32Array(instances * 3);\n      rotationArray = new Float32Array(instances * 4);\n    }\n    for (let index = 0; index < poses.length; index++) {\n      const positionOffset = index * 3;\n      const rotationOffset = index * 4;\n      const { position, orientation: r } = poses[index];\n      const convertedPosition = Array.isArray(position) ? position : pointToVec3(position);\n      positionArray[positionOffset + 0] = convertedPosition[0];\n      positionArray[positionOffset + 1] = convertedPosition[1];\n      positionArray[positionOffset + 2] = convertedPosition[2];\n\n      const convertedRotation = Array.isArray(r) ? r : [r.x, r.y, r.z, r.w];\n      rotationArray[rotationOffset + 0] = convertedRotation[0];\n      rotationArray[rotationOffset + 1] = convertedRotation[1];\n      rotationArray[rotationOffset + 2] = convertedRotation[2];\n      rotationArray[rotationOffset + 3] = convertedRotation[3];\n    }\n  }\n\n  function convertColors(colors: any): Vec4[] {\n    return shouldConvert(colors) ? colors.map(toRGBA) : colors;\n  }\n\n  function fillColorArray(\n    color: ?Color | ?Vec4,\n    colors: ?((Color | Vec4)[]),\n    monochrome: boolean,\n    shouldClose: boolean\n  ) {\n    if (monochrome) {\n      if (colorArray.length < VERTICES_PER_INSTANCE * 4) {\n        colorArray = new Float32Array(VERTICES_PER_INSTANCE * 4);\n      }\n      const monochromeColor = color || DEFAULT_MONOCHROME_COLOR;\n      const [convertedMonochromeColor] = convertColors([monochromeColor]);\n      const [r, g, b, a] = convertedMonochromeColor;\n      for (let index = 0; index < VERTICES_PER_INSTANCE; index++) {\n        const offset = index * 4;\n        colorArray[offset + 0] = r;\n        colorArray[offset + 1] = g;\n        colorArray[offset + 2] = b;\n        colorArray[offset + 3] = a;\n      }\n    } else if (colors) {\n      const length = shouldClose ? colors.length + 1 : colors.length;\n      if (colorArray.length < length * 4) {\n        colorArray = new Float32Array(length * 4);\n      }\n      const convertedColors = convertColors(colors);\n      for (let index = 0; index < convertedColors.length; index++) {\n        const offset = index * 4;\n        const [r, g, b, a] = convertedColors[index];\n        colorArray[offset + 0] = r;\n        colorArray[offset + 1] = g;\n        colorArray[offset + 2] = b;\n        colorArray[offset + 3] = a;\n      }\n\n      if (shouldClose) {\n        const [r, g, b, a] = convertedColors[0];\n        const lastIndex = length - 1;\n        colorArray[lastIndex * 4 + 0] = r;\n        colorArray[lastIndex * 4 + 1] = g;\n        colorArray[lastIndex * 4 + 2] = b;\n        colorArray[lastIndex * 4 + 3] = a;\n      }\n    }\n  }\n\n  // Disable depth for debug rendering (so lines stay visible)\n  const render = (debug, commands) => {\n    if (debug) {\n      regl({ depth: { enable: false } })(commands);\n    } else {\n      commands();\n    }\n  };\n\n  // Render one line list/strip\n  function renderLine(props) {\n    const { debug, primitive = \"lines\", scaleInvariant = false } = props;\n    const numInputPoints = props.points.length;\n\n    if (numInputPoints < 2) {\n      return;\n    }\n\n    const alreadyClosed = numInputPoints > 2 && pointsEqual(props.points[0], props.points[numInputPoints - 1]);\n    // whether the first point needs to be duplicated after the last point\n    const shouldClose = !alreadyClosed && props.closed;\n\n    fillPointArray(props.points, alreadyClosed, shouldClose);\n    positionBuffer1({ data: pointArray, usage: \"dynamic\" });\n    positionBuffer2({ data: pointArray, usage: \"dynamic\" });\n\n    const monochrome = !(props.colors && props.colors.length);\n    fillColorArray(props.color, props.colors, monochrome, shouldClose);\n    colorBuffer({ data: colorArray, usage: \"dynamic\" });\n\n    const joined = primitive === \"line strip\";\n    const effectiveNumPoints = numInputPoints + (shouldClose ? 1 : 0);\n    const instances = joined ? effectiveNumPoints - 1 : Math.floor(effectiveNumPoints / 2);\n\n    // fill instanced pose buffers\n    const { poses } = props;\n    const hasInstancedPoses = !!poses && poses.length > 0;\n    if (hasInstancedPoses && poses) {\n      if (instances !== poses.length) {\n        console.error(`Expected ${instances} poses but given ${poses.length} poses: will result in webgl error.`);\n        return;\n      }\n      fillPoseArrays(instances, poses);\n      posePositionBuffer({ data: positionArray, usage: \"dynamic\" });\n      poseRotationBuffer({ data: rotationArray, usage: \"dynamic\" });\n    }\n\n    render(debug, () => {\n      // Use Object.assign because it's actually faster than babel's object spread polyfill.\n      command(\n        Object.assign({}, props, {\n          joined,\n          primitive: \"triangle strip\",\n          alpha: debug ? 0.2 : 1,\n          monochrome,\n          instances,\n          scaleInvariant,\n          hasInstancedPoses,\n        })\n      );\n      if (debug) {\n        command(\n          Object.assign({}, props, {\n            joined,\n            primitive: \"line strip\",\n            alpha: 1,\n            monochrome,\n            instances,\n            scaleInvariant,\n            hasInstancedPoses,\n          })\n        );\n      }\n    });\n  }\n\n  return (inProps: any) => {\n    if (Array.isArray(inProps)) {\n      inProps.forEach(renderLine);\n    } else {\n      renderLine(inProps);\n    }\n  };\n};\n\nexport default function Lines(props: { ...CommonCommandProps, children: Line[] }) {\n  return <Command getChildrenForHitmap={nonInstancedGetChildrenForHitmap} {...props} reglCommand={lines} />;\n}\n","// @flow\n\n//  Copyright (c) 2018-present, GM Cruise LLC\n//\n//  This source code is licensed under the Apache License, Version 2.0,\n//  found in the LICENSE file in the root directory of this source tree.\n//  You may not use this file except in compliance with the License.\n\nimport React from \"react\";\n\nimport type { Point, Vec3, Line } from \"../types\";\nimport Lines from \"./Lines\";\n\nconst pointToVec3 = (p: Vec3): Point => ({\n  x: p[0],\n  y: p[1],\n  z: p[2],\n});\n\nconst scale = 100;\nconst x = 1 * scale;\nconst xAxisPoints = [[-x, 0, 0], [x, 0, 0]].map(pointToVec3);\nconst yAxisPoints = [[0, -100, 0], [0, 100, 0]].map(pointToVec3);\nconst zAxisPoints = [[0, 0, -100], [0, 0, 100]].map(pointToVec3);\nconst pose = {\n  orientation: { x: 0, y: 0, z: 0, w: 0 },\n  position: { x: 0, y: 0, z: 0 },\n};\nconst xAxis = {\n  pose,\n  points: xAxisPoints,\n  scale: { x: 0.5, y: 0.5, z: 0.5 },\n  color: { r: 0.95, g: 0.26, b: 0.4, a: 1 },\n};\nconst yAxis = {\n  pose,\n  points: yAxisPoints,\n  scale: { x: 0.5, y: 0.5, z: 0.5 },\n  color: { r: 0.02, g: 0.82, b: 0.49, a: 1 },\n};\nconst zAxis = {\n  pose,\n  points: zAxisPoints,\n  scale: { x: 0.5, y: 0.5, z: 0.5 },\n  color: { r: 0.11, g: 0.51, b: 0.92, a: 1 },\n};\n\ntype Axis = Line;\n\ntype Props = {\n  children: Axis[],\n};\n\n// Renders lines along the x, y, and z axes; useful for debugging.\nexport default class Axes extends React.Component<Props> {\n  static defaultProps: Props = {\n    children: [xAxis, yAxis, zAxis],\n  };\n\n  render() {\n    return <Lines>{this.props.children}</Lines>;\n  }\n}\n","// @flow\n\n//  Copyright (c) 2018-present, GM Cruise LLC\n//\n//  This source code is licensed under the Apache License, Version 2.0,\n//  found in the LICENSE file in the root directory of this source tree.\n//  You may not use this file except in compliance with the License.\n\nimport * as React from \"react\";\n\nimport type { Cube } from \"../types\";\nimport fromGeometry from \"../utils/fromGeometry\";\nimport { createInstancedGetChildrenForHitmap } from \"../utils/getChildrenForHitmapDefaults\";\nimport Command, { type CommonCommandProps } from \"./Command\";\n\nconst cubes = fromGeometry(\n  [\n    // bottom face corners\n    [-0.5, -0.5, -0.5],\n    [-0.5, 0.5, -0.5],\n    [0.5, -0.5, -0.5],\n    [0.5, 0.5, -0.5],\n    // top face corners\n    [-0.5, -0.5, 0.5],\n    [-0.5, 0.5, 0.5],\n    [0.5, -0.5, 0.5],\n    [0.5, 0.5, 0.5],\n  ],\n  [\n    // bottom\n    [0, 1, 2],\n    [1, 2, 3],\n    // top\n    [4, 5, 6],\n    [5, 6, 7],\n    // left\n    [0, 2, 4],\n    [2, 4, 6],\n    // right\n    [1, 3, 5],\n    [3, 5, 7],\n    //front\n    [2, 3, 6],\n    [3, 6, 7],\n    //back\n    [0, 1, 4],\n    [1, 4, 5],\n  ]\n);\n\nconst getChildrenForHitmap = createInstancedGetChildrenForHitmap(1);\nexport default function Cubes(props: { ...CommonCommandProps, children: Cube[] }) {\n  return <Command getChildrenForHitmap={getChildrenForHitmap} {...props} reglCommand={cubes} />;\n}\n","// @flow\n\n//  Copyright (c) 2018-present, GM Cruise LLC\n//\n//  This source code is licensed under the Apache License, Version 2.0,\n//  found in the LICENSE file in the root directory of this source tree.\n//  You may not use this file except in compliance with the License.\n\nimport * as React from \"react\";\n\nimport type { SphereList } from \"../types\";\nimport fromGeometry from \"../utils/fromGeometry\";\nimport { createInstancedGetChildrenForHitmap } from \"../utils/getChildrenForHitmapDefaults\";\nimport Command, { type CommonCommandProps } from \"./Command\";\n\nconst NUM_PARALLELS = 15;\nconst NUM_MERIDIANS = 15;\nconst RADIUS = 0.5;\n\nconst northPole = [0, 0, RADIUS];\nconst southPole = [0, 0, -RADIUS];\nconst points = [northPole, southPole];\nconst faces = [];\n\nfor (let i = 0; i < NUM_PARALLELS; i++) {\n  for (let j = 0; j < NUM_MERIDIANS; j++) {\n    const phi = ((i + 1) / (NUM_PARALLELS + 1)) * Math.PI;\n    const z = RADIUS * Math.cos(phi);\n    const width = RADIUS * Math.sin(phi);\n    const theta = (j * 2 * Math.PI) / NUM_MERIDIANS;\n    const x = width * Math.cos(theta);\n    const y = width * Math.sin(theta);\n    points.push([x, y, z]);\n    if (j > 0) {\n      // connect to previous parallel (or north pole)\n      const prevMeridianPt = i === 0 ? 0 : points.length - 1 - NUM_MERIDIANS;\n      faces.push([points.length - 2, points.length - 1, prevMeridianPt]);\n      if (i > 0) {\n        faces.push([points.length - 2, prevMeridianPt - 1, prevMeridianPt]);\n      }\n    }\n  }\n  // connect to previous parallel (or north pole)\n  const prevMeridianPt = i === 0 ? 0 : points.length - 2 * NUM_MERIDIANS;\n  faces.push([points.length - 1, points.length - NUM_MERIDIANS, prevMeridianPt]);\n  if (i > 0) {\n    faces.push([points.length - 1, points.length - NUM_MERIDIANS - 1, prevMeridianPt]);\n  }\n}\n// connect last parallel to south pole\nfor (let j = 0; j < NUM_MERIDIANS; j++) {\n  const pt = points.length - NUM_MERIDIANS + j;\n  const prevPt = j === 0 ? points.length - 1 : pt - 1;\n  faces.push([pt, prevPt, 1]);\n}\n\nconst spheres = fromGeometry(points, faces);\n\nconst getChildrenForHitmap = createInstancedGetChildrenForHitmap(1);\nexport default function Spheres(props: { ...CommonCommandProps, children: SphereList[] }) {\n  return <Command getChildrenForHitmap={getChildrenForHitmap} {...props} reglCommand={spheres} />;\n}\n","// @flow\n\n//  Copyright (c) 2019-present, GM Cruise LLC\n//\n//  This source code is licensed under the Apache License, Version 2.0,\n//  found in the LICENSE file in the root directory of this source tree.\n//  You may not use this file except in compliance with the License.\n\nimport React from \"react\";\n\nimport type { Line, Point, Vec3, Scale, GetChildrenForHitmap, SphereList } from \"../../types\";\nimport { vec4ToRGBA, vec3ToPoint } from \"../../utils/commandUtils\";\nimport Lines from \"../Lines\";\nimport Spheres from \"../Spheres\";\n\nexport function multiplyScale(scale: Scale, factor: number): Scale {\n  return { x: scale.x * factor, y: scale.y * factor, z: scale.z * factor };\n}\n\nexport const DEFAULT_COLOR = [1, 1, 1, 1];\nexport const ACTIVE_POLYGON_COLOR = [0.8, 0, 0.8, 1];\nexport const ACTIVE_POINT_COLOR = [1, 0.2, 1, 1];\nexport const LINE_STRIP = \"line strip\";\nconst POINT_SIZE_FACTOR = 1.3;\nexport const DRAW_SCALE = { x: 0.1, y: 0.1, z: 0.1 };\nexport const DRAW_POINT_SCALE = multiplyScale(DRAW_SCALE, POINT_SIZE_FACTOR);\nexport const HITMAP_SCALE = { x: 0.5, y: 0.5, z: 0.5 };\nexport const HITMAP_POINT_SCALE = multiplyScale(HITMAP_SCALE, POINT_SIZE_FACTOR);\nexport const POSE = {\n  position: { x: 0, y: 0, z: 0 },\n  orientation: { x: 0, y: 0, z: 0, w: 0 },\n};\n\nlet count = 1;\n\nexport class PolygonPoint {\n  id: number;\n  point: Vec3;\n  active: boolean = false;\n\n  constructor(points: Vec3) {\n    this.id = count++;\n    this.point = points;\n  }\n}\n\nexport class Polygon {\n  id: number;\n  name: string;\n  points: PolygonPoint[] = [];\n  active: boolean = false;\n\n  constructor(name: string = \"\") {\n    this.name = name;\n    this.id = count++;\n  }\n}\n\nexport type DrawPolygonType = Polygon;\n\ntype Props = {\n  children: DrawPolygonType[],\n};\n\nconst polygonLinesGetChildrenForHitmap: GetChildrenForHitmap = <T: any>(\n  props: T,\n  assignNextColors,\n  excludedObjects\n) => {\n  // This is almost identical to the default nonInstancedGetChildrenForHitmap, with changes marked.\n  return props\n    .map((prop) => {\n      if (excludedObjects.some(({ object }) => object === prop)) {\n        return null;\n      }\n      const hitmapProp = { ...prop };\n      // Change from original: pass the original marker as a callback object instead of this marker.\n      const [hitmapColor] = assignNextColors(prop.originalMarker, 1);\n      // Change from original: increase scale for hitmap\n      hitmapProp.scale = HITMAP_SCALE;\n\n      hitmapProp.color = hitmapColor;\n      if (hitmapProp.colors && hitmapProp.points && hitmapProp.points.length) {\n        hitmapProp.colors = new Array(hitmapProp.points.length).fill(hitmapColor);\n      }\n      return hitmapProp;\n    })\n    .filter(Boolean);\n};\n\n/**\n * Draw the polygon lines\n */\nclass PolygonLines extends React.Component<Props> {\n  render() {\n    const polygons = this.props.children;\n    const lines: Line[] = [];\n    for (const poly of polygons) {\n      const color = poly.active ? ACTIVE_POLYGON_COLOR : DEFAULT_COLOR;\n      const points: (Point | Vec3)[] = poly.points.map(({ point }) => vec3ToPoint(point));\n\n      lines.push({\n        primitive: LINE_STRIP,\n        pose: POSE,\n        points,\n        scale: DRAW_SCALE,\n        color: vec4ToRGBA(color),\n        originalMarker: poly,\n      });\n    }\n\n    return <Lines getChildrenForHitmap={polygonLinesGetChildrenForHitmap}>{lines}</Lines>;\n  }\n}\n\nconst polygonPointsGetChildrenForHitmap: GetChildrenForHitmap = <T: any>(\n  props: T,\n  assignNextColors,\n  excludedObjects\n) => {\n  // This is similar to the default nonInstancedGetChildrenForHitmap, with changes marked.\n  return props\n    .map((prop) => {\n      if (excludedObjects.some(({ object }) => object === prop)) {\n        return null;\n      }\n      const hitmapProp = { ...prop };\n      // Change from original: assign a non-instanced color to each point color, even though this marker uses\n      // instancing.\n      // This is so that we can have a unique callback object for each point.\n      hitmapProp.colors = hitmapProp.colors.map((color, index) => {\n        return assignNextColors(prop.originalMarkers[index], 1);\n      });\n      // Change from original: increase scale for hitmap\n      hitmapProp.scale = HITMAP_POINT_SCALE;\n      return hitmapProp;\n    })\n    .filter(Boolean);\n};\n\n/**\n * Draw the polygon points at the end of each lines\n */\nclass PolygonPoints extends React.Component<Props> {\n  render() {\n    const polygons = this.props.children;\n    const points = [];\n    const colors = [];\n    const originalMarkers = [];\n\n    for (const poly of polygons) {\n      const color = poly.active ? ACTIVE_POLYGON_COLOR : DEFAULT_COLOR;\n      for (const point of poly.points) {\n        const convertedPoint = vec3ToPoint(point.point);\n        points.push(convertedPoint);\n        colors.push(point.active ? ACTIVE_POINT_COLOR : color);\n        originalMarkers.push(point);\n      }\n    }\n\n    const sphereList: SphereList = {\n      points,\n      colors,\n      pose: POSE,\n      scale: DRAW_POINT_SCALE,\n      originalMarkers,\n    };\n\n    return <Spheres getChildrenForHitmap={polygonPointsGetChildrenForHitmap}>{[sphereList]}</Spheres>;\n  }\n}\n\nexport default function DrawPolygons({ children: polygons = [] }: Props) {\n  if (polygons.length === 0) {\n    return null;\n  }\n\n  return (\n    <React.Fragment>\n      <PolygonLines>{polygons}</PolygonLines>\n      <PolygonPoints>{polygons}</PolygonPoints>\n    </React.Fragment>\n  );\n}\n","// @flow\n\n//  Copyright (c) 2019-present, GM Cruise LLC\n//\n//  This source code is licensed under the Apache License, Version 2.0,\n//  found in the LICENSE file in the root directory of this source tree.\n//  You may not use this file except in compliance with the License.\n\nimport distance from \"distance-to-line-segment\";\n\nimport type { Vec3, MouseHandler } from \"../../types\";\nimport { PolygonPoint, Polygon } from \"./index\";\n\ntype OptionalZPoint = {\n  x: number,\n  y: number,\n  z?: number,\n};\n\ntype PolygonAddCommand = {\n  points: OptionalZPoint[],\n  name?: string,\n};\n\nfunction areEqual(point1: PolygonPoint, point2: PolygonPoint) {\n  const [x1, y1, z1] = point1.point;\n  const [x2, y2, z2] = point2.point;\n  return x1 === x2 && y1 === y2 && z1 === z2;\n}\n\nfunction isClosed(polygon: Polygon): boolean {\n  const { points } = polygon;\n  for (let i = 0; i < points.length - 1; i++) {\n    if (areEqual(points[i], points[i + 1])) {\n      return true;\n    }\n  }\n  const firstPoint = points[0];\n  const lastPoint = points[points.length - 1];\n  return areEqual(firstPoint, lastPoint);\n}\n\n// Has listeners you can pass to Worldview for mouse interactions\n// internally builds a list of polygons and modifies the polygons\n// based on mouse & keyboard interactions. For now we use mututation internally\n// instead of immutability to keep the number of allocations lower and make\n// the implementation a bit more straightforward\n\nexport default class PolygonBuilder {\n  mouseDown: boolean = false;\n  polygons: Polygon[];\n  onChange: () => void = () => {};\n  activePolygon: ?Polygon;\n  activePoint: ?PolygonPoint;\n  mouseDownPoint: Vec3;\n\n  constructor(polygons: Polygon[] = []) {\n    this.polygons = polygons;\n  }\n\n  isActivePolygonClosed(): boolean {\n    return !!this.activePolygon && isClosed(this.activePolygon);\n  }\n\n  // adds a polygon to the builder, transforming it into the internal representation\n  addPolygon(cmd: PolygonAddCommand): void {\n    const { points, name } = cmd;\n    if (points.length < 3) {\n      return;\n    }\n    // clear any selections\n    this.selectObject();\n\n    const polygon = new Polygon(name);\n    polygon.points = points.map((p) => new PolygonPoint([p.x, p.y, p.z || 0]));\n    if (!isClosed(polygon)) {\n      polygon.points.push(polygon.points[0]);\n    }\n    this.polygons.push(polygon);\n  }\n\n  // push a new point - either adds to the active polygon\n  // or creates a new polygon at this point\n  pushPoint(point: Vec3): void {\n    const { activePolygon } = this;\n    if (activePolygon) {\n      // do not push a point on a closed polygon\n      if (!isClosed(activePolygon)) {\n        const newPoint = new PolygonPoint(point);\n        activePolygon.points.push(newPoint);\n        this.selectObject(newPoint);\n        return;\n      }\n    }\n\n    const polygon = new Polygon();\n    polygon.points.push(new PolygonPoint(point));\n    const floatingPoint = new PolygonPoint(point);\n    polygon.points.push(floatingPoint);\n    this.polygons.push(polygon);\n    this.selectObject(floatingPoint);\n    this.onChange();\n  }\n\n  // updates the active point to the new position\n  updateActivePoint(point: Vec3): void {\n    if (this.activePoint) {\n      this.activePoint.point = point;\n      this.onChange();\n    }\n  }\n\n  // closes the active polygon by either deleting it if\n  // is only 2 points (no \"single sided\" polygons...)\n  // or inserts an 'overlap' point by making the first point\n  // and last point a reference to the same point in the list\n  // this structure of overlap is similar to the structure used by geoJSON\n  // though \"left to right\" ordering is not enforced\n  closeActivePolygon(): void {\n    const polygon = this.activePolygon;\n    if (!polygon) {\n      return;\n    }\n\n    // remove single lines\n    if (polygon.points.length === 2) {\n      this.deletePolygon(polygon);\n    } else {\n      polygon.points.push(polygon.points[0]);\n    }\n    this.onChange();\n  }\n\n  // mouse move handler - should be added to Worldview as a prop\n  onMouseMove: MouseHandler = (e, args) => {\n    // prevent the camera from responding to move if we\n    // have an active object being edited\n    if (this.activePolygon) {\n      e.preventDefault();\n      e.stopPropagation();\n    }\n    //const cursor = e.ctrlKey ? 'crosshair' : '';\n    //document.body.style.cursor = cursor;\n\n    if (!this.mouseDown) {\n      return;\n    }\n    if (!args) {\n      return;\n    }\n\n    // early return to only raycast when mouse moves during interaction\n    if (!this.activePoint && !this.activePolygon) {\n      return;\n    }\n\n    const { ray } = args;\n    const point = ray.planeIntersection([0, 0, 0], [0, 0, 1]);\n    // satisfy flow\n    if (!point) {\n      return;\n    }\n\n    // satisfy flow\n    const { activePolygon } = this;\n\n    if (this.activePoint) {\n      this.updateActivePoint(point);\n    } else if (activePolygon && this.mouseDownPoint) {\n      // move polygon\n      const [pointX, pointY] = point;\n      const [mouseX, mouseY] = this.mouseDownPoint;\n      // figure out how far the mouse has moved\n      const dX = pointX - mouseX;\n      const dY = pointY - mouseY;\n\n      // save the new mouse position as for the next computation\n      this.mouseDownPoint = point;\n\n      // only update the 'overlap' point once\n      const uniquePoints = activePolygon.points.reduce((acc, point) => {\n        if (!acc.includes(point)) {\n          acc.push(point);\n        }\n        return acc;\n      }, []);\n\n      // adjust each point's location\n      for (const polygonPoint of uniquePoints) {\n        const { point } = polygonPoint;\n        point[0] = point[0] + dX;\n        point[1] = point[1] + dY;\n      }\n\n      this.onChange();\n    }\n  };\n\n  // deletes a polygon\n  deletePolygon(polygon: Polygon): void {\n    this.polygons = this.polygons.filter((poly) => poly !== polygon);\n    this.activePolygon = null;\n  }\n\n  // deletes a point in the active polygon\n  // if the point is the 'overlap point' create a new one\n  // also deletes the entire polygon if the polygon becomes a 1-sided polygon\n  deletePoint(point: PolygonPoint): void {\n    const { activePolygon } = this;\n    if (!activePolygon) {\n      return;\n    }\n    const newPoints = activePolygon.points.filter((p) => p.id !== point.id);\n    // if the 'overlap' point is deleted, create a new start/end overlap point\n    if (newPoints.length === activePolygon.points.length - 2) {\n      newPoints.push(newPoints[0]);\n    }\n    activePolygon.points = newPoints;\n    this.activePoint = null;\n    if (activePolygon.points.length < 4) {\n      this.deletePolygon(activePolygon);\n    }\n    this.onChange();\n  }\n\n  // key down handler - to be passed to Worldview as a prop\n  onKeyDown = (e: KeyboardEvent): void => {\n    // only respond to key events if we have a selected polygon\n    const { activePolygon } = this;\n    if (!activePolygon) {\n      return;\n    }\n\n    switch (e.key) {\n      case \"Delete\":\n      case \"Backspace\":\n        if (this.activePoint) {\n          this.deletePoint(this.activePoint);\n        } else {\n          this.deletePolygon(activePolygon);\n        }\n        this.onChange();\n        break;\n      default:\n        break;\n    }\n  };\n\n  // select either a point or polygon by id\n  selectObject(object?: Polygon | PolygonPoint) {\n    // clear out any previously active objects\n    this.activePolygon = null;\n    if (this.activePoint) {\n      this.activePoint.active = false;\n    }\n    this.activePoint = null;\n\n    for (const polygon of this.polygons) {\n      let isActive = polygon === object;\n      polygon.active = isActive;\n      if (isActive) {\n        this.activePolygon = polygon;\n      }\n      for (const point of polygon.points) {\n        if (point === object) {\n          // if a point is selected, activate both it\n          // and the polygon it belongs to\n          this.activePoint = point;\n          point.active = true;\n          polygon.active = true;\n          this.activePolygon = polygon;\n          isActive = true;\n        }\n      }\n    }\n\n    this.onChange();\n  }\n\n  // mouse up handler - to be passed to Worldview as a prop\n  onMouseUp: MouseHandler = (e, args) => {\n    if (!e.ctrlKey) {\n      this.mouseDown = false;\n    }\n  };\n\n  // double click handler - to be passed to Worldview as a prop\n  onDoubleClick: MouseHandler = (e, args) => {\n    // satisfy flow\n    if (!args) {\n      return;\n    }\n    if (!args.objects.length) {\n      return;\n    }\n\n    this.selectObject(args.objects[0].object);\n\n    // if a point was double-clicked, delete it\n    if (this.activePoint) {\n      this.deletePoint(this.activePoint);\n      return;\n    }\n\n    // otherwise insert a new point into the nearest line of the active polygon\n    const { activePolygon } = this;\n\n    // if no polygon is active, don't do anything w/ the double-click\n    if (!activePolygon) {\n      return;\n    }\n\n    let shortestDistance = Number.MAX_SAFE_INTEGER;\n    let shortestIndex = -1;\n    const { ray } = args;\n    const point = ray.planeIntersection([0, 0, 0], [0, 0, 1]);\n    if (!point) {\n      return;\n    }\n    const [px, py] = point;\n\n    // find the closest line segment of the active polygon\n    const { points } = activePolygon;\n    for (let i = 0; i < points.length - 1; i++) {\n      const point1 = points[i];\n      const point2 = points[i + 1];\n      const [x1, y1] = point1.point;\n      const [x2, y2] = point2.point;\n\n      // distance.squared is faster since we don't care about the\n      // actual distance, just which line produces the shortest distance\n      const dist = distance.squared(x1, y1, x2, y2, px, py);\n      if (dist < shortestDistance) {\n        shortestDistance = dist;\n        shortestIndex = i;\n      }\n    }\n\n    // insert a new point in the nearest line\n    if (shortestIndex > -1) {\n      const newPoint = new PolygonPoint(point);\n      activePolygon.points.splice(shortestIndex + 1, 0, newPoint);\n      this.activePoint = newPoint;\n    }\n    this.onChange();\n  };\n\n  // mouse down handler - to be passed to Worldview as a prop\n  onMouseDown: MouseHandler = (e, args) => {\n    if (!args) {\n      return;\n    }\n    const { ray } = args;\n\n    const point = ray.planeIntersection([0, 0, 0], [0, 0, 1]);\n\n    // satisfy flow but raycasting should always work\n    if (!point) {\n      return;\n    }\n\n    const isFirstClick = !this.mouseDown;\n    this.mouseDown = true;\n    this.mouseDownPoint = point;\n    const isCtrlClick = e.ctrlKey;\n\n    // single click or click+drag is for selection & moving\n    if (isFirstClick && !isCtrlClick) {\n      const clickObject = args.objects[0];\n      this.selectObject(clickObject && clickObject.object);\n      return this.onChange();\n    }\n\n    // ctrl+click always inserts a point\n    if (isCtrlClick) {\n      this.pushPoint(point);\n      return this.onChange();\n    }\n\n    // if mouse was down & we have a non-control click, close the active polygon\n    this.closeActivePolygon();\n    return this.onChange();\n  };\n}\n","// @flow\n\n//  Copyright (c) 2018-present, GM Cruise LLC\n//\n//  This source code is licensed under the Apache License, Version 2.0,\n//  found in the LICENSE file in the root directory of this source tree.\n//  You may not use this file except in compliance with the License.\n\nimport * as React from \"react\";\n\nimport type { Regl, TriangleList } from \"../types\";\nimport {\n  defaultBlend,\n  getVertexColors,\n  pointToVec3Array,\n  shouldConvert,\n  toRGBA,\n  withPose,\n} from \"../utils/commandUtils\";\nimport { createInstancedGetChildrenForHitmap } from \"../utils/getChildrenForHitmapDefaults\";\nimport Command, { type CommonCommandProps } from \"./Command\";\n\n// TODO(Audrey): default to the actual regl defaults before 1.x release\nconst defaultSingleColorDepth = { enable: true, mask: false };\nconst defaultVetexColorDepth = {\n  enable: true,\n  mask: true,\n  func: \"<=\",\n};\n\nconst singleColor = (regl) =>\n  withPose({\n    primitive: \"triangles\",\n    vert: `\n  precision mediump float;\n\n  attribute vec3 point;\n\n  uniform mat4 projection, view;\n\n  #WITH_POSE\n\n  void main () {\n    vec3 pos = applyPose(point);\n    gl_Position = projection * view * vec4(pos, 1);\n  }\n  `,\n    frag: `\n  precision mediump float;\n  uniform vec4 color;\n  void main () {\n    gl_FragColor = color;\n  }\n  `,\n    attributes: {\n      point: (context, props) => {\n        if (shouldConvert(props.points)) {\n          return pointToVec3Array(props.points);\n        }\n        return props.points;\n      },\n      color: (context, props) => {\n        if (shouldConvert(props.colors) || shouldConvert(props.color)) {\n          return getVertexColors(props);\n        }\n        return props.color || props.colors;\n      },\n    },\n    uniforms: {\n      color: (context, props) => {\n        if (shouldConvert(props.color)) {\n          return toRGBA(props.color);\n        }\n        return props.color;\n      },\n    },\n    // can pass in { enable: true, depth: false } to turn off depth to prevent flicker\n    // because multiple items are rendered to the same z plane\n    depth: {\n      enable: (context, props) => {\n        return (props.depth && props.depth.enable) || defaultSingleColorDepth.enable;\n      },\n      mask: (context, props) => {\n        return (props.depth && props.depth.mask) || defaultSingleColorDepth.mask;\n      },\n    },\n    blend: defaultBlend,\n\n    count: (context, props) => props.points.length,\n  });\n\nconst vertexColors = (regl) =>\n  withPose({\n    primitive: \"triangles\",\n    vert: `\n  precision mediump float;\n\n  attribute vec3 point;\n  attribute vec4 color;\n\n  uniform mat4 projection, view;\n\n  varying vec4 vColor;\n\n  #WITH_POSE\n\n  void main () {\n    vec3 pos = applyPose(point);\n    vColor = color;\n    gl_Position = projection * view * vec4(pos, 1);\n  }\n  `,\n    frag: `\n  precision mediump float;\n  varying vec4 vColor;\n  void main () {\n    gl_FragColor = vColor;\n  }\n  `,\n    attributes: {\n      point: (context, props) => {\n        if (shouldConvert(props.points)) {\n          return pointToVec3Array(props.points);\n        }\n        return props.points;\n      },\n      color: (context, props) => {\n        if (shouldConvert(props.colors) || shouldConvert(props.color)) {\n          return getVertexColors(props);\n        }\n        return props.color || props.colors;\n      },\n    },\n\n    depth: {\n      enable: (context, props) => {\n        return (props.depth && props.depth.enable) || defaultVetexColorDepth.enable;\n      },\n      mask: (context, props) => {\n        return (props.depth && props.depth.mask) || defaultVetexColorDepth.mask;\n      },\n    },\n    blend: defaultBlend,\n\n    count: (context, props) => props.points.length,\n  });\n\n// command to render triangle lists optionally supporting vertex colors for each triangle\nconst triangles = (regl: Regl) => {\n  const single = regl(singleColor(regl));\n  const vertex = regl(vertexColors(regl));\n  return (props: any, isHitmap: boolean) => {\n    const items: TriangleList[] = Array.isArray(props) ? props : [props];\n    const singleColorItems = [];\n    const vertexColorItems = [];\n    items.forEach((item) => {\n      // If the item has onlyRenderInHitmap set, only render it in the hitmap.\n      if (isHitmap || !item.onlyRenderInHitmap) {\n        if (item.colors && item.colors.length) {\n          vertexColorItems.push(item);\n        } else {\n          singleColorItems.push(item);\n        }\n      }\n    });\n\n    single(singleColorItems);\n    vertex(vertexColorItems);\n  };\n};\n\nconst getChildrenForHitmap = createInstancedGetChildrenForHitmap(3);\nexport default function Triangles(props: { ...CommonCommandProps, children: TriangleList[] }) {\n  return <Command getChildrenForHitmap={getChildrenForHitmap} {...props} reglCommand={triangles} />;\n}\n","// @flow\n\n//  Copyright (c) 2018-present, GM Cruise LLC\n//\n//  This source code is licensed under the Apache License, Version 2.0,\n//  found in the LICENSE file in the root directory of this source tree.\n//  You may not use this file except in compliance with the License.\n\nimport earcut from \"earcut\";\nimport React from \"react\";\n\nimport type { Vec3, Point, PolygonType } from \"../types\";\nimport { shouldConvert, pointToVec3 } from \"../utils/commandUtils\";\nimport { getChildrenForHitmapWithOriginalMarker } from \"../utils/getChildrenForHitmapDefaults\";\nimport Triangles from \"./Triangles\";\n\nconst NO_POSE = {\n  position: { x: 0, y: 0, z: 0 },\n  orientation: { x: 0, y: 0, z: 0, w: 0 },\n};\n\nconst DEFAULT_SCALE = { x: 1, y: 1, z: 1 };\n\nfunction flatten3D(points: Vec3[]): Float32Array {\n  const array = new Float32Array(points.length * 3);\n  for (let i = 0; i < points.length; i++) {\n    const [x, y, z] = points[i];\n    array[i * 3] = x;\n    array[i * 3 + 1] = y;\n    array[i * 3 + 2] = z;\n  }\n  return array;\n}\n\nfunction getEarcutPoints(points: Vec3[]): (Vec3 | Point)[] {\n  const flattenedPoints = flatten3D(points);\n  const indices = earcut(flattenedPoints, null, 3);\n  const newPoints = [];\n  for (let i = 0; i < indices.length; i++) {\n    const originalIndex = indices[i];\n    newPoints.push(points[originalIndex]);\n  }\n  return newPoints;\n}\n\ntype Props = {\n  children: PolygonType[],\n};\n\n// command to draw a filled polygon\nfunction FilledPolygons({ children: polygons = [], ...rest }: Props) {\n  const triangles = polygons.map((poly) => {\n    // $FlowFixMe flow doesn't know how shouldConvert works\n    const points: Vec3[] = shouldConvert(poly.points) ? poly.points.map(pointToVec3) : poly.points;\n    const pose = poly.pose ? poly.pose : NO_POSE;\n    const earcutPoints = getEarcutPoints(points);\n    return {\n      ...poly,\n      points: earcutPoints,\n      pose,\n      scale: DEFAULT_SCALE,\n      originalMarker: poly,\n    };\n  });\n\n  // Overwrite the triangle's default getChildrenForHitmap because we want to event as if each triangle is a single\n  // polygon.\n  return (\n    <Triangles getChildrenForHitmap={getChildrenForHitmapWithOriginalMarker} {...rest}>\n      {triangles}\n    </Triangles>\n  );\n}\n\nexport default FilledPolygons;\n","// @flow\n\n//  Copyright (c) 2018-present, GM Cruise LLC\n//\n//  This source code is licensed under the Apache License, Version 2.0,\n//  found in the LICENSE file in the root directory of this source tree.\n//  You may not use this file except in compliance with the License.\n\nimport React from \"react\";\n\nimport type { Point, CameraCommand, Dimensions, Color, Pose, Scale } from \"../types\";\nimport { getCSSColor } from \"../utils/commandUtils\";\nimport { type WorldviewContextType } from \"../WorldviewContext\";\nimport WorldviewReactContext from \"../WorldviewReactContext\";\n\nconst BG_COLOR_LIGHT = \"#ffffff\";\nconst BG_COLOR_DARK = \"rgba(0,0,0,0.8)\";\nconst BRIGHTNESS_THRESHOLD = 128;\nconst DEFAULT_TEXT_COLOR = { r: 1, g: 1, b: 1, a: 1 };\nconst DEFAULT_BG_COLOR = { r: 0, g: 0, b: 0, a: 0.8 };\n\nexport type TextMarker = {\n  name?: string,\n  pose: Pose,\n  scale: Scale,\n  color?: Color,\n  colors?: Color[],\n  text: string,\n};\n\nlet cssHasBeenInserted = false;\nfunction insertGlobalCss() {\n  if (cssHasBeenInserted) {\n    return;\n  }\n  const style = document.createElement(\"style\");\n  style.innerHTML = `\n    .regl-worldview-text-wrapper {\n      position: absolute;\n      white-space: nowrap;\n      z-index: 100;\n      pointer-events: none;\n      top: 0;\n      left: 0;\n      will-change: transform;\n    }\n    .regl-worldview-text-inner {\n      position: relative;\n      left: -50%;\n      top: -0.5em;\n      white-space: pre-line;\n    }\n  `;\n  if (document.body) {\n    document.body.appendChild(style);\n  }\n  cssHasBeenInserted = true;\n}\n\nexport function isColorDark({ r, g, b }: Color): boolean {\n  // ITU-R BT.709 https://en.wikipedia.org/wiki/Rec._709\n  // 0.2126 * 255 * r + 0.7152 * 255 * g + 0.0722 * 255 * b\n  const luma = 54.213 * r + 182.376 * g + 18.411 * b;\n  return luma < BRIGHTNESS_THRESHOLD;\n}\n\nfunction isColorEqual(a: Color, b: Color): boolean {\n  return a.r === b.r && a.g === b.g && a.b === b.b && a.a === b.a;\n}\n\nclass TextElement {\n  wrapper = document.createElement(\"span\");\n  _inner = document.createElement(\"span\");\n  _text = document.createTextNode(\"\");\n  // store prev colors to improve perf\n  _prevTextColor: Color = DEFAULT_TEXT_COLOR;\n  _prevBgColor: ?Color = DEFAULT_BG_COLOR;\n  _prevAutoBackgroundColor: ?boolean = null;\n\n  constructor() {\n    insertGlobalCss();\n    this.wrapper.className = \"regl-worldview-text-wrapper\";\n    this._inner.className = \"regl-worldview-text-inner\";\n    this.wrapper.appendChild(this._inner);\n    this._inner.appendChild(this._text);\n    this.wrapper.style.color = getCSSColor(DEFAULT_TEXT_COLOR);\n  }\n\n  update(marker: TextMarker, left: number, top: number, autoBackgroundColor?: boolean) {\n    this.wrapper.style.transform = `translate(${left.toFixed()}px,${top.toFixed()}px)`;\n    const { color, colors = [] } = marker;\n    const hasBgColor = colors.length >= 2;\n    const textColor = hasBgColor ? colors[0] : color;\n\n    if (textColor) {\n      if (!isColorEqual(this._prevTextColor, textColor)) {\n        this._prevTextColor = textColor;\n        this.wrapper.style.color = getCSSColor(textColor);\n      }\n\n      if (!autoBackgroundColor && autoBackgroundColor !== this._prevAutoBackgroundColor) {\n        // remove background color if autoBackgroundColor has changed\n        this._inner.style.background = \"transparent\";\n        this._prevBgColor = null;\n      } else {\n        if (\n          autoBackgroundColor &&\n          (!this._prevBgColor || (this._prevBgColor && !isColorEqual(textColor, this._prevBgColor)))\n        ) {\n          // update background color with automatic dark/light color\n          this._prevBgColor = textColor;\n          const isTextColorDark = isColorDark(textColor);\n          const hexBgColor = isTextColorDark ? BG_COLOR_LIGHT : BG_COLOR_DARK;\n          this._inner.style.background = hexBgColor;\n        } else if (hasBgColor && this._prevBgColor && !isColorEqual(colors[1], this._prevBgColor)) {\n          // update background color with colors[1] data\n          this._prevBgColor = colors[1];\n          this._inner.style.background = getCSSColor(colors[1]);\n        }\n      }\n    }\n    this._prevAutoBackgroundColor = autoBackgroundColor;\n\n    if (this._text.textContent !== marker.text) {\n      this._text.textContent = marker.text || \"\";\n    }\n  }\n}\n\ntype Props = {\n  children: TextMarker[],\n  autoBackgroundColor?: boolean,\n};\n\n// Render text on a scene using DOM nodes, similar to the Overlay command.\n// Implementation uses manual DOM manipulation to avoid the performance hit from React tree reconciliation.\nexport default class Text extends React.Component<Props> {\n  _context: ?WorldviewContextType;\n  _textComponents: Map<string | TextMarker, TextElement> = new Map();\n  _textContainerRef: { current: HTMLDivElement | null } = React.createRef();\n\n  static defaultProps = {\n    children: [],\n  };\n\n  componentDidMount() {\n    if (this._context) {\n      this._context.registerPaintCallback(this.paint);\n    }\n  }\n\n  componentWillUnmount = () => {\n    if (this._context) {\n      this._context.unregisterPaintCallback(this.paint);\n    }\n  };\n\n  paint = () => {\n    const context = this._context;\n    const textComponents = this._textComponents;\n    const { children: markers, autoBackgroundColor } = this.props;\n    const { current: textContainer } = this._textContainerRef;\n    const initializedData = context && context.initializedData;\n\n    if (!textContainer || !context || !initializedData) {\n      return;\n    }\n    const {\n      dimension,\n      dimension: { width, height },\n    } = context;\n    const { camera } = initializedData;\n\n    const componentsToRemove = new Set(textComponents.keys());\n\n    for (const marker of markers) {\n      const { pose, name } = marker;\n      const { position } = pose;\n      const coord = this.project(position, camera, dimension);\n      if (!coord) {\n        continue;\n      }\n\n      const [left, top] = coord;\n      if (left < -10 || top < -10 || left > width + 10 || top > height + 10) {\n        continue;\n      }\n\n      let el = textComponents.get(name || marker);\n      if (el) {\n        componentsToRemove.delete(name || marker);\n      } else {\n        el = new TextElement();\n        textComponents.set(name || marker, el);\n        textContainer.appendChild(el.wrapper);\n      }\n\n      el.update(marker, left, top, autoBackgroundColor);\n    }\n\n    for (const key of componentsToRemove) {\n      const el = textComponents.get(key);\n      if (!el) {\n        continue;\n      }\n      el.wrapper.remove();\n      textComponents.delete(key);\n    }\n  };\n\n  project = (point: Point, camera: CameraCommand, dimension: Dimensions) => {\n    const vec = [point.x, point.y, point.z];\n    const { left, top, width, height } = dimension;\n    const viewport = [left, top, width, height];\n    return camera.toScreenCoord(viewport, vec);\n  };\n\n  render() {\n    return (\n      <React.Fragment>\n        <div ref={this._textContainerRef} />\n        <WorldviewReactContext.Consumer>\n          {(ctx: ?WorldviewContextType) => {\n            if (ctx) {\n              this._context = ctx;\n            }\n            return null;\n          }}\n        </WorldviewReactContext.Consumer>\n      </React.Fragment>\n    );\n  }\n}\n","// @flow\n\nimport TinySDF from \"@mapbox/tiny-sdf\";\nimport memoizeOne from \"memoize-one\";\nimport React, { useState } from \"react\";\n\nimport type { Color } from \"../types\";\nimport { defaultBlend, defaultDepth } from \"../utils/commandUtils\";\nimport Command, { type CommonCommandProps } from \"./Command\";\nimport { isColorDark, type TextMarker } from \"./Text\";\n\n// The GLText command renders text from a Signed Distance Field texture.\n// There are many external resources about SDFs and text rendering in WebGL, including:\n// https://steamcdn-a.akamaihd.net/apps/valve/2007/SIGGRAPH2007_AlphaTestedMagnification.pdf\n// https://blog.mapbox.com/drawing-text-with-signed-distance-fields-in-mapbox-gl-b0933af6f817\n// http://hack.chrons.me/opengl-text-rendering/\n// https://stackoverflow.com/questions/25956272/better-quality-text-in-webgl\n//\n// Approach\n// ========\n// Characters from the font are measured using a <canvas> and the SDFs are drawn into a texture up front\n// (and whenever new characters are being rendered). Then one instanced draw call is made with an instance\n// per character which reads from the corresponding place in the texture atlas.\n//\n// Possible future improvements\n// ============================\n// - Add hitmap support.\n// - Allow customization of font style, maybe highlight ranges.\n// - Add a scaleInvariant option.\n// - Consider a solid rectangular background instead of an outline. This is challenging because the\n//   instances currently overlap, so there will be z-fighting, but might be possible using the stencil buffer and multiple draw calls.\n// - Somehow support kerning and more advanced font metrics. However, the web font APIs may not\n//   provide support for this. Some font info could be generated/stored offline, possibly including the atlas.\n// - Explore multi-channel SDFs.\n\ntype TextMarkerProps = TextMarker & {\n  billboard?: ?boolean,\n  highlightedIndices?: Array<number>,\n  highlightColor?: ?Color,\n};\ntype Props = {\n  ...CommonCommandProps,\n  children: $ReadOnlyArray<TextMarkerProps>,\n  autoBackgroundColor?: boolean,\n};\n\ntype FontAtlas = {|\n  textureData: Uint8Array,\n  textureWidth: number,\n  textureHeight: number,\n  charInfo: {\n    [char: string]: {|\n      x: number,\n      y: number,\n      width: number,\n    |},\n  },\n|};\n\n// Font size used in rendering the atlas. This is independent of the `scale` of the rendered text.\nconst FONT_SIZE = 40;\nconst MAX_ATLAS_WIDTH = 512;\nconst SDF_RADIUS = 8;\nconst CUTOFF = 0.25;\nconst BUFFER = 10;\n\nconst BG_COLOR_LIGHT = Object.freeze({ r: 1, g: 1, b: 1, a: 1 });\nconst BG_COLOR_DARK = Object.freeze({ r: 0, g: 0, b: 0, a: 1 });\n\nconst memoizedCreateCanvas = memoizeOne((font) => {\n  const canvas = document.createElement(\"canvas\");\n  const ctx = canvas.getContext(\"2d\");\n  ctx.font = font;\n  return ctx;\n});\n\n// Build a single font atlas: a texture containing all characters and position/size data for each character.\nconst createMemoizedBuildAtlas = () =>\n  memoizeOne(\n    (charSet: Set<string>): FontAtlas => {\n      const tinySDF = new TinySDF(FONT_SIZE, BUFFER, SDF_RADIUS, CUTOFF, \"sans-serif\", \"normal\");\n      const ctx = memoizedCreateCanvas(`${FONT_SIZE}px sans-serif`);\n\n      let textureWidth = 0;\n      const rowHeight = FONT_SIZE + 2 * BUFFER;\n      const charInfo = {};\n\n      // Measure and assign positions to all characters\n      let x = 0;\n      let y = 0;\n      for (const char of charSet) {\n        const width = ctx.measureText(char).width;\n        const dx = Math.ceil(width) + 2 * BUFFER;\n        if (x + dx > MAX_ATLAS_WIDTH) {\n          x = 0;\n          y += rowHeight;\n        }\n        charInfo[char] = { x, y, width };\n        x += dx;\n        textureWidth = Math.max(textureWidth, x);\n      }\n\n      const textureHeight = y + rowHeight;\n      const textureData = new Uint8Array(textureWidth * textureHeight);\n\n      // Use tiny-sdf to create SDF images for each character and copy them into a single texture\n      for (const char of charSet) {\n        const { x, y } = charInfo[char];\n        const data = tinySDF.draw(char);\n        for (let i = 0; i < tinySDF.size; i++) {\n          for (let j = 0; j < tinySDF.size; j++) {\n            // if this character is near the right edge, we don't actually copy the whole square of data\n            if (x + j < textureWidth) {\n              textureData[textureWidth * (y + i) + x + j] = data[i * tinySDF.size + j];\n            }\n          }\n        }\n      }\n\n      return { textureData, textureWidth, textureHeight, charInfo };\n    }\n  );\n\nconst vert = `\n  precision mediump float;\n\n  uniform mat4 projection, view, billboardRotation;\n  uniform float fontSize;\n  uniform vec2 atlasSize;\n\n  // per-vertex attributes\n  attribute vec2 texCoord;\n  attribute vec2 position;\n\n  // per-instance (character) attributes\n  attribute vec2 srcOffset;\n  attribute float srcWidth;\n  attribute vec2 destOffset;\n\n  // per-marker attributes\n  attribute vec3 scale;\n  attribute float billboard;\n  attribute vec2 alignmentOffset;\n  attribute float enableBackground;\n  attribute float enableHighlight;\n  attribute vec4 foregroundColor;\n  attribute vec4 backgroundColor;\n  attribute vec4 highlightColor;\n  attribute vec3 posePosition;\n  attribute vec4 poseOrientation;\n\n  varying vec2 vTexCoord;\n  varying float vEnableBackground;\n  varying vec4 vForegroundColor;\n  varying vec4 vBackgroundColor;\n  varying vec4 vHighlightColor;\n  varying float vEnableHighlight;\n\n  // rotate a 3d point v by a rotation quaternion q\n  // like applyPose(), but we need to use a custom per-instance pose\n  vec3 rotate(vec3 v, vec4 q) {\n    vec3 temp = cross(q.xyz, v) + q.w * v;\n    return v + (2.0 * cross(q.xyz, temp));\n  }\n\n  void main () {\n    vec2 srcSize = vec2(srcWidth, fontSize);\n    vec3 markerSpacePos = scale * vec3((destOffset + position * srcSize + alignmentOffset) / fontSize, 0);\n    vec3 pos;\n    if (billboard == 1.0) {\n      pos = (billboardRotation * vec4(markerSpacePos, 1)).xyz + posePosition;\n    } else {\n      pos = rotate(markerSpacePos, poseOrientation) + posePosition;\n    }\n    gl_Position = projection * view * vec4(pos, 1);\n    vTexCoord = (srcOffset + texCoord * srcSize) / atlasSize;\n    vEnableBackground = enableBackground;\n    vForegroundColor = foregroundColor;\n    vBackgroundColor = backgroundColor;\n    vHighlightColor = highlightColor;\n    vEnableHighlight = enableHighlight;\n  }\n`;\n\nconst frag = `\n  #extension GL_OES_standard_derivatives : enable\n  precision mediump float;\n  uniform mat4 projection;\n  uniform sampler2D atlas;\n  uniform float cutoff;\n\n  varying vec2 vTexCoord;\n  varying float vEnableBackground;\n  varying vec4 vForegroundColor;\n  varying vec4 vBackgroundColor;\n  varying vec4 vHighlightColor;\n  varying float vEnableHighlight;\n  void main() {\n    float dist = texture2D(atlas, vTexCoord).a;\n\n    // fwidth(dist) is used to provide some anti-aliasing. However it's currently only used\n    // when the solid background is enabled, because the alpha blending and\n    // depth test don't work together nicely for partially-transparent pixels.\n    float edgeStep = smoothstep(1.0 - cutoff - fwidth(dist), 1.0 - cutoff, dist);\n    if (vEnableHighlight > 0.5) {\n      gl_FragColor = mix(vHighlightColor, vec4(0, 0, 0, 1), edgeStep);\n    } else if (vEnableBackground > 0.5) {\n      float screenSize = fwidth(vTexCoord.x);\n      gl_FragColor = mix(vBackgroundColor, vForegroundColor, edgeStep);\n    } else {\n      gl_FragColor = vForegroundColor;\n      gl_FragColor.a *= step(1.0 - cutoff, dist);\n    }\n\n    if (gl_FragColor.a == 0.) {\n      discard;\n    }\n  }\n`;\n\nfunction makeTextCommand() {\n  // Keep the set of rendered characters around so we don't have to rebuild the font atlas too often.\n  const charSet = new Set();\n  const memoizedBuildAtlas = createMemoizedBuildAtlas();\n\n  const command = (regl: any) => {\n    const atlasTexture = regl.texture();\n    const drawText = regl({\n      depth: defaultDepth,\n      blend: defaultBlend,\n      primitive: \"triangle strip\",\n      vert,\n      frag,\n      uniforms: {\n        atlas: atlasTexture,\n        atlasSize: () => [atlasTexture.width, atlasTexture.height],\n        fontSize: FONT_SIZE,\n        cutoff: CUTOFF,\n      },\n      instances: regl.prop(\"instances\"),\n      count: 4,\n      attributes: {\n        position: [[0, 0], [0, -1], [1, 0], [1, -1]],\n        texCoord: [[0, 0], [0, 1], [1, 0], [1, 1]], // flipped\n        srcOffset: (ctx, props) => ({ buffer: props.srcOffsets, divisor: 1 }),\n        destOffset: (ctx, props) => ({ buffer: props.destOffsets, divisor: 1 }),\n        srcWidth: (ctx, props) => ({ buffer: props.srcWidths, divisor: 1 }),\n        scale: (ctx, props) => ({ buffer: props.scale, divisor: 1 }),\n        alignmentOffset: (ctx, props) => ({ buffer: props.alignmentOffset, divisor: 1 }),\n        billboard: (ctx, props) => ({ buffer: props.billboard, divisor: 1 }),\n        foregroundColor: (ctx, props) => ({ buffer: props.foregroundColor, divisor: 1 }),\n        backgroundColor: (ctx, props) => ({ buffer: props.backgroundColor, divisor: 1 }),\n        highlightColor: (ctx, props) => ({ buffer: props.highlightColor, divisor: 1 }),\n        enableBackground: (ctx, props) => ({ buffer: props.enableBackground, divisor: 1 }),\n        enableHighlight: (ctx, props) => ({ buffer: props.enableHighlight, divisor: 1 }),\n        posePosition: (ctx, props) => ({ buffer: props.posePosition, divisor: 1 }),\n        poseOrientation: (ctx, props) => ({ buffer: props.poseOrientation, divisor: 1 }),\n      },\n    });\n\n    return (props: $ReadOnlyArray<TextMarkerProps>) => {\n      let estimatedInstances = 0;\n      const prevNumChars = charSet.size;\n      for (const { text } of props) {\n        if (typeof text !== \"string\") {\n          throw new Error(`Expected typeof 'text' to be a string. But got type '${typeof text}' instead.`);\n        }\n\n        for (const char of text) {\n          ++estimatedInstances;\n          charSet.add(char);\n        }\n      }\n      const charsChanged = charSet.size !== prevNumChars;\n\n      const { textureData, textureWidth, textureHeight, charInfo } = memoizedBuildAtlas(\n        // only use a new set if the characters changed, since memoizeOne uses shallow equality\n        charsChanged ? new Set(charSet) : charSet\n      );\n\n      // re-upload texture only if characters were added\n      if (charsChanged) {\n        atlasTexture({\n          data: textureData,\n          width: textureWidth,\n          height: textureHeight,\n          format: \"alpha\",\n          wrap: \"clamp\",\n          mag: \"linear\",\n          min: \"linear\",\n        });\n      }\n\n      const destOffsets = new Float32Array(estimatedInstances * 2);\n      const srcWidths = new Float32Array(estimatedInstances);\n      const srcOffsets = new Float32Array(estimatedInstances * 2);\n\n      // These don't vary across characters within a marker, but the divisor can't be dynamic so we have to duplicate the data for each character.\n      const alignmentOffset = new Float32Array(estimatedInstances * 2);\n      const scale = new Float32Array(estimatedInstances * 3);\n      const foregroundColor = new Float32Array(estimatedInstances * 4);\n      const backgroundColor = new Float32Array(estimatedInstances * 4);\n      const highlightColor = new Float32Array(estimatedInstances * 4);\n      const enableBackground = new Float32Array(estimatedInstances);\n      const billboard = new Float32Array(estimatedInstances);\n      const posePosition = new Float32Array(estimatedInstances * 3);\n      const poseOrientation = new Float32Array(estimatedInstances * 4);\n      const enableHighlight = new Float32Array(estimatedInstances);\n\n      let totalInstances = 0;\n      for (const marker of props) {\n        let totalWidth = 0;\n        let x = 0;\n        let y = 0;\n        let markerInstances = 0;\n\n        const fgColor = marker.colors?.[0] || marker.color || BG_COLOR_LIGHT;\n        const outline = marker.colors?.[1] != null || command.autoBackgroundColor;\n        const bgColor =\n          marker.colors?.[1] || (command.autoBackgroundColor && isColorDark(fgColor) ? BG_COLOR_LIGHT : BG_COLOR_DARK);\n        const hlColor = marker?.highlightColor || { r: 1, b: 0, g: 1, a: 1 };\n\n        for (let i = 0; i < marker.text.length; i++) {\n          const char = marker.text[i];\n          if (char === \"\\n\") {\n            x = 0;\n            y = FONT_SIZE;\n            continue;\n          }\n          const info = charInfo[char];\n          const index = totalInstances + markerInstances;\n\n          // Calculate per-character attributes\n          destOffsets[2 * index + 0] = x;\n          destOffsets[2 * index + 1] = -y;\n          srcOffsets[2 * index + 0] = info.x + BUFFER;\n          srcOffsets[2 * index + 1] = info.y + BUFFER;\n          srcWidths[index] = info.width;\n\n          x += info.width;\n          totalWidth = Math.max(totalWidth, x);\n\n          // Copy per-marker attributes. These are duplicated per character so that we can draw\n          // all characters from all markers in a single draw call.\n\n          billboard[index] = marker.billboard ?? true ? 1 : 0;\n\n          scale[3 * index + 0] = marker.scale.x;\n          scale[3 * index + 1] = marker.scale.y;\n          scale[3 * index + 2] = marker.scale.z;\n\n          posePosition[3 * index + 0] = marker.pose.position.x;\n          posePosition[3 * index + 1] = marker.pose.position.y;\n          posePosition[3 * index + 2] = marker.pose.position.z;\n\n          poseOrientation[4 * index + 0] = marker.pose.orientation.x;\n          poseOrientation[4 * index + 1] = marker.pose.orientation.y;\n          poseOrientation[4 * index + 2] = marker.pose.orientation.z;\n          poseOrientation[4 * index + 3] = marker.pose.orientation.w;\n\n          foregroundColor[4 * index + 0] = fgColor.r;\n          foregroundColor[4 * index + 1] = fgColor.g;\n          foregroundColor[4 * index + 2] = fgColor.b;\n          foregroundColor[4 * index + 3] = fgColor.a;\n\n          backgroundColor[4 * index + 0] = bgColor.r;\n          backgroundColor[4 * index + 1] = bgColor.g;\n          backgroundColor[4 * index + 2] = bgColor.b;\n          backgroundColor[4 * index + 3] = bgColor.a;\n\n          highlightColor[4 * index + 0] = hlColor.r;\n          highlightColor[4 * index + 1] = hlColor.g;\n          highlightColor[4 * index + 2] = hlColor.b;\n          highlightColor[4 * index + 3] = hlColor.a;\n\n          enableHighlight[index] = marker.highlightedIndices && marker.highlightedIndices.includes(i) ? 1 : 0;\n\n          enableBackground[index] = outline ? 1 : 0;\n\n          ++markerInstances;\n        }\n\n        const totalHeight = y + FONT_SIZE;\n        for (let i = 0; i < markerInstances; i++) {\n          alignmentOffset[2 * (totalInstances + i) + 0] = -totalWidth / 2;\n          alignmentOffset[2 * (totalInstances + i) + 1] = totalHeight / 2;\n        }\n\n        totalInstances += markerInstances;\n      }\n\n      drawText({\n        instances: totalInstances,\n\n        // per-character\n        srcOffsets,\n        destOffsets,\n        srcWidths,\n\n        // per-marker\n        alignmentOffset,\n        billboard,\n        enableBackground,\n        enableHighlight,\n        foregroundColor,\n        backgroundColor,\n        highlightColor,\n        poseOrientation,\n        posePosition,\n        scale,\n      });\n    };\n  };\n  command.autoBackgroundColor = false;\n  return command;\n}\n\nexport default function GLText(props: Props) {\n  const [command] = useState(() => makeTextCommand());\n  // HACK: Worldview doesn't provide an easy way to pass a command-level prop into the regl commands,\n  // so just attach it to the command object for now.\n  command.autoBackgroundColor = props.autoBackgroundColor;\n  return <Command reglCommand={command} {...props} />;\n}\n","// @flow\n\n//  Copyright (c) 2019-present, GM Cruise LLC\n//\n//  This source code is licensed under the Apache License, Version 2.0,\n//  found in the LICENSE file in the root directory of this source tree.\n//  You may not use this file except in compliance with the License.\n\nimport { mat4 } from \"gl-matrix\";\nimport memoizeWeak from \"memoize-weak\";\nimport React, { useContext, useState, useEffect, useCallback, useDebugValue } from \"react\";\n\nimport type { Pose, Scale, MouseHandler } from \"../types\";\nimport { defaultBlend, pointToVec3, orientationToVec4 } from \"../utils/commandUtils\";\nimport { getChildrenForHitmapWithOriginalMarker } from \"../utils/getChildrenForHitmapDefaults\";\nimport parseGLB, { type GLBModel } from \"../utils/parseGLB\";\nimport WorldviewReactContext from \"../WorldviewReactContext\";\nimport Command from \"./Command\";\n\nfunction glConstantToRegl(value: ?number): ?string {\n  if (value === undefined) {\n    return undefined;\n  }\n  // prettier-ignore\n  switch (value) {\n    // min/mag filters\n    case WebGLRenderingContext.NEAREST: return \"nearest\";\n    case WebGLRenderingContext.LINEAR: return \"linear\";\n    case WebGLRenderingContext.NEAREST_MIPMAP_NEAREST: return \"nearest mipmap nearest\";\n    case WebGLRenderingContext.NEAREST_MIPMAP_LINEAR: return \"nearest mipmap linear\";\n    case WebGLRenderingContext.LINEAR_MIPMAP_NEAREST: return \"linear mipmap nearest\";\n    case WebGLRenderingContext.LINEAR_MIPMAP_LINEAR: return \"linear mipmap linear\";\n    // texture wrapping modes\n    case WebGLRenderingContext.REPEAT: return \"repeat\";\n    case WebGLRenderingContext.CLAMP_TO_EDGE: return \"clamp\";\n    case WebGLRenderingContext.MIRRORED_REPEAT: return \"mirror\";\n  }\n  throw new Error(`unhandled constant value ${JSON.stringify(value)}`);\n}\n\nconst drawModel = (regl) => {\n  const command = regl({\n    primitive: \"triangles\",\n    blend: defaultBlend,\n    uniforms: {\n      globalAlpha: regl.context(\"globalAlpha\"),\n      poseMatrix: regl.context(\"poseMatrix\"),\n\n      baseColorTexture: regl.prop(\"baseColorTexture\"),\n      baseColorFactor: regl.prop(\"baseColorFactor\"),\n      nodeMatrix: regl.prop(\"nodeMatrix\"),\n      \"light.direction\": [0, 0, -1],\n      \"light.ambientIntensity\": 0.5,\n      \"light.diffuseIntensity\": 0.5,\n      hitmapColor: regl.context(\"hitmapColor\"),\n      isHitmap: regl.context(\"isHitmap\"),\n    },\n    attributes: {\n      position: regl.prop(\"positions\"),\n      normal: regl.prop(\"normals\"),\n      texCoord: regl.prop(\"texCoords\"),\n    },\n    elements: regl.prop(\"indices\"),\n    vert: `\n  uniform mat4 projection, view;\n  uniform mat4 nodeMatrix;\n  uniform mat4 poseMatrix;\n  attribute vec3 position, normal;\n  varying vec3 vNormal;\n  attribute vec2 texCoord;\n  varying vec2 vTexCoord;\n\n  void main() {\n    // using the projection matrix for normals breaks lighting for orthographic mode\n    mat4 mv = view * poseMatrix * nodeMatrix;\n    vNormal = normalize((mv * vec4(normal, 0)).xyz);\n    vTexCoord = texCoord;\n    gl_Position = projection * mv * vec4(position, 1);\n  }\n  `,\n    frag: `\n  precision mediump float;\n  uniform bool isHitmap;\n  uniform vec4 hitmapColor;\n  uniform float globalAlpha;\n  uniform sampler2D baseColorTexture;\n  uniform vec4 baseColorFactor;\n  varying mediump vec2 vTexCoord;\n  varying mediump vec3 vNormal;\n\n  // Basic directional lighting from:\n  // http://ogldev.atspace.co.uk/www/tutorial18/tutorial18.html\n  struct DirectionalLight {\n    mediump vec3 direction;\n    lowp float ambientIntensity;\n    lowp float diffuseIntensity;\n  };\n  uniform DirectionalLight light;\n\n  void main() {\n    vec4 baseColor = texture2D(baseColorTexture, vTexCoord) * baseColorFactor;\n    float diffuse = light.diffuseIntensity * max(0.0, dot(vNormal, -light.direction));\n    gl_FragColor = isHitmap ? hitmapColor : vec4((light.ambientIntensity + diffuse) * baseColor.rgb, baseColor.a * globalAlpha);\n  }\n  `,\n  });\n\n  // default values for when baseColorTexture is not specified\n  const singleTexCoord = regl.buffer([0, 0]);\n  const whiteTexture = regl.texture({\n    data: [255, 255, 255, 255],\n    width: 1,\n    height: 1,\n  });\n\n  // build the draw calls needed to draw the model. This will happen whenever the model changes.\n  const getDrawCalls = memoizeWeak((model: GLBModel) => {\n    // upload textures to the GPU\n    const { accessors } = model;\n    const textures =\n      model.json.textures &&\n      model.json.textures.map((textureInfo) => {\n        const sampler = model.json.samplers[textureInfo.sampler];\n        const bitmap = model.images && model.images[textureInfo.source];\n        const texture = regl.texture({\n          data: bitmap,\n          min: glConstantToRegl(sampler.minFilter),\n          mag: glConstantToRegl(sampler.magFilter),\n          wrapS: glConstantToRegl(sampler.wrapS),\n          wrapT: glConstantToRegl(sampler.wrapT),\n        });\n        return texture;\n      });\n    if (model.images) {\n      model.images.forEach((bitmap: ImageBitmap) => bitmap.close());\n    }\n\n    const drawCalls = [];\n    // helper to draw the primitives comprising a mesh\n    function drawMesh(mesh, nodeMatrix) {\n      for (const primitive of mesh.primitives) {\n        const material = model.json.materials[primitive.material];\n        const texInfo = material.pbrMetallicRoughness.baseColorTexture;\n        if (!accessors) {\n          throw new Error(\"Error decoding GLB model: Missing `accessors` in JSON data\");\n        }\n        drawCalls.push({\n          indices: accessors[primitive.indices],\n          positions: accessors[primitive.attributes.POSITION],\n          normals: accessors[primitive.attributes.NORMAL],\n          texCoords: texInfo\n            ? accessors[primitive.attributes[`TEXCOORD_${texInfo.texCoord || 0}`]]\n            : { divisor: 1, buffer: singleTexCoord },\n          baseColorTexture: texInfo ? textures[texInfo.index] : whiteTexture,\n          baseColorFactor: material.pbrMetallicRoughness.baseColorFactor || [1, 1, 1, 1],\n          nodeMatrix,\n        });\n      }\n    }\n\n    // helper to draw all the meshes contained in a node and its child nodes\n    function drawNode(node, parentMatrix) {\n      const nodeMatrix = node.matrix\n        ? mat4.clone(node.matrix)\n        : mat4.fromRotationTranslationScale(\n            mat4.create(),\n            node.rotation || [0, 0, 0, 1],\n            node.translation || [0, 0, 0],\n            node.scale || [1, 1, 1]\n          );\n      mat4.mul(nodeMatrix, parentMatrix, nodeMatrix);\n      if (node.mesh != null) {\n        drawMesh(model.json.meshes[node.mesh], nodeMatrix);\n      }\n      if (node.children) {\n        for (const childIdx of node.children) {\n          drawNode(model.json.nodes[childIdx], nodeMatrix);\n        }\n      }\n    }\n\n    // finally, draw each of the main scene's nodes\n    for (const nodeIdx of model.json.scenes[model.json.scene].nodes) {\n      const rootTransform = mat4.create();\n      mat4.rotateX(rootTransform, rootTransform, Math.PI / 2);\n      mat4.rotateY(rootTransform, rootTransform, Math.PI / 2);\n      drawNode(model.json.nodes[nodeIdx], rootTransform);\n    }\n    return drawCalls;\n  });\n\n  // create a regl command to set the context for each draw call\n  const withContext = regl({\n    context: {\n      poseMatrix: (context, props) =>\n        mat4.fromRotationTranslationScale(\n          mat4.create(),\n          orientationToVec4(props.pose.orientation),\n          pointToVec3(props.pose.position),\n          props.scale ? pointToVec3(props.scale) : [1, 1, 1]\n        ),\n      globalAlpha: (context, props) => (props.alpha == null ? 1 : props.alpha),\n      hitmapColor: (context, props) => props.color || [0, 0, 0, 1],\n      isHitmap: (context, props) => !!props.isHitmap,\n    },\n  });\n\n  return (props, isHitmap) => {\n    const drawCalls = getDrawCalls(props.model);\n    withContext(isHitmap ? { ...props, isHitmap } : props, () => {\n      command(drawCalls);\n    });\n  };\n};\n\ntype Props = {|\n  model: string | (() => Promise<GLBModel>),\n  onClick?: MouseHandler,\n  onDoubleClick?: MouseHandler,\n  onMouseDown?: MouseHandler,\n  onMouseMove?: MouseHandler,\n  onMouseUp?: MouseHandler,\n  children: {\n    pose: Pose,\n    scale: Scale,\n    alpha?: ?number,\n  },\n|};\n\nfunction useAsyncValue<T>(fn: () => Promise<T>, deps: ?(any[])): ?T {\n  const [value, setValue] = useState<?T>();\n  useEffect(\n    useCallback(() => {\n      let unloaded = false;\n      fn().then((result) => {\n        if (!unloaded) {\n          setValue(result);\n        }\n      });\n      return () => {\n        unloaded = true;\n        setValue(undefined);\n      };\n    }, deps || [fn]),\n    deps || [fn]\n  );\n  return value;\n}\n\nfunction useModel(model: string | (() => Promise<GLBModel>)): ?GLBModel {\n  useDebugValue(model);\n  return useAsyncValue(\n    async () => {\n      if (typeof model === \"function\") {\n        return model();\n      }\n      if (typeof model === \"string\") {\n        const response = await fetch(model);\n        if (!response.ok) {\n          throw new Error(`failed to fetch GLTF model: ${response.status}`);\n        }\n        return parseGLB(await response.arrayBuffer());\n      }\n\n      /*:: (model: empty) */\n      throw new Error(`unsupported model prop: ${typeof model}`);\n    },\n    [model]\n  );\n}\n\nexport default function GLTFScene(props: Props) {\n  const { children, model, ...rest } = props;\n\n  const context = useContext(WorldviewReactContext);\n  const loadedModel = useModel(model);\n  useEffect(\n    () => {\n      if (context) {\n        context.onDirty();\n      }\n    },\n    [context, loadedModel]\n  );\n\n  if (!loadedModel) {\n    return null;\n  }\n\n  return (\n    <Command {...rest} reglCommand={drawModel} getChildrenForHitmap={getChildrenForHitmapWithOriginalMarker}>\n      {{ ...children, model: loadedModel, originalMarker: children }}\n    </Command>\n  );\n}\n","// @flow\n\n//  Copyright (c) 2018-present, GM Cruise LLC\n//\n//  This source code is licensed under the Apache License, Version 2.0,\n//  found in the LICENSE file in the root directory of this source tree.\n//  You may not use this file except in compliance with the License.\n\nimport React from \"react\";\n\nimport { withPose } from \"../utils/commandUtils\";\nimport { nonInstancedGetChildrenForHitmap } from \"../utils/getChildrenForHitmapDefaults\";\nimport Command, { type CommonCommandProps } from \"./Command\";\n\nconst DEFAULT_GRID_COLOR = [0.3, 0.3, 0.3, 1];\n\nexport function grid() {\n  return withPose({\n    vert: `\n    precision mediump float;\n    uniform mat4 projection, view;\n\n    attribute vec3 point;\n    attribute vec4 color;\n    varying vec4 fragColor;\n\n    void main () {\n      fragColor = color;\n      vec3 p = point;\n      gl_Position = projection * view * vec4(p, 1);\n    }\n    `,\n    frag: `\n      precision mediump float;\n      varying vec4 fragColor;\n      void main () {\n        gl_FragColor = fragColor;\n      }\n    `,\n    primitive: \"lines\",\n    attributes: {\n      point: (context, props) => {\n        const points = [];\n        const bound = props.count;\n        for (let i = -props.count; i < props.count; i++) {\n          points.push([-bound, i, 0]);\n          points.push([bound, i, 0]);\n          points.push([i, -bound, 0]);\n          points.push([i, bound, 0]);\n        }\n        return points;\n      },\n      color: (context, props) => {\n        const color = props.color || DEFAULT_GRID_COLOR;\n        return new Array(props.count * 4 * 2).fill(color);\n      },\n    },\n    count: (context, props) => {\n      // 8 points per count\n      const count = props.count * 4 * 2;\n      return count;\n    },\n  });\n}\n\ntype Props = {\n  ...CommonCommandProps,\n  count: number,\n};\n\n// useful for rendering a grid for debugging in stories\n\nexport default function Grid({ count, ...rest }: Props) {\n  const children = { count };\n  return (\n    <Command getChildrenForHitmap={nonInstancedGetChildrenForHitmap} {...rest} reglCommand={grid}>\n      {children}\n    </Command>\n  );\n}\n\nGrid.defaultProps = { count: 6 };\n","// @flow\n\n//  Copyright (c) 2018-present, GM Cruise LLC\n//\n//  This source code is licensed under the Apache License, Version 2.0,\n//  found in the LICENSE file in the root directory of this source tree.\n//  You may not use this file except in compliance with the License.\n\nimport * as React from \"react\";\n\nimport type { Point, Vec3, Dimensions, Pose } from \"../types\";\nimport { type WorldviewContextType } from \"../WorldviewContext\";\nimport WorldviewReactContext from \"../WorldviewReactContext\";\n\ntype PoseObj = { pose: Pose };\ntype RenderItemInput<T: PoseObj> = {\n  item: T,\n  coordinates: ?Vec3,\n  index: number,\n  dimension: Dimensions,\n};\n\ntype Props<T: PoseObj> = {\n  children: T[],\n  renderItem: (RenderItemInput<T>) => React.Node,\n};\n\ntype State = {\n  items: React.Node[],\n};\n\n// A command that renders arbitrary DOM nodes on top of the Worldview 3D scene.\n// It supplies coordinates to the `renderItem` prop for positioning DOM nodes relative to the canvas.\nexport default class Overlay<T: PoseObj> extends React.Component<Props<T>, State> {\n  _context: ?WorldviewContextType;\n  state = { items: [] };\n\n  componentDidMount() {\n    if (this._context) {\n      this._context.registerPaintCallback(this.paint);\n    }\n  }\n\n  componentWillUnmount = () => {\n    if (this._context) {\n      this._context.unregisterPaintCallback(this.paint);\n    }\n  };\n\n  paint = () => {\n    const context = this._context;\n    const dimension = context && context.dimension;\n    const { renderItem, children } = this.props;\n    if (!context || !dimension) {\n      return;\n    }\n    const items = children.map((item, index) => {\n      const coordinates = this.project(item.pose.position, context);\n      return renderItem({ item, index, coordinates, dimension });\n    });\n    this.setState({ items });\n  };\n\n  project = (point: Point, context: ?WorldviewContextType): ?Vec3 => {\n    if (!context || !context.initializedData) {\n      return;\n    }\n    const { dimension } = context;\n    const { camera } = context.initializedData;\n\n    const vec = [point.x, point.y, point.z];\n    const { left, top, width, height } = dimension;\n    const viewport = [left, top, width, height];\n    return camera.toScreenCoord(viewport, vec);\n  };\n\n  render() {\n    return (\n      <React.Fragment>\n        <WorldviewReactContext.Consumer>\n          {(ctx: ?WorldviewContextType) => {\n            if (ctx) {\n              this._context = ctx;\n            }\n            return this.state.items;\n          }}\n        </WorldviewReactContext.Consumer>\n      </React.Fragment>\n    );\n  }\n}\n","// @flow\n\n//  Copyright (c) 2018-present, GM Cruise LLC\n//\n//  This source code is licensed under the Apache License, Version 2.0,\n//  found in the LICENSE file in the root directory of this source tree.\n//  You may not use this file except in compliance with the License.\n\nimport * as React from \"react\";\n\nimport type { PointType, Regl } from \"../types\";\nimport { getVertexColors, pointToVec3, withPose } from \"../utils/commandUtils\";\nimport { createInstancedGetChildrenForHitmap } from \"../utils/getChildrenForHitmapDefaults\";\nimport Command, { type CommonCommandProps } from \"./Command\";\n\nconst points = (regl: Regl) => {\n  const [min, max] = regl.limits.pointSizeDims;\n  return withPose({\n    primitive: \"points\",\n    vert: `\n    precision mediump float;\n\n    #WITH_POSE\n\n    uniform mat4 projection, view;\n    uniform float pointSize;\n\n    attribute vec3 point;\n    attribute vec4 color;\n    varying vec4 fragColor;\n    void main () {\n      gl_PointSize = pointSize;\n      vec3 pos = applyPose(point);\n      gl_Position = projection * view * vec4(pos, 1);\n      fragColor = color;\n    }\n    `,\n    frag: `\n    precision mediump float;\n    varying vec4 fragColor;\n    void main () {\n      gl_FragColor = vec4(fragColor.x, fragColor.y, fragColor.z, 1);\n    }\n    `,\n    attributes: {\n      point: (context, props) => {\n        return props.points.map((point) => (Array.isArray(point) ? point : pointToVec3(point)));\n      },\n      color: (context, props) => {\n        const colors = getVertexColors(props);\n        return colors;\n      },\n    },\n\n    uniforms: {\n      pointSize: (context, props) => {\n        const size = props.scale.x || 1;\n        return Math.min(max, Math.max(min, size));\n      },\n    },\n\n    count: regl.prop(\"points.length\"),\n  });\n};\n\nconst getChildrenForHitmap = createInstancedGetChildrenForHitmap(1);\nexport default function Points(props: { ...CommonCommandProps, children: PointType[] }) {\n  return <Command getChildrenForHitmap={getChildrenForHitmap} {...props} reglCommand={points} />;\n}\n","// @flow\n\n//  Copyright (c) 2018-present, GM Cruise LLC\n//\n//  This source code is licensed under the Apache License, Version 2.0,\n//  found in the LICENSE file in the root directory of this source tree.\n//  You may not use this file except in compliance with the License.\n\nexport { default as Arrows } from \"./Arrows\";\nexport { default as Axes } from \"./Axes\";\nexport { default as Command, SUPPORTED_MOUSE_EVENTS } from \"./Command\";\nexport { default as Cones } from \"./Cones\";\nexport { default as Cubes } from \"./Cubes\";\nexport { default as Cylinders } from \"./Cylinders\";\nexport { default as DrawPolygons, Polygon, PolygonPoint } from \"./DrawPolygon/index\";\nexport { default as PolygonBuilder } from \"./DrawPolygon/PolygonBuilder\";\nexport { default as FilledPolygons } from \"./FilledPolygons\";\nexport { default as GLText } from \"./GLText\";\nexport { default as GLTFScene } from \"./GLTFScene\";\nexport { default as Grid } from \"./Grid\";\nexport { default as Lines } from \"./Lines\";\nexport { default as Overlay } from \"./Overlay\";\nexport { default as Points } from \"./Points\";\nexport { default as Spheres } from \"./Spheres\";\nexport { default as Text } from \"./Text\";\nexport { default as Triangles } from \"./Triangles\";\n"]},"metadata":{},"sourceType":"module"}