import { useState, useEffect, useRef } from 'react';

//

// A react hook which can be used to load async, disposable resources
// and fire the cleanup callback when the component unmounts.
// If the component unmounts before the async operation completes the
// resource will still be cleaned up once it finishes loading and an
// abort signal will be issued to the async load operation.
function useAbortable(defaultValue, action, cleanup, args) {
  const [result, setResult] = useState(defaultValue);
  let controller;
  useEffect(() => {
    controller = new AbortController();
    const promise = action(controller).then(result => {
      // If we're aborted don't set the result into state.
      // The cleanup will be called when the component unmounts.
      if (!controller.signal.aborted) {
        setResult(result);
      }

      return result;
    });
    return () => {
      setResult(defaultValue); // on unmount or args changing clean up the old value

      promise.then(cleanup);
      controller.abort();
    };
  }, args);
  return [result, () => controller.abort()];
}

//

function useCleanup(teardown) {
  useEffect(() => {
    return () => {
      teardown();
    };
  }, []);
}

//

function useEventListener(target, type, enable, handler, dependencies) {
  useEffect(() => {
    if (enable) {
      target.addEventListener(type, handler);
      return () => target.removeEventListener(type, handler);
    }
  }, [target, type, enable, ...dependencies]);
}

//

function useAnimationFrame(callback, disable, dependencies) {
  // persist the requestAnimationFrameId so the last refresh callback can be cancelled when component unmounts
  const rafId = useRef(); // start the loop when the component mounts and cancel the animation frame when unmounts
  // or related dependency changes

  function createAnimationFrame(callback) {
    rafId.current = requestAnimationFrame(timestamp => {
      createAnimationFrame(callback);
      return callback(timestamp);
    });
  }

  useEffect(() => {
    if (!disable) {
      createAnimationFrame(callback);
    }

    return function cleanup() {
      if (rafId.current) {
        cancelAnimationFrame(rafId.current);
      }
    };
  }, [callback, disable, ...dependencies]);
}

//  Copyright (c) 2018-present, GM Cruise LLC

export { useAbortable, useCleanup, useEventListener, useAnimationFrame };
//# sourceMappingURL=index.esm.js.map
